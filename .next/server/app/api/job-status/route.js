"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/job-status/route";
exports.ids = ["app/api/job-status/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjob-status%2Froute&page=%2Fapi%2Fjob-status%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjob-status%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjob-status%2Froute&page=%2Fapi%2Fjob-status%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjob-status%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_ethanhoppe_Desktop_AItravelagent_app_api_job_status_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/job-status/route.ts */ \"(rsc)/./app/api/job-status/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/job-status/route\",\n        pathname: \"/api/job-status\",\n        filename: \"route\",\n        bundlePath: \"app/api/job-status/route\"\n    },\n    resolvedPagePath: \"/Users/ethanhoppe/Desktop/AItravelagent/app/api/job-status/route.ts\",\n    nextConfigOutput,\n    userland: _Users_ethanhoppe_Desktop_AItravelagent_app_api_job_status_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/job-status/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZqb2Itc3RhdHVzJTJGcm91dGUmcGFnZT0lMkZhcGklMkZqb2Itc3RhdHVzJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGam9iLXN0YXR1cyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmV0aGFuaG9wcGUlMkZEZXNrdG9wJTJGQUl0cmF2ZWxhZ2VudCUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZldGhhbmhvcHBlJTJGRGVza3RvcCUyRkFJdHJhdmVsYWdlbnQmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ21CO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Lz9kZmJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi9Vc2Vycy9ldGhhbmhvcHBlL0Rlc2t0b3AvQUl0cmF2ZWxhZ2VudC9hcHAvYXBpL2pvYi1zdGF0dXMvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2pvYi1zdGF0dXMvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9qb2Itc3RhdHVzXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9qb2Itc3RhdHVzL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2V0aGFuaG9wcGUvRGVza3RvcC9BSXRyYXZlbGFnZW50L2FwcC9hcGkvam9iLXN0YXR1cy9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvam9iLXN0YXR1cy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjob-status%2Froute&page=%2Fapi%2Fjob-status%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjob-status%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/job-status/route.ts":
/*!*************************************!*\
  !*** ./app/api/job-status/route.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   maxDuration: () => (/* binding */ maxDuration),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _lib_itinerary_processor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/itinerary-processor */ \"(rsc)/./lib/itinerary-processor.ts\");\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../lib/logger */ \"(rsc)/./lib/logger.ts\");\n\n\n\n\n// Configure runtime\nconst runtime = \"nodejs\";\nconst maxDuration = 60; // 60 seconds - plenty for a status check\n// Use dynamic configurations\nconst dynamic = \"force-dynamic\";\n// Helper function to get DB-compatible ID (copied for debugging)\nfunction getDbCompatibleId(id) {\n    // If the ID is already numeric, return it as is\n    if (!isNaN(Number(id))) {\n        return Number(id);\n    }\n    // For job IDs that start with a timestamp (job_ or debug_), extract the timestamp\n    const timestampMatch = id.match(/^(job|debug|test)_(\\d+)/);\n    if (timestampMatch && !isNaN(Number(timestampMatch[2]))) {\n        // Use the timestamp portion as the numeric ID\n        return Number(timestampMatch[2]);\n    }\n    // For any other IDs, use a hash function to generate a numeric ID\n    let hash = 0;\n    const prime = 31; // Use a prime number for better distribution\n    for(let i = 0; i < id.length; i++){\n        // Get the character code\n        const char = id.charCodeAt(i);\n        // Multiply the current hash by the prime and add the character code\n        hash = Math.imul(hash, prime) + char | 0;\n    }\n    // Ensure positive number by using absolute value\n    return Math.abs(hash);\n}\nasync function GET(request) {\n    try {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.info(`Job status API called at ${new Date().toISOString()}`);\n        // Get the job ID from the query params\n        const { searchParams } = new URL(request.url);\n        const jobId = searchParams.get(\"jobId\");\n        if (!jobId) {\n            _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Missing jobId parameter\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Missing jobId parameter\"\n            }, {\n                status: 400\n            });\n        }\n        _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.info(`Checking status for job: ${jobId}`);\n        // Debug info about the job ID conversion for logging\n        const dbCompatibleId = getDbCompatibleId(jobId);\n        _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.debug(`Job ID conversion: \"${jobId}\" -> ${dbCompatibleId} (db-compatible)`);\n        // Get the job status from Supabase\n        const statusResult = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.getJobStatus)(jobId);\n        _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.info(`Job ${jobId} status result:`, statusResult);\n        // For completed jobs with raw results that haven't been processed yet,\n        // process them and return the processed data\n        if (statusResult.statusFound && statusResult.status === \"completed\" && statusResult.hasRawResult && !statusResult.result?.processed) {\n            try {\n                // Process the raw OpenAI response\n                const processedItinerary = (0,_lib_itinerary_processor__WEBPACK_IMPORTED_MODULE_2__.processRawResponse)(statusResult.rawResult);\n                // Return the processed itinerary along with the status\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    status: statusResult.status,\n                    itinerary: processedItinerary\n                });\n            } catch (processingError) {\n                _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error(`Error processing raw response for job ${jobId}:`, processingError);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    status: \"failed\",\n                    error: `Error processing response: ${processingError.message}`\n                });\n            }\n        }\n        // Return the status as-is if it's not a completed job with raw results\n        _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.info(`Returning job status: ${statusResult.status}`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            status: statusResult.status,\n            hasResult: statusResult.hasResult,\n            hasError: statusResult.hasError,\n            error: statusResult.error,\n            result: statusResult.result\n        });\n    } catch (error) {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Error in job status API:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: `Server error: ${error.message}`\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TzdDLHFEQUFZQSxDQUFDaUMsSUFBSSxDQUFDO29CQUN2QkMsUUFBUTtvQkFDUkYsT0FBTyxDQUFDLDJCQUEyQixFQUFFYSxnQkFBZ0JDLE9BQU8sQ0FBQyxDQUFDO2dCQUNoRTtZQUNGO1FBQ0Y7UUFFQSx1RUFBdUU7UUFDdkUzQywrQ0FBTUEsQ0FBQ3FCLElBQUksQ0FBQyxDQUFDLHNCQUFzQixFQUFFYSxhQUFhSCxNQUFNLENBQUMsQ0FBQztRQUMxRCxPQUFPbEMscURBQVlBLENBQUNpQyxJQUFJLENBQUM7WUFDdkJDLFFBQVFHLGFBQWFILE1BQU07WUFDM0JhLFdBQVdWLGFBQWFVLFNBQVM7WUFDakNDLFVBQVVYLGFBQWFXLFFBQVE7WUFDL0JoQixPQUFPSyxhQUFhTCxLQUFLO1lBQ3pCUSxRQUFRSCxhQUFhRyxNQUFNO1FBQzdCO0lBQ0YsRUFBRSxPQUFPUixPQUFZO1FBQ25CN0IsK0NBQU1BLENBQUM2QixLQUFLLENBQUMsNEJBQTRCQTtRQUN6QyxPQUFPaEMscURBQVlBLENBQUNpQyxJQUFJLENBQ3RCO1lBQUVELE9BQU8sQ0FBQyxjQUFjLEVBQUVBLE1BQU1jLE9BQU8sQ0FBQyxDQUFDO1FBQUMsR0FDMUM7WUFBRVosUUFBUTtRQUFJO0lBRWxCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10cmF2ZWwtYWdlbnQvLi9hcHAvYXBpL2pvYi1zdGF0dXMvcm91dGUudHM/ZDNkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBnZXRKb2JTdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9saWIvc3VwYWJhc2UnO1xuaW1wb3J0IHsgcHJvY2Vzc1Jhd1Jlc3BvbnNlIH0gZnJvbSAnLi4vLi4vLi4vbGliL2l0aW5lcmFyeS1wcm9jZXNzb3InO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vbGliL2xvZ2dlcic7XG5cbi8vIENvbmZpZ3VyZSBydW50aW1lXG5leHBvcnQgY29uc3QgcnVudGltZSA9ICdub2RlanMnO1xuZXhwb3J0IGNvbnN0IG1heER1cmF0aW9uID0gNjA7IC8vIDYwIHNlY29uZHMgLSBwbGVudHkgZm9yIGEgc3RhdHVzIGNoZWNrXG5cbi8vIFVzZSBkeW5hbWljIGNvbmZpZ3VyYXRpb25zXG5leHBvcnQgY29uc3QgZHluYW1pYyA9ICdmb3JjZS1keW5hbWljJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBEQi1jb21wYXRpYmxlIElEIChjb3BpZWQgZm9yIGRlYnVnZ2luZylcbmZ1bmN0aW9uIGdldERiQ29tcGF0aWJsZUlkKGlkOiBzdHJpbmcpOiBudW1iZXIge1xuICAvLyBJZiB0aGUgSUQgaXMgYWxyZWFkeSBudW1lcmljLCByZXR1cm4gaXQgYXMgaXNcbiAgaWYgKCFpc05hTihOdW1iZXIoaWQpKSkge1xuICAgIHJldHVybiBOdW1iZXIoaWQpO1xuICB9XG4gIFxuICAvLyBGb3Igam9iIElEcyB0aGF0IHN0YXJ0IHdpdGggYSB0aW1lc3RhbXAgKGpvYl8gb3IgZGVidWdfKSwgZXh0cmFjdCB0aGUgdGltZXN0YW1wXG4gIGNvbnN0IHRpbWVzdGFtcE1hdGNoID0gaWQubWF0Y2goL14oam9ifGRlYnVnfHRlc3QpXyhcXGQrKS8pO1xuICBpZiAodGltZXN0YW1wTWF0Y2ggJiYgIWlzTmFOKE51bWJlcih0aW1lc3RhbXBNYXRjaFsyXSkpKSB7XG4gICAgLy8gVXNlIHRoZSB0aW1lc3RhbXAgcG9ydGlvbiBhcyB0aGUgbnVtZXJpYyBJRFxuICAgIHJldHVybiBOdW1iZXIodGltZXN0YW1wTWF0Y2hbMl0pO1xuICB9XG5cbiAgLy8gRm9yIGFueSBvdGhlciBJRHMsIHVzZSBhIGhhc2ggZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBudW1lcmljIElEXG4gIGxldCBoYXNoID0gMDtcbiAgY29uc3QgcHJpbWUgPSAzMTsgLy8gVXNlIGEgcHJpbWUgbnVtYmVyIGZvciBiZXR0ZXIgZGlzdHJpYnV0aW9uXG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gR2V0IHRoZSBjaGFyYWN0ZXIgY29kZVxuICAgIGNvbnN0IGNoYXIgPSBpZC5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIE11bHRpcGx5IHRoZSBjdXJyZW50IGhhc2ggYnkgdGhlIHByaW1lIGFuZCBhZGQgdGhlIGNoYXJhY3RlciBjb2RlXG4gICAgaGFzaCA9IE1hdGguaW11bChoYXNoLCBwcmltZSkgKyBjaGFyIHwgMDtcbiAgfVxuICBcbiAgLy8gRW5zdXJlIHBvc2l0aXZlIG51bWJlciBieSB1c2luZyBhYnNvbHV0ZSB2YWx1ZVxuICByZXR1cm4gTWF0aC5hYnMoaGFzaCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogUmVxdWVzdCkge1xuICB0cnkge1xuICAgIGxvZ2dlci5pbmZvKGBKb2Igc3RhdHVzIEFQSSBjYWxsZWQgYXQgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCk7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBqb2IgSUQgZnJvbSB0aGUgcXVlcnkgcGFyYW1zXG4gICAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGNvbnN0IGpvYklkID0gc2VhcmNoUGFyYW1zLmdldCgnam9iSWQnKTtcbiAgICBcbiAgICBpZiAoIWpvYklkKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ01pc3Npbmcgam9iSWQgcGFyYW1ldGVyJyk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdNaXNzaW5nIGpvYklkIHBhcmFtZXRlcicgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBsb2dnZXIuaW5mbyhgQ2hlY2tpbmcgc3RhdHVzIGZvciBqb2I6ICR7am9iSWR9YCk7XG4gICAgXG4gICAgLy8gRGVidWcgaW5mbyBhYm91dCB0aGUgam9iIElEIGNvbnZlcnNpb24gZm9yIGxvZ2dpbmdcbiAgICBjb25zdCBkYkNvbXBhdGlibGVJZCA9IGdldERiQ29tcGF0aWJsZUlkKGpvYklkKTtcbiAgICBsb2dnZXIuZGVidWcoYEpvYiBJRCBjb252ZXJzaW9uOiBcIiR7am9iSWR9XCIgLT4gJHtkYkNvbXBhdGlibGVJZH0gKGRiLWNvbXBhdGlibGUpYCk7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBqb2Igc3RhdHVzIGZyb20gU3VwYWJhc2VcbiAgICBjb25zdCBzdGF0dXNSZXN1bHQgPSBhd2FpdCBnZXRKb2JTdGF0dXMoam9iSWQpO1xuICAgIFxuICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gc3RhdHVzIHJlc3VsdDpgLCBzdGF0dXNSZXN1bHQpO1xuICAgIFxuICAgIC8vIEZvciBjb21wbGV0ZWQgam9icyB3aXRoIHJhdyByZXN1bHRzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXQsXG4gICAgLy8gcHJvY2VzcyB0aGVtIGFuZCByZXR1cm4gdGhlIHByb2Nlc3NlZCBkYXRhXG4gICAgaWYgKFxuICAgICAgc3RhdHVzUmVzdWx0LnN0YXR1c0ZvdW5kICYmXG4gICAgICBzdGF0dXNSZXN1bHQuc3RhdHVzID09PSAnY29tcGxldGVkJyAmJlxuICAgICAgc3RhdHVzUmVzdWx0Lmhhc1Jhd1Jlc3VsdCAmJlxuICAgICAgIXN0YXR1c1Jlc3VsdC5yZXN1bHQ/LnByb2Nlc3NlZFxuICAgICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgcmF3IE9wZW5BSSByZXNwb25zZVxuICAgICAgICBjb25zdCBwcm9jZXNzZWRJdGluZXJhcnkgPSBwcm9jZXNzUmF3UmVzcG9uc2Uoc3RhdHVzUmVzdWx0LnJhd1Jlc3VsdCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXR1cm4gdGhlIHByb2Nlc3NlZCBpdGluZXJhcnkgYWxvbmcgd2l0aCB0aGUgc3RhdHVzXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXNSZXN1bHQuc3RhdHVzLFxuICAgICAgICAgIGl0aW5lcmFyeTogcHJvY2Vzc2VkSXRpbmVyYXJ5XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAocHJvY2Vzc2luZ0Vycm9yOiBhbnkpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIHJhdyByZXNwb25zZSBmb3Igam9iICR7am9iSWR9OmAsIHByb2Nlc3NpbmdFcnJvcik7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcbiAgICAgICAgICBlcnJvcjogYEVycm9yIHByb2Nlc3NpbmcgcmVzcG9uc2U6ICR7cHJvY2Vzc2luZ0Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmV0dXJuIHRoZSBzdGF0dXMgYXMtaXMgaWYgaXQncyBub3QgYSBjb21wbGV0ZWQgam9iIHdpdGggcmF3IHJlc3VsdHNcbiAgICBsb2dnZXIuaW5mbyhgUmV0dXJuaW5nIGpvYiBzdGF0dXM6ICR7c3RhdHVzUmVzdWx0LnN0YXR1c31gKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3RhdHVzOiBzdGF0dXNSZXN1bHQuc3RhdHVzLFxuICAgICAgaGFzUmVzdWx0OiBzdGF0dXNSZXN1bHQuaGFzUmVzdWx0LFxuICAgICAgaGFzRXJyb3I6IHN0YXR1c1Jlc3VsdC5oYXNFcnJvcixcbiAgICAgIGVycm9yOiBzdGF0dXNSZXN1bHQuZXJyb3IsXG4gICAgICByZXN1bHQ6IHN0YXR1c1Jlc3VsdC5yZXN1bHRcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW4gam9iIHN0YXR1cyBBUEk6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6IGBTZXJ2ZXIgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59ICJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJnZXRKb2JTdGF0dXMiLCJwcm9jZXNzUmF3UmVzcG9uc2UiLCJsb2dnZXIiLCJydW50aW1lIiwibWF4RHVyYXRpb24iLCJkeW5hbWljIiwiZ2V0RGJDb21wYXRpYmxlSWQiLCJpZCIsImlzTmFOIiwiTnVtYmVyIiwidGltZXN0YW1wTWF0Y2giLCJtYXRjaCIsImhhc2giLCJwcmltZSIsImkiLCJsZW5ndGgiLCJjaGFyIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJpbXVsIiwiYWJzIiwiR0VUIiwicmVxdWVzdCIsImluZm8iLCJEYXRlIiwidG9JU09TdHJpbmciLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJ1cmwiLCJqb2JJZCIsImdldCIsImVycm9yIiwianNvbiIsInN0YXR1cyIsImRiQ29tcGF0aWJsZUlkIiwiZGVidWciLCJzdGF0dXNSZXN1bHQiLCJzdGF0dXNGb3VuZCIsImhhc1Jhd1Jlc3VsdCIsInJlc3VsdCIsInByb2Nlc3NlZCIsInByb2Nlc3NlZEl0aW5lcmFyeSIsInJhd1Jlc3VsdCIsIml0aW5lcmFyeSIsInByb2Nlc3NpbmdFcnJvciIsIm1lc3NhZ2UiLCJoYXNSZXN1bHQiLCJoYXNFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/job-status/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/itinerary-processor.ts":
/*!************************************!*\
  !*** ./lib/itinerary-processor.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processRawResponse: () => (/* binding */ processRawResponse)\n/* harmony export */ });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ \"(rsc)/./lib/logger.ts\");\n\n/**\n * Processes the raw response from OpenAI into a structured itinerary object\n * with validation and normalization of data\n */ function processRawResponse(rawResponse) {\n    _logger__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Processing raw OpenAI response\", {\n        responseLength: rawResponse?.length || 0,\n        hasResponse: !!rawResponse\n    });\n    if (!rawResponse) {\n        _logger__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Received empty response from OpenAI\");\n        throw new Error(\"Received empty response from OpenAI\");\n    }\n    // Try to parse the JSON response\n    let parsedItinerary;\n    try {\n        // Clean up any potential markdown formatting\n        const cleanedResponse = cleanResponse(rawResponse);\n        parsedItinerary = JSON.parse(cleanedResponse);\n        _logger__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Successfully parsed OpenAI response as JSON\");\n    } catch (error) {\n        _logger__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Failed to parse OpenAI response as JSON:\", error);\n        _logger__WEBPACK_IMPORTED_MODULE_0__.logger.debug(\"Raw response:\", rawResponse.substring(0, 200) + \"...\");\n        throw new Error(`Failed to parse OpenAI response: ${error.message}`);\n    }\n    // Process and validate the itinerary\n    const processedItinerary = validateAndNormalizeItinerary(parsedItinerary);\n    _logger__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"Successfully processed and normalized itinerary data\");\n    return processedItinerary;\n}\n/**\n * Cleans the response string to handle potential formatting issues\n */ function cleanResponse(response) {\n    // Remove any potential markdown code block indicators\n    let cleaned = response.trim();\n    // Check if the response is wrapped in code blocks\n    if (cleaned.startsWith(\"```\") && cleaned.endsWith(\"```\")) {\n        // Remove the first line that might contain \"```json\"\n        cleaned = cleaned.substring(cleaned.indexOf(\"\\n\") + 1);\n        // Remove the closing code block\n        cleaned = cleaned.substring(0, cleaned.lastIndexOf(\"```\"));\n        cleaned = cleaned.trim();\n    }\n    // Handle potential JSON with newlines\n    return cleaned;\n}\n/**\n * Validates and normalizes an itinerary object\n */ function validateAndNormalizeItinerary(itinerary) {\n    if (!itinerary || typeof itinerary !== \"object\") {\n        _logger__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Itinerary is not an object\", {\n            itinerary\n        });\n        throw new Error(\"Invalid itinerary format: not an object\");\n    }\n    // Ensure the itinerary has the expected structure\n    const validatedItinerary = {\n        id: itinerary.id || `trip-${Date.now()}`,\n        title: itinerary.title || `Trip to ${itinerary.destination || \"Destination\"}`,\n        destination: itinerary.destination || \"Unknown Destination\",\n        dates: {\n            start: itinerary.dates?.start || new Date().toISOString().split(\"T\")[0],\n            end: itinerary.dates?.end\n        },\n        days: [],\n        budget: {\n            accommodation: 0,\n            food: 0,\n            activities: 0,\n            transport: 0,\n            total: 0\n        }\n    };\n    // Process days and activities\n    if (Array.isArray(itinerary.days)) {\n        for(let i = 0; i < itinerary.days.length; i++){\n            const day = itinerary.days[i];\n            if (!day || typeof day !== \"object\") continue;\n            const processedDay = {\n                date: day.date || null,\n                activities: []\n            };\n            // Process activities for this day\n            if (Array.isArray(day.activities)) {\n                for(let j = 0; j < day.activities.length; j++){\n                    const activity = day.activities[j];\n                    if (!activity || typeof activity !== \"object\") continue;\n                    // Ensure coordinates are valid\n                    let coordinates = {\n                        lat: 0,\n                        lng: 0\n                    };\n                    if (activity.coordinates && typeof activity.coordinates === \"object\") {\n                        coordinates = {\n                            lat: parseFloat(String(activity.coordinates.lat)) || 0,\n                            lng: parseFloat(String(activity.coordinates.lng)) || 0\n                        };\n                    }\n                    // Parse cost as number if it's not already\n                    let cost = 0;\n                    if (activity.cost !== undefined) {\n                        cost = typeof activity.cost === \"number\" ? activity.cost : parseFloat(String(activity.cost)) || 0;\n                    }\n                    // Add processed activity to the day\n                    processedDay.activities.push({\n                        id: activity.id || `act-${i}-${j}`,\n                        time: activity.time || \"\",\n                        title: activity.title || `Activity ${j + 1}`,\n                        description: activity.description || \"\",\n                        location: activity.location || \"\",\n                        coordinates,\n                        cost,\n                        image: activity.image || \"\"\n                    });\n                }\n            }\n            validatedItinerary.days.push(processedDay);\n        }\n    }\n    // Process budget\n    if (itinerary.budget && typeof itinerary.budget === \"object\") {\n        const budget = itinerary.budget;\n        // Get budget values and convert to numbers if needed\n        const accommodation = typeof budget.accommodation === \"number\" ? budget.accommodation : parseFloat(String(budget.accommodation)) || 0;\n        const food = typeof budget.food === \"number\" ? budget.food : parseFloat(String(budget.food)) || 0;\n        const activities = typeof budget.activities === \"number\" ? budget.activities : parseFloat(String(budget.activities)) || 0;\n        const transport = typeof budget.transport === \"number\" ? budget.transport : parseFloat(String(budget.transport)) || 0;\n        // Calculate total from components if not provided\n        let total = typeof budget.total === \"number\" ? budget.total : parseFloat(String(budget.total)) || 0;\n        // If total is 0 or NaN, calculate from components\n        if (!total || isNaN(total)) {\n            total = accommodation + food + activities + transport;\n        }\n        validatedItinerary.budget = {\n            accommodation,\n            food,\n            activities,\n            transport,\n            total\n        };\n    } else {\n        // If no budget provided, calculate from activities\n        let totalActivityCost = 0;\n        // Sum up all activity costs\n        if (validatedItinerary.days) {\n            for (const day of validatedItinerary.days){\n                if (day.activities) {\n                    for (const activity of day.activities){\n                        if (typeof activity.cost === \"number\") {\n                            totalActivityCost += activity.cost;\n                        }\n                    }\n                }\n            }\n        }\n        // Set a default budget based on activity costs\n        validatedItinerary.budget = {\n            accommodation: Math.round(totalActivityCost * 0.4),\n            food: Math.round(totalActivityCost * 0.3),\n            activities: totalActivityCost,\n            transport: Math.round(totalActivityCost * 0.2),\n            total: totalActivityCost + Math.round(totalActivityCost * 0.4) + Math.round(totalActivityCost * 0.3) + Math.round(totalActivityCost * 0.2)\n        };\n    }\n    return validatedItinerary;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztZQUNBQztZQUNBQztZQUNBQztRQUNGO0lBQ0YsT0FBTztRQUNMLG1EQUFtRDtRQUNuRCxJQUFJc0Isb0JBQW9CO1FBRXhCLDRCQUE0QjtRQUM1QixJQUFJdkMsbUJBQW1CVyxJQUFJLEVBQUU7WUFDM0IsS0FBSyxNQUFNVSxPQUFPckIsbUJBQW1CVyxJQUFJLENBQUU7Z0JBQ3pDLElBQUlVLElBQUlOLFVBQVUsRUFBRTtvQkFDbEIsS0FBSyxNQUFNVSxZQUFZSixJQUFJTixVQUFVLENBQUU7d0JBQ3JDLElBQUksT0FBT1UsU0FBU00sSUFBSSxLQUFLLFVBQVU7NEJBQ3JDUSxxQkFBcUJkLFNBQVNNLElBQUk7d0JBQ3BDO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLCtDQUErQztRQUMvQy9CLG1CQUFtQlksTUFBTSxHQUFHO1lBQzFCQyxlQUFlMkIsS0FBS0MsS0FBSyxDQUFDRixvQkFBb0I7WUFDOUN6QixNQUFNMEIsS0FBS0MsS0FBSyxDQUFDRixvQkFBb0I7WUFDckN4QixZQUFZd0I7WUFDWnZCLFdBQVd3QixLQUFLQyxLQUFLLENBQUNGLG9CQUFvQjtZQUMxQ3RCLE9BQU9zQixvQkFDTEMsS0FBS0MsS0FBSyxDQUFDRixvQkFBb0IsT0FDL0JDLEtBQUtDLEtBQUssQ0FBQ0Ysb0JBQW9CLE9BQy9CQyxLQUFLQyxLQUFLLENBQUNGLG9CQUFvQjtRQUNuQztJQUNGO0lBRUEsT0FBT3ZDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10cmF2ZWwtYWdlbnQvLi9saWIvaXRpbmVyYXJ5LXByb2Nlc3Nvci50cz81NGJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcblxudHlwZSBEYXlUeXBlID0ge1xuICBkYXRlPzogc3RyaW5nO1xuICBhY3Rpdml0aWVzPzogQXJyYXk8e1xuICAgIGlkPzogc3RyaW5nO1xuICAgIHRpbWU/OiBzdHJpbmc7XG4gICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgbG9jYXRpb24/OiBzdHJpbmc7XG4gICAgY29vcmRpbmF0ZXM/OiB7XG4gICAgICBsYXQ6IG51bWJlcjtcbiAgICAgIGxuZzogbnVtYmVyO1xuICAgIH07XG4gICAgY29zdD86IG51bWJlcjtcbiAgICBpbWFnZT86IHN0cmluZztcbiAgfT47XG59O1xuXG50eXBlIFByb2Nlc3NlZEl0aW5lcmFyeSA9IHtcbiAgaWQ/OiBzdHJpbmc7XG4gIHRpdGxlPzogc3RyaW5nO1xuICBkZXN0aW5hdGlvbj86IHN0cmluZztcbiAgZGF0ZXM/OiB7XG4gICAgc3RhcnQ/OiBzdHJpbmc7XG4gICAgZW5kPzogc3RyaW5nO1xuICB9O1xuICBkYXlzPzogRGF5VHlwZVtdO1xuICBidWRnZXQ/OiB7XG4gICAgYWNjb21tb2RhdGlvbj86IG51bWJlcjtcbiAgICBmb29kPzogbnVtYmVyO1xuICAgIGFjdGl2aXRpZXM/OiBudW1iZXI7XG4gICAgdHJhbnNwb3J0PzogbnVtYmVyO1xuICAgIHRvdGFsPzogbnVtYmVyO1xuICB9O1xuICBlcnJvcj86IHN0cmluZztcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSByYXcgcmVzcG9uc2UgZnJvbSBPcGVuQUkgaW50byBhIHN0cnVjdHVyZWQgaXRpbmVyYXJ5IG9iamVjdFxuICogd2l0aCB2YWxpZGF0aW9uIGFuZCBub3JtYWxpemF0aW9uIG9mIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NSYXdSZXNwb25zZShyYXdSZXNwb25zZTogc3RyaW5nKTogUHJvY2Vzc2VkSXRpbmVyYXJ5IHtcbiAgbG9nZ2VyLmluZm8oJ1Byb2Nlc3NpbmcgcmF3IE9wZW5BSSByZXNwb25zZScsIHsgXG4gICAgcmVzcG9uc2VMZW5ndGg6IHJhd1Jlc3BvbnNlPy5sZW5ndGggfHwgMCxcbiAgICBoYXNSZXNwb25zZTogISFyYXdSZXNwb25zZVxuICB9KTtcbiAgXG4gIGlmICghcmF3UmVzcG9uc2UpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ1JlY2VpdmVkIGVtcHR5IHJlc3BvbnNlIGZyb20gT3BlbkFJJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXZlZCBlbXB0eSByZXNwb25zZSBmcm9tIE9wZW5BSScpO1xuICB9XG4gIFxuICAvLyBUcnkgdG8gcGFyc2UgdGhlIEpTT04gcmVzcG9uc2VcbiAgbGV0IHBhcnNlZEl0aW5lcmFyeTogYW55O1xuICB0cnkge1xuICAgIC8vIENsZWFuIHVwIGFueSBwb3RlbnRpYWwgbWFya2Rvd24gZm9ybWF0dGluZ1xuICAgIGNvbnN0IGNsZWFuZWRSZXNwb25zZSA9IGNsZWFuUmVzcG9uc2UocmF3UmVzcG9uc2UpO1xuICAgIHBhcnNlZEl0aW5lcmFyeSA9IEpTT04ucGFyc2UoY2xlYW5lZFJlc3BvbnNlKTtcbiAgICBsb2dnZXIuaW5mbygnU3VjY2Vzc2Z1bGx5IHBhcnNlZCBPcGVuQUkgcmVzcG9uc2UgYXMgSlNPTicpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgT3BlbkFJIHJlc3BvbnNlIGFzIEpTT046JywgZXJyb3IpO1xuICAgIGxvZ2dlci5kZWJ1ZygnUmF3IHJlc3BvbnNlOicsIHJhd1Jlc3BvbnNlLnN1YnN0cmluZygwLCAyMDApICsgJy4uLicpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIE9wZW5BSSByZXNwb25zZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG4gIFxuICAvLyBQcm9jZXNzIGFuZCB2YWxpZGF0ZSB0aGUgaXRpbmVyYXJ5XG4gIGNvbnN0IHByb2Nlc3NlZEl0aW5lcmFyeSA9IHZhbGlkYXRlQW5kTm9ybWFsaXplSXRpbmVyYXJ5KHBhcnNlZEl0aW5lcmFyeSk7XG4gIGxvZ2dlci5pbmZvKCdTdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIGFuZCBub3JtYWxpemVkIGl0aW5lcmFyeSBkYXRhJyk7XG4gIFxuICByZXR1cm4gcHJvY2Vzc2VkSXRpbmVyYXJ5O1xufVxuXG4vKipcbiAqIENsZWFucyB0aGUgcmVzcG9uc2Ugc3RyaW5nIHRvIGhhbmRsZSBwb3RlbnRpYWwgZm9ybWF0dGluZyBpc3N1ZXNcbiAqL1xuZnVuY3Rpb24gY2xlYW5SZXNwb25zZShyZXNwb25zZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gUmVtb3ZlIGFueSBwb3RlbnRpYWwgbWFya2Rvd24gY29kZSBibG9jayBpbmRpY2F0b3JzXG4gIGxldCBjbGVhbmVkID0gcmVzcG9uc2UudHJpbSgpO1xuICBcbiAgLy8gQ2hlY2sgaWYgdGhlIHJlc3BvbnNlIGlzIHdyYXBwZWQgaW4gY29kZSBibG9ja3NcbiAgaWYgKGNsZWFuZWQuc3RhcnRzV2l0aCgnYGBgJykgJiYgY2xlYW5lZC5lbmRzV2l0aCgnYGBgJykpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGxpbmUgdGhhdCBtaWdodCBjb250YWluIFwiYGBganNvblwiXG4gICAgY2xlYW5lZCA9IGNsZWFuZWQuc3Vic3RyaW5nKGNsZWFuZWQuaW5kZXhPZignXFxuJykgKyAxKTtcbiAgICAvLyBSZW1vdmUgdGhlIGNsb3NpbmcgY29kZSBibG9ja1xuICAgIGNsZWFuZWQgPSBjbGVhbmVkLnN1YnN0cmluZygwLCBjbGVhbmVkLmxhc3RJbmRleE9mKCdgYGAnKSk7XG4gICAgY2xlYW5lZCA9IGNsZWFuZWQudHJpbSgpO1xuICB9XG4gIFxuICAvLyBIYW5kbGUgcG90ZW50aWFsIEpTT04gd2l0aCBuZXdsaW5lc1xuICByZXR1cm4gY2xlYW5lZDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYW5kIG5vcm1hbGl6ZXMgYW4gaXRpbmVyYXJ5IG9iamVjdFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUl0aW5lcmFyeShpdGluZXJhcnk6IGFueSk6IFByb2Nlc3NlZEl0aW5lcmFyeSB7XG4gIGlmICghaXRpbmVyYXJ5IHx8IHR5cGVvZiBpdGluZXJhcnkgIT09ICdvYmplY3QnKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdJdGluZXJhcnkgaXMgbm90IGFuIG9iamVjdCcsIHsgaXRpbmVyYXJ5IH0pO1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpdGluZXJhcnkgZm9ybWF0OiBub3QgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgXG4gIC8vIEVuc3VyZSB0aGUgaXRpbmVyYXJ5IGhhcyB0aGUgZXhwZWN0ZWQgc3RydWN0dXJlXG4gIGNvbnN0IHZhbGlkYXRlZEl0aW5lcmFyeTogUHJvY2Vzc2VkSXRpbmVyYXJ5ID0ge1xuICAgIGlkOiBpdGluZXJhcnkuaWQgfHwgYHRyaXAtJHtEYXRlLm5vdygpfWAsXG4gICAgdGl0bGU6IGl0aW5lcmFyeS50aXRsZSB8fCBgVHJpcCB0byAke2l0aW5lcmFyeS5kZXN0aW5hdGlvbiB8fCAnRGVzdGluYXRpb24nfWAsXG4gICAgZGVzdGluYXRpb246IGl0aW5lcmFyeS5kZXN0aW5hdGlvbiB8fCAnVW5rbm93biBEZXN0aW5hdGlvbicsXG4gICAgZGF0ZXM6IHtcbiAgICAgIHN0YXJ0OiBpdGluZXJhcnkuZGF0ZXM/LnN0YXJ0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgZW5kOiBpdGluZXJhcnkuZGF0ZXM/LmVuZFxuICAgIH0sXG4gICAgZGF5czogW10sXG4gICAgYnVkZ2V0OiB7XG4gICAgICBhY2NvbW1vZGF0aW9uOiAwLFxuICAgICAgZm9vZDogMCxcbiAgICAgIGFjdGl2aXRpZXM6IDAsXG4gICAgICB0cmFuc3BvcnQ6IDAsXG4gICAgICB0b3RhbDogMFxuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFByb2Nlc3MgZGF5cyBhbmQgYWN0aXZpdGllc1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGluZXJhcnkuZGF5cykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0aW5lcmFyeS5kYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXkgPSBpdGluZXJhcnkuZGF5c1tpXTtcbiAgICAgIGlmICghZGF5IHx8IHR5cGVvZiBkYXkgIT09ICdvYmplY3QnKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgcHJvY2Vzc2VkRGF5OiBEYXlUeXBlID0ge1xuICAgICAgICBkYXRlOiBkYXkuZGF0ZSB8fCBudWxsLFxuICAgICAgICBhY3Rpdml0aWVzOiBbXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhY3Rpdml0aWVzIGZvciB0aGlzIGRheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF5LmFjdGl2aXRpZXMpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF5LmFjdGl2aXRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBhY3Rpdml0eSA9IGRheS5hY3Rpdml0aWVzW2pdO1xuICAgICAgICAgIGlmICghYWN0aXZpdHkgfHwgdHlwZW9mIGFjdGl2aXR5ICE9PSAnb2JqZWN0JykgY29udGludWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRW5zdXJlIGNvb3JkaW5hdGVzIGFyZSB2YWxpZFxuICAgICAgICAgIGxldCBjb29yZGluYXRlcyA9IHsgbGF0OiAwLCBsbmc6IDAgfTtcbiAgICAgICAgICBpZiAoYWN0aXZpdHkuY29vcmRpbmF0ZXMgJiYgdHlwZW9mIGFjdGl2aXR5LmNvb3JkaW5hdGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgICAgIGxhdDogcGFyc2VGbG9hdChTdHJpbmcoYWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0KSkgfHwgMCxcbiAgICAgICAgICAgICAgbG5nOiBwYXJzZUZsb2F0KFN0cmluZyhhY3Rpdml0eS5jb29yZGluYXRlcy5sbmcpKSB8fCAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQYXJzZSBjb3N0IGFzIG51bWJlciBpZiBpdCdzIG5vdCBhbHJlYWR5XG4gICAgICAgICAgbGV0IGNvc3QgPSAwO1xuICAgICAgICAgIGlmIChhY3Rpdml0eS5jb3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvc3QgPSB0eXBlb2YgYWN0aXZpdHkuY29zdCA9PT0gJ251bWJlcicgPyBcbiAgICAgICAgICAgICAgYWN0aXZpdHkuY29zdCA6IFxuICAgICAgICAgICAgICBwYXJzZUZsb2F0KFN0cmluZyhhY3Rpdml0eS5jb3N0KSkgfHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIHByb2Nlc3NlZCBhY3Rpdml0eSB0byB0aGUgZGF5XG4gICAgICAgICAgcHJvY2Vzc2VkRGF5LmFjdGl2aXRpZXMhLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGFjdGl2aXR5LmlkIHx8IGBhY3QtJHtpfS0ke2p9YCxcbiAgICAgICAgICAgIHRpbWU6IGFjdGl2aXR5LnRpbWUgfHwgJycsXG4gICAgICAgICAgICB0aXRsZTogYWN0aXZpdHkudGl0bGUgfHwgYEFjdGl2aXR5ICR7aisxfWAsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYWN0aXZpdHkuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICBsb2NhdGlvbjogYWN0aXZpdHkubG9jYXRpb24gfHwgJycsXG4gICAgICAgICAgICBjb29yZGluYXRlcyxcbiAgICAgICAgICAgIGNvc3QsXG4gICAgICAgICAgICBpbWFnZTogYWN0aXZpdHkuaW1hZ2UgfHwgJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB2YWxpZGF0ZWRJdGluZXJhcnkuZGF5cyEucHVzaChwcm9jZXNzZWREYXkpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUHJvY2VzcyBidWRnZXRcbiAgaWYgKGl0aW5lcmFyeS5idWRnZXQgJiYgdHlwZW9mIGl0aW5lcmFyeS5idWRnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgYnVkZ2V0ID0gaXRpbmVyYXJ5LmJ1ZGdldDtcbiAgICBcbiAgICAvLyBHZXQgYnVkZ2V0IHZhbHVlcyBhbmQgY29udmVydCB0byBudW1iZXJzIGlmIG5lZWRlZFxuICAgIGNvbnN0IGFjY29tbW9kYXRpb24gPSB0eXBlb2YgYnVkZ2V0LmFjY29tbW9kYXRpb24gPT09ICdudW1iZXInID8gXG4gICAgICBidWRnZXQuYWNjb21tb2RhdGlvbiA6IFxuICAgICAgcGFyc2VGbG9hdChTdHJpbmcoYnVkZ2V0LmFjY29tbW9kYXRpb24pKSB8fCAwO1xuICAgICAgXG4gICAgY29uc3QgZm9vZCA9IHR5cGVvZiBidWRnZXQuZm9vZCA9PT0gJ251bWJlcicgPyBcbiAgICAgIGJ1ZGdldC5mb29kIDogXG4gICAgICBwYXJzZUZsb2F0KFN0cmluZyhidWRnZXQuZm9vZCkpIHx8IDA7XG4gICAgICBcbiAgICBjb25zdCBhY3Rpdml0aWVzID0gdHlwZW9mIGJ1ZGdldC5hY3Rpdml0aWVzID09PSAnbnVtYmVyJyA/IFxuICAgICAgYnVkZ2V0LmFjdGl2aXRpZXMgOiBcbiAgICAgIHBhcnNlRmxvYXQoU3RyaW5nKGJ1ZGdldC5hY3Rpdml0aWVzKSkgfHwgMDtcbiAgICAgIFxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHR5cGVvZiBidWRnZXQudHJhbnNwb3J0ID09PSAnbnVtYmVyJyA/IFxuICAgICAgYnVkZ2V0LnRyYW5zcG9ydCA6IFxuICAgICAgcGFyc2VGbG9hdChTdHJpbmcoYnVkZ2V0LnRyYW5zcG9ydCkpIHx8IDA7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIGZyb20gY29tcG9uZW50cyBpZiBub3QgcHJvdmlkZWRcbiAgICBsZXQgdG90YWwgPSB0eXBlb2YgYnVkZ2V0LnRvdGFsID09PSAnbnVtYmVyJyA/IFxuICAgICAgYnVkZ2V0LnRvdGFsIDogXG4gICAgICBwYXJzZUZsb2F0KFN0cmluZyhidWRnZXQudG90YWwpKSB8fCAwO1xuICAgICAgXG4gICAgLy8gSWYgdG90YWwgaXMgMCBvciBOYU4sIGNhbGN1bGF0ZSBmcm9tIGNvbXBvbmVudHNcbiAgICBpZiAoIXRvdGFsIHx8IGlzTmFOKHRvdGFsKSkge1xuICAgICAgdG90YWwgPSBhY2NvbW1vZGF0aW9uICsgZm9vZCArIGFjdGl2aXRpZXMgKyB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIFxuICAgIHZhbGlkYXRlZEl0aW5lcmFyeS5idWRnZXQgPSB7XG4gICAgICBhY2NvbW1vZGF0aW9uLFxuICAgICAgZm9vZCxcbiAgICAgIGFjdGl2aXRpZXMsXG4gICAgICB0cmFuc3BvcnQsXG4gICAgICB0b3RhbFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbm8gYnVkZ2V0IHByb3ZpZGVkLCBjYWxjdWxhdGUgZnJvbSBhY3Rpdml0aWVzXG4gICAgbGV0IHRvdGFsQWN0aXZpdHlDb3N0ID0gMDtcbiAgICBcbiAgICAvLyBTdW0gdXAgYWxsIGFjdGl2aXR5IGNvc3RzXG4gICAgaWYgKHZhbGlkYXRlZEl0aW5lcmFyeS5kYXlzKSB7XG4gICAgICBmb3IgKGNvbnN0IGRheSBvZiB2YWxpZGF0ZWRJdGluZXJhcnkuZGF5cykge1xuICAgICAgICBpZiAoZGF5LmFjdGl2aXRpZXMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIGRheS5hY3Rpdml0aWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFjdGl2aXR5LmNvc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHRvdGFsQWN0aXZpdHlDb3N0ICs9IGFjdGl2aXR5LmNvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBhIGRlZmF1bHQgYnVkZ2V0IGJhc2VkIG9uIGFjdGl2aXR5IGNvc3RzXG4gICAgdmFsaWRhdGVkSXRpbmVyYXJ5LmJ1ZGdldCA9IHtcbiAgICAgIGFjY29tbW9kYXRpb246IE1hdGgucm91bmQodG90YWxBY3Rpdml0eUNvc3QgKiAwLjQpLCAvLyA0MCUgb2YgdG90YWwgZm9yIGFjY29tbW9kYXRpb25cbiAgICAgIGZvb2Q6IE1hdGgucm91bmQodG90YWxBY3Rpdml0eUNvc3QgKiAwLjMpLCAvLyAzMCUgZm9yIGZvb2RcbiAgICAgIGFjdGl2aXRpZXM6IHRvdGFsQWN0aXZpdHlDb3N0LFxuICAgICAgdHJhbnNwb3J0OiBNYXRoLnJvdW5kKHRvdGFsQWN0aXZpdHlDb3N0ICogMC4yKSwgLy8gMjAlIGZvciB0cmFuc3BvcnRcbiAgICAgIHRvdGFsOiB0b3RhbEFjdGl2aXR5Q29zdCArIFxuICAgICAgICBNYXRoLnJvdW5kKHRvdGFsQWN0aXZpdHlDb3N0ICogMC40KSArIFxuICAgICAgICBNYXRoLnJvdW5kKHRvdGFsQWN0aXZpdHlDb3N0ICogMC4zKSArIFxuICAgICAgICBNYXRoLnJvdW5kKHRvdGFsQWN0aXZpdHlDb3N0ICogMC4yKVxuICAgIH07XG4gIH1cbiAgXG4gIHJldHVybiB2YWxpZGF0ZWRJdGluZXJhcnk7XG59ICJdLCJuYW1lcyI6WyJsb2dnZXIiLCJwcm9jZXNzUmF3UmVzcG9uc2UiLCJyYXdSZXNwb25zZSIsImluZm8iLCJyZXNwb25zZUxlbmd0aCIsImxlbmd0aCIsImhhc1Jlc3BvbnNlIiwiZXJyb3IiLCJFcnJvciIsInBhcnNlZEl0aW5lcmFyeSIsImNsZWFuZWRSZXNwb25zZSIsImNsZWFuUmVzcG9uc2UiLCJKU09OIiwicGFyc2UiLCJkZWJ1ZyIsInN1YnN0cmluZyIsIm1lc3NhZ2UiLCJwcm9jZXNzZWRJdGluZXJhcnkiLCJ2YWxpZGF0ZUFuZE5vcm1hbGl6ZUl0aW5lcmFyeSIsInJlc3BvbnNlIiwiY2xlYW5lZCIsInRyaW0iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJpdGluZXJhcnkiLCJ2YWxpZGF0ZWRJdGluZXJhcnkiLCJpZCIsIkRhdGUiLCJub3ciLCJ0aXRsZSIsImRlc3RpbmF0aW9uIiwiZGF0ZXMiLCJzdGFydCIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJlbmQiLCJkYXlzIiwiYnVkZ2V0IiwiYWNjb21tb2RhdGlvbiIsImZvb2QiLCJhY3Rpdml0aWVzIiwidHJhbnNwb3J0IiwidG90YWwiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwiZGF5IiwicHJvY2Vzc2VkRGF5IiwiZGF0ZSIsImoiLCJhY3Rpdml0eSIsImNvb3JkaW5hdGVzIiwibGF0IiwibG5nIiwicGFyc2VGbG9hdCIsIlN0cmluZyIsImNvc3QiLCJ1bmRlZmluZWQiLCJwdXNoIiwidGltZSIsImRlc2NyaXB0aW9uIiwibG9jYXRpb24iLCJpbWFnZSIsImlzTmFOIiwidG90YWxBY3Rpdml0eUNvc3QiLCJNYXRoIiwicm91bmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/itinerary-processor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/logger.ts":
/*!***********************!*\
  !*** ./lib/logger.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLogger: () => (/* binding */ createLogger),\n/* harmony export */   logger: () => (/* binding */ logger)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n// Advanced logger utility for structured logging with context\n\n\n\n// Configure log file path - default to logs directory in project root\nconst LOG_DIR = process.env.LOG_DIR || \"logs\";\nconst LOG_FILE = process.env.LOG_FILE || \"app.log\";\nconst MAX_LOG_SIZE = 5 * 1024 * 1024; // 5MB max log file size\nconst LOG_LEVEL = process.env.LOG_LEVEL || \"info\";\n// Ensure log directory exists\ntry {\n    if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(LOG_DIR)) {\n        fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(LOG_DIR, {\n            recursive: true\n        });\n    }\n} catch (err) {\n    console.error(\"Failed to create log directory:\", err);\n}\n// Define log levels as numbers for comparisons\nconst logLevelValues = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3\n};\n/**\n * Write log to file with rotation\n */ function writeToFile(message) {\n    try {\n        const logPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(LOG_DIR, LOG_FILE);\n        // Check if log file exists and if it's too large\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(logPath)) {\n            const stats = fs__WEBPACK_IMPORTED_MODULE_0___default().statSync(logPath);\n            if (stats.size > MAX_LOG_SIZE) {\n                // Create backup of current log file with timestamp\n                const timestamp = new Date().toISOString().replace(/:/g, \"-\");\n                const backupPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(LOG_DIR, `${LOG_FILE}.${timestamp}.backup`);\n                fs__WEBPACK_IMPORTED_MODULE_0___default().renameSync(logPath, backupPath);\n            }\n        }\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.appendFileSync)(logPath, message + \"\\n\");\n    } catch (err) {\n        console.error(\"Failed to write to log file:\", err);\n    }\n}\n/**\n * Format object for logging - handles circular refs and formats nicely\n */ function formatObject(obj) {\n    try {\n        // Remove circular references\n        const seen = new WeakSet();\n        const safeObj = JSON.stringify(obj, (key, value)=>{\n            if (typeof value === \"object\" && value !== null) {\n                if (seen.has(value)) {\n                    return \"[Circular]\";\n                }\n                seen.add(value);\n            }\n            return value;\n        }, 2);\n        return safeObj;\n    } catch (err) {\n        return `[Unformattable Object: ${err}]`;\n    }\n}\n/**\n * Main logger function\n */ function logWithLevel(level, context, message, ...args) {\n    // Skip logs below current level\n    if (logLevelValues[level] < logLevelValues[LOG_LEVEL]) {\n        return;\n    }\n    const timestamp = new Date().toISOString();\n    const formattedArgs = args.map((arg)=>typeof arg === \"object\" && arg !== null ? formatObject(arg) : String(arg)).join(\" \");\n    const logEntry = `[${timestamp}] [${level.toUpperCase()}] [${context}] ${message} ${formattedArgs}`;\n    // Always log to console for immediate feedback\n    if (level === \"error\") {\n        console.error(logEntry);\n    } else if (level === \"warn\") {\n        console.warn(logEntry);\n    } else {\n        console.log(logEntry);\n    }\n    // Also write to log file\n    writeToFile(logEntry);\n}\n/**\n * Create a logger for a specific context\n */ function createLogger(context) {\n    return {\n        debug: (message, ...args)=>logWithLevel(\"debug\", context, message, ...args),\n        info: (message, ...args)=>logWithLevel(\"info\", context, message, ...args),\n        warn: (message, ...args)=>logWithLevel(\"warn\", context, message, ...args),\n        error: (message, ...args)=>logWithLevel(\"error\", context, message, ...args)\n    };\n}\n// Export a default logger\nconst logger = createLogger(\"app\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Qy9DLElBQUlILFVBQVUsU0FBUztRQUNyQi9CLFFBQVFDLEtBQUssQ0FBQ3FDO0lBQ2hCLE9BQU8sSUFBSVAsVUFBVSxRQUFRO1FBQzNCL0IsUUFBUUssSUFBSSxDQUFDaUM7SUFDZixPQUFPO1FBQ0x0QyxRQUFRd0MsR0FBRyxDQUFDRjtJQUNkO0lBRUEseUJBQXlCO0lBQ3pCaEMsWUFBWWdDO0FBQ2Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNHLGFBQWFULE9BQWU7SUFDMUMsT0FBTztRQUNMN0IsT0FBTyxDQUFDSSxTQUFpQixHQUFHMEIsT0FBZ0JILGFBQWEsU0FBU0UsU0FBU3pCLFlBQVkwQjtRQUN2RjdCLE1BQU0sQ0FBQ0csU0FBaUIsR0FBRzBCLE9BQWdCSCxhQUFhLFFBQVFFLFNBQVN6QixZQUFZMEI7UUFDckY1QixNQUFNLENBQUNFLFNBQWlCLEdBQUcwQixPQUFnQkgsYUFBYSxRQUFRRSxTQUFTekIsWUFBWTBCO1FBQ3JGaEMsT0FBTyxDQUFDTSxTQUFpQixHQUFHMEIsT0FBZ0JILGFBQWEsU0FBU0UsU0FBU3pCLFlBQVkwQjtJQUN6RjtBQUNGO0FBRUEsMEJBQTBCO0FBQ25CLE1BQU1TLFNBQVNELGFBQWEsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRyYXZlbC1hZ2VudC8uL2xpYi9sb2dnZXIudHM/ZmQ1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBZHZhbmNlZCBsb2dnZXIgdXRpbGl0eSBmb3Igc3RydWN0dXJlZCBsb2dnaW5nIHdpdGggY29udGV4dFxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgYXBwZW5kRmlsZVN5bmMgfSBmcm9tICdmcyc7XG5cbi8vIExvZyBsZXZlbHNcbmV4cG9ydCB0eXBlIExvZ0xldmVsID0gJ2RlYnVnJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcic7XG5cbi8vIENvbmZpZ3VyZSBsb2cgZmlsZSBwYXRoIC0gZGVmYXVsdCB0byBsb2dzIGRpcmVjdG9yeSBpbiBwcm9qZWN0IHJvb3RcbmNvbnN0IExPR19ESVIgPSBwcm9jZXNzLmVudi5MT0dfRElSIHx8ICdsb2dzJztcbmNvbnN0IExPR19GSUxFID0gcHJvY2Vzcy5lbnYuTE9HX0ZJTEUgfHwgJ2FwcC5sb2cnO1xuY29uc3QgTUFYX0xPR19TSVpFID0gNSAqIDEwMjQgKiAxMDI0OyAvLyA1TUIgbWF4IGxvZyBmaWxlIHNpemVcbmNvbnN0IExPR19MRVZFTCA9IChwcm9jZXNzLmVudi5MT0dfTEVWRUwgfHwgJ2luZm8nKSBhcyBMb2dMZXZlbDtcblxuLy8gRW5zdXJlIGxvZyBkaXJlY3RvcnkgZXhpc3RzXG50cnkge1xuICBpZiAoIWZzLmV4aXN0c1N5bmMoTE9HX0RJUikpIHtcbiAgICBmcy5ta2RpclN5bmMoTE9HX0RJUiwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIH1cbn0gY2F0Y2ggKGVycikge1xuICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGxvZyBkaXJlY3Rvcnk6JywgZXJyKTtcbn1cblxuLy8gRGVmaW5lIGxvZyBsZXZlbHMgYXMgbnVtYmVycyBmb3IgY29tcGFyaXNvbnNcbmNvbnN0IGxvZ0xldmVsVmFsdWVzOiBSZWNvcmQ8TG9nTGV2ZWwsIG51bWJlcj4gPSB7XG4gIGRlYnVnOiAwLFxuICBpbmZvOiAxLFxuICB3YXJuOiAyLFxuICBlcnJvcjogM1xufTtcblxuLyoqXG4gKiBXcml0ZSBsb2cgdG8gZmlsZSB3aXRoIHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVG9GaWxlKG1lc3NhZ2U6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IGxvZ1BhdGggPSBwYXRoLmpvaW4oTE9HX0RJUiwgTE9HX0ZJTEUpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGxvZyBmaWxlIGV4aXN0cyBhbmQgaWYgaXQncyB0b28gbGFyZ2VcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2dQYXRoKSkge1xuICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhsb2dQYXRoKTtcbiAgICAgIGlmIChzdGF0cy5zaXplID4gTUFYX0xPR19TSVpFKSB7XG4gICAgICAgIC8vIENyZWF0ZSBiYWNrdXAgb2YgY3VycmVudCBsb2cgZmlsZSB3aXRoIHRpbWVzdGFtcFxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvOi9nLCAnLScpO1xuICAgICAgICBjb25zdCBiYWNrdXBQYXRoID0gcGF0aC5qb2luKExPR19ESVIsIGAke0xPR19GSUxFfS4ke3RpbWVzdGFtcH0uYmFja3VwYCk7XG4gICAgICAgIGZzLnJlbmFtZVN5bmMobG9nUGF0aCwgYmFja3VwUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGFwcGVuZEZpbGVTeW5jKGxvZ1BhdGgsIG1lc3NhZ2UgKyAnXFxuJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSB0byBsb2cgZmlsZTonLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IG9iamVjdCBmb3IgbG9nZ2luZyAtIGhhbmRsZXMgY2lyY3VsYXIgcmVmcyBhbmQgZm9ybWF0cyBuaWNlbHlcbiAqL1xuZnVuY3Rpb24gZm9ybWF0T2JqZWN0KG9iajogYW55KTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICAvLyBSZW1vdmUgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHNhZmVPYmogPSBKU09OLnN0cmluZ2lmeShvYmosIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgMik7XG4gICAgXG4gICAgcmV0dXJuIHNhZmVPYmo7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBgW1VuZm9ybWF0dGFibGUgT2JqZWN0OiAke2Vycn1dYDtcbiAgfVxufVxuXG4vKipcbiAqIE1haW4gbG9nZ2VyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGxvZ1dpdGhMZXZlbChsZXZlbDogTG9nTGV2ZWwsIGNvbnRleHQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAvLyBTa2lwIGxvZ3MgYmVsb3cgY3VycmVudCBsZXZlbFxuICBpZiAobG9nTGV2ZWxWYWx1ZXNbbGV2ZWxdIDwgbG9nTGV2ZWxWYWx1ZXNbTE9HX0xFVkVMIGFzIExvZ0xldmVsXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBmb3JtYXR0ZWRBcmdzID0gYXJncy5tYXAoYXJnID0+IFxuICAgIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbCA/IGZvcm1hdE9iamVjdChhcmcpIDogU3RyaW5nKGFyZylcbiAgKS5qb2luKCcgJyk7XG4gIFxuICBjb25zdCBsb2dFbnRyeSA9IGBbJHt0aW1lc3RhbXB9XSBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0gWyR7Y29udGV4dH1dICR7bWVzc2FnZX0gJHtmb3JtYXR0ZWRBcmdzfWA7XG4gIFxuICAvLyBBbHdheXMgbG9nIHRvIGNvbnNvbGUgZm9yIGltbWVkaWF0ZSBmZWVkYmFja1xuICBpZiAobGV2ZWwgPT09ICdlcnJvcicpIHtcbiAgICBjb25zb2xlLmVycm9yKGxvZ0VudHJ5KTtcbiAgfSBlbHNlIGlmIChsZXZlbCA9PT0gJ3dhcm4nKSB7XG4gICAgY29uc29sZS53YXJuKGxvZ0VudHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhsb2dFbnRyeSk7XG4gIH1cbiAgXG4gIC8vIEFsc28gd3JpdGUgdG8gbG9nIGZpbGVcbiAgd3JpdGVUb0ZpbGUobG9nRW50cnkpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxvZ2dlciBmb3IgYSBzcGVjaWZpYyBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2dnZXIoY29udGV4dDogc3RyaW5nKSB7XG4gIHJldHVybiB7XG4gICAgZGVidWc6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSA9PiBsb2dXaXRoTGV2ZWwoJ2RlYnVnJywgY29udGV4dCwgbWVzc2FnZSwgLi4uYXJncyksXG4gICAgaW5mbzogKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IGxvZ1dpdGhMZXZlbCgnaW5mbycsIGNvbnRleHQsIG1lc3NhZ2UsIC4uLmFyZ3MpLFxuICAgIHdhcm46IChtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSA9PiBsb2dXaXRoTGV2ZWwoJ3dhcm4nLCBjb250ZXh0LCBtZXNzYWdlLCAuLi5hcmdzKSxcbiAgICBlcnJvcjogKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IGxvZ1dpdGhMZXZlbCgnZXJyb3InLCBjb250ZXh0LCBtZXNzYWdlLCAuLi5hcmdzKSxcbiAgfTtcbn1cblxuLy8gRXhwb3J0IGEgZGVmYXVsdCBsb2dnZXJcbmV4cG9ydCBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoJ2FwcCcpOyAiXSwibmFtZXMiOlsiZnMiLCJwYXRoIiwiYXBwZW5kRmlsZVN5bmMiLCJMT0dfRElSIiwicHJvY2VzcyIsImVudiIsIkxPR19GSUxFIiwiTUFYX0xPR19TSVpFIiwiTE9HX0xFVkVMIiwiZXhpc3RzU3luYyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImxvZ0xldmVsVmFsdWVzIiwiZGVidWciLCJpbmZvIiwid2FybiIsIndyaXRlVG9GaWxlIiwibWVzc2FnZSIsImxvZ1BhdGgiLCJqb2luIiwic3RhdHMiLCJzdGF0U3luYyIsInNpemUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwiYmFja3VwUGF0aCIsInJlbmFtZVN5bmMiLCJmb3JtYXRPYmplY3QiLCJvYmoiLCJzZWVuIiwiV2Vha1NldCIsInNhZmVPYmoiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5IiwidmFsdWUiLCJoYXMiLCJhZGQiLCJsb2dXaXRoTGV2ZWwiLCJsZXZlbCIsImNvbnRleHQiLCJhcmdzIiwiZm9ybWF0dGVkQXJncyIsIm1hcCIsImFyZyIsIlN0cmluZyIsImxvZ0VudHJ5IiwidG9VcHBlckNhc2UiLCJsb2ciLCJjcmVhdGVMb2dnZXIiLCJsb2dnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/logger.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   countJobsByStatus: () => (/* binding */ countJobsByStatus),\n/* harmony export */   createJob: () => (/* binding */ createJob),\n/* harmony export */   getInMemoryJobs: () => (/* binding */ getInMemoryJobs),\n/* harmony export */   getJobStatus: () => (/* binding */ getJobStatus),\n/* harmony export */   getRecentJobs: () => (/* binding */ getRecentJobs),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   updateJobStatus: () => (/* binding */ updateJobStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ \"(rsc)/./lib/logger.ts\");\n\n\n// Create a logger for the Supabase module\nconst logger = (0,_logger__WEBPACK_IMPORTED_MODULE_0__.createLogger)(\"supabase\");\n// Explicitly log all environment variables for debugging\nlogger.info(\"Supabase initialization\", {\n    NODE_ENV: \"development\",\n    hasProcessEnv: typeof process !== \"undefined\" && !!process.env,\n    nodeEnv: \"development\",\n    hasSbUrl: \"NEXT_PUBLIC_SUPABASE_URL\" in process.env,\n    hasSbKey: \"NEXT_PUBLIC_SUPABASE_ANON_KEY\" in process.env,\n    nextConfig: \"string\" === \"string\",\n    envVarCount: Object.keys(process.env).filter((key)=>key.startsWith(\"NEXT_\")).length\n});\n// Supabase client setup\n// Directly access variables for debugging rather than using || '' pattern initially\nlet supabaseUrl = \"https://toaiekqwflojwicejvne.supabase.co\";\nlet supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\";\n// Debug Supabase setup without exposing keys\nlogger.debug(\"Supabase credentials\", {\n    urlPrefix: supabaseUrl?.substring(0, 12) + \"...\" || 0,\n    keyPrefix: supabaseAnonKey?.substring(0, 6) + \"...\" || 0\n});\n// Fallback to empty string if undefined\nsupabaseUrl = supabaseUrl || \"\";\nsupabaseAnonKey = supabaseAnonKey || \"\";\n// Debug Supabase setup without exposing keys\nlogger.info(\"Supabase configuration check\", {\n    hasUrl: Boolean(supabaseUrl),\n    urlLength: supabaseUrl?.length || 0,\n    urlPrefix: supabaseUrl?.substring(0, 8) || \"\",\n    hasKey: Boolean(supabaseAnonKey),\n    keyLength: supabaseAnonKey?.length || 0,\n    keyPrefix: supabaseAnonKey?.substring(0, 4) || \"\"\n});\n// Check if Supabase is configured properly\nconst isSupabaseConfigured = Boolean(supabaseUrl && supabaseAnonKey);\n// In-memory store to track if Supabase connectivity failed during runtime\nlet supabaseDisabled = false;\n// Initialize the Supabase client with explicit options for better reliability\nconst supabase = isSupabaseConfigured ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    },\n    global: {\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    },\n    db: {\n        schema: \"public\"\n    }\n}) : (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://placeholder-url.supabase.co\", \"placeholder-key\", {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    }\n});\n// Log initialization status\nif (!isSupabaseConfigured) {\n    logger.warn(\"Supabase not properly configured. Using in-memory job storage as fallback.\");\n} else {\n    logger.info(\"Supabase client initialized, verifying connection...\");\n    // Attempt to verify connection and ensure the jobs table exists\n    verifySupabaseConnection().catch((err)=>{\n        logger.error(\"Failed to verify Supabase connection:\", err.message);\n    });\n}\n// In-memory fallback store for development or when Supabase isn't configured\nconst inMemoryJobs = {};\n// Function to verify the Supabase connection\nasync function verifySupabaseConnection() {\n    if (!isSupabaseConfigured) return;\n    try {\n        logger.info(\"Checking Supabase connection...\");\n        // First try to directly query if the jobs table exists\n        const { data, error } = await supabase.from(\"jobs\").select(\"*\").limit(1);\n        if (error) {\n            // Table might not exist\n            if (error.code === \"42P01\") {\n                logger.warn(\"Jobs table does not exist, will attempt to create it\");\n                await ensureJobsTableExists();\n            } else {\n                logger.error(\"Supabase connection verification failed:\", {\n                    message: error.message,\n                    code: error.code,\n                    details: error.details\n                });\n            }\n        } else {\n            logger.info(\"Supabase connection verified successfully, jobs table exists\");\n            // Check to see if we have the right columns\n            await checkTableStructure(data);\n        }\n    } catch (error) {\n        logger.error(\"Error verifying Supabase connection:\", {\n            message: error.message,\n            stack: error.stack?.substring(0, 200)\n        });\n        // If this is a network error, disable Supabase\n        if (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\") || error instanceof TypeError) {\n            logger.warn(\"Disabling Supabase due to connection issues\");\n            supabaseDisabled = true;\n        }\n    }\n}\n// Check and adapt to existing table structure\nasync function checkTableStructure(sampleData) {\n    if (sampleData && sampleData.length > 0) {\n        // Log the structure we found for debugging\n        const firstRow = sampleData[0];\n        logger.debug(\"Found existing jobs table with columns:\", Object.keys(firstRow).join(\", \"));\n    }\n}\n// Function to check and create the jobs table if it doesn't exist\nasync function ensureJobsTableExists() {\n    if (!isSupabaseConfigured) return;\n    try {\n        logger.info(\"Attempting to create jobs table...\");\n        // Check if we have permission to execute SQL\n        try {\n            // First, try to create a simple table with the minimum required fields\n            const createTableSQL = `\n        CREATE TABLE IF NOT EXISTS jobs (\n          id BIGINT PRIMARY KEY,\n          status TEXT,\n          result JSONB,\n          error TEXT,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n        );\n      `;\n            const { error: createError } = await supabase.rpc(\"execute_sql\", {\n                sql: createTableSQL\n            });\n            if (createError) {\n                logger.error(\"Failed to create jobs table via SQL:\", createError);\n                // Try an alternative approach - using the insert API\n                logger.info(\"Trying to create jobs table via insert...\");\n                const { error: insertError } = await supabase.from(\"jobs\").insert({\n                    id: 0,\n                    status: \"test\",\n                    result: null,\n                    error: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                });\n                if (insertError) {\n                    // If Supabase doesn't let us create the table, log what needs to be created\n                    logger.error(\"Cannot create jobs table automatically:\", insertError);\n                    logger.error(\"Please create the jobs table manually with this SQL:\");\n                    logger.error(createTableSQL);\n                } else {\n                    logger.info(\"Jobs table created successfully through insert\");\n                    // Clean up test record\n                    await supabase.from(\"jobs\").delete().eq(\"id\", 0);\n                }\n            } else {\n                logger.info(\"Jobs table created successfully through SQL\");\n            }\n        } catch (sqlError) {\n            logger.error(\"Error executing SQL:\", sqlError.message);\n        }\n    } catch (error) {\n        logger.error(\"Error ensuring jobs table exists:\", error);\n    }\n}\n// Helper function to convert job ID to database-compatible ID\nfunction getDbCompatibleId(id) {\n    // If the ID is already numeric, return it as is\n    if (!isNaN(Number(id))) {\n        return Number(id);\n    }\n    // For job IDs that start with a timestamp (job_ or debug_), extract the timestamp\n    const timestampMatch = id.match(/^(job|debug|test)_(\\d+)/);\n    if (timestampMatch && !isNaN(Number(timestampMatch[2]))) {\n        // Use the timestamp portion as the numeric ID\n        return Number(timestampMatch[2]);\n    }\n    // For any other IDs, use a hash function to generate a numeric ID\n    let hash = 0;\n    const prime = 31; // Use a prime number for better distribution\n    for(let i = 0; i < id.length; i++){\n        // Get the character code\n        const char = id.charCodeAt(i);\n        // Multiply the current hash by the prime and add the character code\n        hash = Math.imul(hash, prime) + char | 0;\n    }\n    // Ensure positive number by using absolute value\n    return Math.abs(hash);\n}\n// Helper function to determine if we should use Supabase\nfunction shouldUseSupabase() {\n    return isSupabaseConfigured && !supabaseDisabled;\n}\n// Helper function to handle and log Supabase errors\nfunction handleSupabaseError(error) {\n    logger.error(\"Supabase operation failed:\", {\n        message: error.message,\n        code: error.code,\n        details: error.details || error.stack?.substring(0, 200)\n    });\n    // If this is a network error, disable Supabase for future operations\n    if (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\") || error instanceof TypeError) {\n        logger.warn(\"Disabling Supabase due to connection issues\");\n        supabaseDisabled = true;\n    }\n}\n// Update the status of a job\nasync function updateJobStatus(jobId, status, data) {\n    const updateTime = new Date().toISOString();\n    const dbId = getDbCompatibleId(jobId);\n    logger.info(`Updating job status: ${jobId} -> ${status}`, {\n        dbId,\n        hasResult: !!data?.result,\n        hasError: !!data?.error\n    });\n    if (shouldUseSupabase()) {\n        try {\n            const updateData = {\n                status,\n                updated_at: updateTime\n            };\n            if (data) {\n                if (data.result !== undefined) {\n                    updateData.result = data.result;\n                }\n                if (data.error !== undefined) {\n                    updateData.error = data.error;\n                }\n            }\n            logger.debug(`Supabase update job ${jobId} with data:`, updateData);\n            // Implement retry logic for job updates\n            let retries = 0;\n            const maxRetries = 3;\n            let success = false;\n            while(retries < maxRetries && !success){\n                const { error } = await supabase.from(\"jobs\").update(updateData).eq(\"id\", dbId);\n                if (error) {\n                    logger.warn(`Failed to update job status (attempt ${retries + 1}):`, error);\n                    retries++;\n                    if (retries < maxRetries) {\n                        // Wait a bit before retrying (exponential backoff)\n                        await new Promise((resolve)=>setTimeout(resolve, 200 * Math.pow(2, retries)));\n                    } else {\n                        handleSupabaseError(error);\n                        break;\n                    }\n                } else {\n                    logger.info(`Job ${jobId} status updated successfully to ${status}`);\n                    success = true;\n                }\n            }\n            return success;\n        } catch (error) {\n            handleSupabaseError(error);\n            // Fallback to in-memory storage\n            logger.info(`Falling back to in-memory storage for job ${jobId}`);\n        }\n    }\n    // Fallback to in-memory storage if Supabase is not available\n    if (!inMemoryJobs[jobId]) {\n        inMemoryJobs[jobId] = {\n            id: jobId,\n            status: status,\n            updated_at: updateTime\n        };\n    } else {\n        inMemoryJobs[jobId].status = status;\n        inMemoryJobs[jobId].updated_at = updateTime;\n    }\n    if (data) {\n        if (data.result !== undefined) {\n            inMemoryJobs[jobId].result = data.result;\n        }\n        if (data.error !== undefined) {\n            inMemoryJobs[jobId].error = data.error;\n        }\n    }\n    logger.info(`Updated in-memory job ${jobId} status to ${status}`);\n    return true;\n}\n// Get the status of a job\nasync function getJobStatus(jobId) {\n    const dbId = getDbCompatibleId(jobId);\n    logger.info(`Getting status for job: ${jobId} (db id: ${dbId})`);\n    if (shouldUseSupabase()) {\n        try {\n            logger.debug(`Querying Supabase for job ${jobId}`);\n            // Implement retry logic for job status fetching\n            let retries = 0;\n            const maxRetries = 3;\n            while(retries < maxRetries){\n                const { data, error } = await supabase.from(\"jobs\").select(\"status, result, error, updated_at\").eq(\"id\", dbId).single();\n                if (error) {\n                    logger.warn(`Failed to get job status (attempt ${retries + 1}):`, error);\n                    retries++;\n                    if (retries < maxRetries) {\n                        // Wait a bit before retrying (exponential backoff)\n                        await new Promise((resolve)=>setTimeout(resolve, 200 * Math.pow(2, retries)));\n                    } else {\n                        handleSupabaseError(error);\n                        break;\n                    }\n                } else if (data) {\n                    logger.info(`Job ${jobId} status retrieved: ${data.status}`, {\n                        hasResult: !!data.result,\n                        hasError: !!data.error,\n                        updatedAt: data.updated_at\n                    });\n                    return {\n                        status: data.status,\n                        result: data.result,\n                        error: data.error\n                    };\n                } else {\n                    logger.warn(`Job ${jobId} not found in database`);\n                    break;\n                }\n            }\n            // At this point, either we hit max retries or no data was found\n            // Try fallback to in-memory storage\n            logger.info(`Supabase lookup failed, checking in-memory storage for job ${jobId}`);\n        } catch (error) {\n            handleSupabaseError(error);\n            logger.info(`Falling back to in-memory storage for job ${jobId} after error`);\n        }\n    }\n    // Fallback to in-memory storage\n    if (inMemoryJobs[jobId]) {\n        logger.info(`Found job ${jobId} in memory with status: ${inMemoryJobs[jobId].status}`);\n        return {\n            status: inMemoryJobs[jobId].status,\n            result: inMemoryJobs[jobId].result,\n            error: inMemoryJobs[jobId].error\n        };\n    }\n    logger.warn(`Job ${jobId} not found in any storage`);\n    return {\n        status: \"not_found\"\n    };\n}\n// Create a new job\nasync function createJob(jobId) {\n    const dbId = getDbCompatibleId(jobId);\n    const timestamp = new Date().toISOString();\n    logger.info(`Creating new job: ${jobId} (db id: ${dbId})`);\n    if (shouldUseSupabase()) {\n        try {\n            // Implement retry logic for job creation\n            let retries = 0;\n            const maxRetries = 3;\n            let success = false;\n            while(retries < maxRetries && !success){\n                // Try to insert a new job\n                const { error } = await supabase.from(\"jobs\").insert({\n                    id: dbId,\n                    status: \"queued\",\n                    created_at: timestamp,\n                    updated_at: timestamp\n                });\n                if (error) {\n                    logger.warn(`Failed to create job (attempt ${retries + 1}):`, error);\n                    retries++;\n                    if (retries < maxRetries) {\n                        // Wait a bit before retrying (exponential backoff)\n                        await new Promise((resolve)=>setTimeout(resolve, 200 * Math.pow(2, retries)));\n                    } else {\n                        handleSupabaseError(error);\n                        break;\n                    }\n                } else {\n                    logger.info(`Job ${jobId} created successfully`);\n                    success = true;\n                }\n            }\n            if (success) {\n                return true;\n            }\n            // If we get here, we hit max retries\n            logger.info(`Supabase job creation failed after retries, falling back to in-memory`);\n        } catch (error) {\n            handleSupabaseError(error);\n            logger.info(`Falling back to in-memory storage for job ${jobId} creation`);\n        }\n    }\n    // Fallback to in-memory storage\n    inMemoryJobs[jobId] = {\n        id: jobId,\n        status: \"queued\",\n        created_at: timestamp,\n        updated_at: timestamp\n    };\n    logger.info(`Created in-memory job ${jobId}`);\n    return true;\n}\n// Export the in-memory jobs for debugging\nfunction getInMemoryJobs() {\n    return {\n        ...inMemoryJobs\n    };\n}\n// Function to count jobs by status - useful for diagnostics\nasync function countJobsByStatus() {\n    if (shouldUseSupabase()) {\n        try {\n            logger.debug(\"Counting jobs by status from Supabase\");\n            // Fetch all jobs\n            const { data, error } = await supabase.from(\"jobs\").select(\"status\").order(\"created_at\", {\n                ascending: false\n            }).limit(500);\n            if (error) {\n                handleSupabaseError(error);\n            } else if (data) {\n                // Count jobs by status\n                const statusCounts = {};\n                data.forEach((job)=>{\n                    statusCounts[job.status] = (statusCounts[job.status] || 0) + 1;\n                });\n                logger.info(\"Job count by status:\", statusCounts);\n                return statusCounts;\n            }\n        } catch (error) {\n            handleSupabaseError(error);\n        }\n    }\n    // Fallback to in-memory count\n    const statusCounts = {};\n    Object.values(inMemoryJobs).forEach((job)=>{\n        statusCounts[job.status] = (statusCounts[job.status] || 0) + 1;\n    });\n    logger.info(\"In-memory job count by status:\", statusCounts);\n    return statusCounts;\n}\n// Get recent jobs for diagnostics\nasync function getRecentJobs(limit = 50) {\n    if (shouldUseSupabase()) {\n        try {\n            logger.debug(`Fetching ${limit} recent jobs from Supabase`);\n            const { data, error } = await supabase.from(\"jobs\").select(\"*\").order(\"created_at\", {\n                ascending: false\n            }).limit(limit);\n            if (error) {\n                handleSupabaseError(error);\n            } else if (data) {\n                logger.info(`Retrieved ${data.length} recent jobs from Supabase`);\n                return data;\n            }\n        } catch (error) {\n            handleSupabaseError(error);\n        }\n    }\n    // Fallback to in-memory jobs\n    const jobs = Object.values(inMemoryJobs).sort((a, b)=>(b.created_at || \"\").localeCompare(a.created_at || \"\")).slice(0, limit);\n    logger.info(`Retrieved ${jobs.length} recent jobs from in-memory storage`);\n    return jobs;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ2I7QUFFeEMsMENBQTBDO0FBQzFDLE1BQU1FLFNBQVNELHFEQUFZQSxDQUFDO0FBRTVCLHlEQUF5RDtBQUN6REMsT0FBT0MsSUFBSSxDQUFDLDJCQUEyQjtJQUNyQ0MsVUFSRjtJQVNFQyxlQUFlLE9BQU9DLFlBQVksZUFBZSxDQUFDLENBQUNBLFFBQVFDLEdBQUc7SUFDOURDLFNBVkY7SUFXRUMsVUFBVSw4QkFBOEJILFFBQVFDLEdBQUc7SUFDbkRHLFVBQVUsbUNBQW1DSixRQUFRQyxHQUFHO0lBQ3hESSxZQUFZLFFBQXdDLEtBQUs7SUFDekRFLGFBQWFDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUUMsR0FBRyxFQUFFUyxNQUFNLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLFVBQVUsQ0FBQyxVQUFVQyxNQUFNO0FBQ3JGO0FBRUEsd0JBQXdCO0FBQ3hCLG9GQUFvRjtBQUNwRixJQUFJQyxjQUFjZCwwQ0FBb0M7QUFDdEQsSUFBSWdCLGtCQUFrQmhCLGtOQUF5QztBQUUvRCw2Q0FBNkM7QUFDN0NKLE9BQU9zQixLQUFLLENBQUMsd0JBQXdCO0lBQ25DQyxXQUFXTCxhQUFhTSxVQUFVLEdBQUcsTUFBTSxTQUFTO0lBQ3BEQyxXQUFXTCxpQkFBaUJJLFVBQVUsR0FBRyxLQUFLLFNBQVM7QUFDekQ7QUFFQSx3Q0FBd0M7QUFDeENOLGNBQWNBLGVBQWU7QUFDN0JFLGtCQUFrQkEsbUJBQW1CO0FBRXJDLDZDQUE2QztBQUM3Q3BCLE9BQU9DLElBQUksQ0FBQyxnQ0FBZ0M7SUFDMUN5QixRQUFRQyxRQUFRVDtJQUNoQlUsV0FBV1YsYUFBYUQsVUFBVTtJQUNsQ00sV0FBV0wsYUFBYU0sVUFBVSxHQUFHLE1BQU07SUFDM0NLLFFBQVFGLFFBQVFQO0lBQ2hCVSxXQUFXVixpQkFBaUJILFVBQVU7SUFDdENRLFdBQVdMLGlCQUFpQkksVUFBVSxHQUFHLE1BQU07QUFDakQ7QUFZQSwyQ0FBMkM7QUFDM0MsTUFBTU8sdUJBQXVCSixRQUFRVCxlQUFlRTtBQUVwRCwwRUFBMEU7QUFDMUUsSUFBSVksbUJBQW1CO0FBRXZCLDhFQUE4RTtBQUN2RSxNQUFNQyxXQUFXRix1QkFDcEJqQyxtRUFBWUEsQ0FBQ29CLGFBQWFFLGlCQUFpQjtJQUN6Q2MsTUFBTTtRQUNKQyxnQkFBZ0I7UUFDaEJDLGtCQUFrQjtJQUNwQjtJQUNBQyxRQUFRO1FBQ05DLFNBQVM7WUFDUCxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBQyxJQUFJO1FBQ0ZDLFFBQVE7SUFDVjtBQUNGLEtBQ0ExQyxtRUFBWUEsQ0FBQyx1Q0FBdUMsbUJBQW1CO0lBQ3JFb0MsTUFBTTtRQUNKQyxnQkFBZ0I7UUFDaEJDLGtCQUFrQjtJQUNwQjtBQUNGLEdBQUc7QUFFUCw0QkFBNEI7QUFDNUIsSUFBSSxDQUFDTCxzQkFBc0I7SUFDekIvQixPQUFPeUMsSUFBSSxDQUFDO0FBQ2QsT0FBTztJQUNMekMsT0FBT0MsSUFBSSxDQUFDO0lBQ1osZ0VBQWdFO0lBQ2hFeUMsMkJBQTJCQyxLQUFLLENBQUNDLENBQUFBO1FBQy9CNUMsT0FBTzZDLEtBQUssQ0FBQyx5Q0FBeUNELElBQUlFLE9BQU87SUFDbkU7QUFDRjtBQUVBLDZFQUE2RTtBQUM3RSxNQUFNQyxlQUF3QyxDQUFDO0FBRS9DLDZDQUE2QztBQUM3QyxlQUFlTDtJQUNiLElBQUksQ0FBQ1gsc0JBQXNCO0lBRTNCLElBQUk7UUFDRi9CLE9BQU9DLElBQUksQ0FBQztRQUVaLHVEQUF1RDtRQUN2RCxNQUFNLEVBQUUrQyxJQUFJLEVBQUVILEtBQUssRUFBRSxHQUFHLE1BQU1aLFNBQzNCZ0IsSUFBSSxDQUFDLFFBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUM7UUFFVCxJQUFJTixPQUFPO1lBQ1Qsd0JBQXdCO1lBQ3hCLElBQUlBLE1BQU1PLElBQUksS0FBSyxTQUFTO2dCQUMxQnBELE9BQU95QyxJQUFJLENBQUM7Z0JBQ1osTUFBTVk7WUFDUixPQUFPO2dCQUNMckQsT0FBTzZDLEtBQUssQ0FBQyw0Q0FBNEM7b0JBQ3ZEQyxTQUFTRCxNQUFNQyxPQUFPO29CQUN0Qk0sTUFBTVAsTUFBTU8sSUFBSTtvQkFDaEJFLFNBQVNULE1BQU1TLE9BQU87Z0JBQ3hCO1lBQ0Y7UUFDRixPQUFPO1lBQ0x0RCxPQUFPQyxJQUFJLENBQUM7WUFDWiw0Q0FBNEM7WUFDNUMsTUFBTXNELG9CQUFvQlA7UUFDNUI7SUFDRixFQUFFLE9BQU9ILE9BQVk7UUFDbkI3QyxPQUFPNkMsS0FBSyxDQUFDLHdDQUF3QztZQUNuREMsU0FBU0QsTUFBTUMsT0FBTztZQUN0QlUsT0FBT1gsTUFBTVcsS0FBSyxFQUFFaEMsVUFBVSxHQUFHO1FBQ25DO1FBRUEsK0NBQStDO1FBQy9DLElBQUlxQixNQUFNQyxPQUFPLEVBQUVXLFNBQVMsbUJBQ3hCWixNQUFNQyxPQUFPLEVBQUVXLFNBQVMsb0JBQ3hCWixpQkFBaUJhLFdBQVc7WUFDOUIxRCxPQUFPeUMsSUFBSSxDQUFDO1lBQ1pULG1CQUFtQjtRQUNyQjtJQUNGO0FBQ0Y7QUFFQSw4Q0FBOEM7QUFDOUMsZUFBZXVCLG9CQUFvQkksVUFBaUI7SUFDbEQsSUFBSUEsY0FBY0EsV0FBVzFDLE1BQU0sR0FBRyxHQUFHO1FBQ3ZDLDJDQUEyQztRQUMzQyxNQUFNMkMsV0FBV0QsVUFBVSxDQUFDLEVBQUU7UUFDOUIzRCxPQUFPc0IsS0FBSyxDQUFDLDJDQUEyQ1YsT0FBT0MsSUFBSSxDQUFDK0MsVUFBVUMsSUFBSSxDQUFDO0lBQ3JGO0FBQ0Y7QUFFQSxrRUFBa0U7QUFDbEUsZUFBZVI7SUFDYixJQUFJLENBQUN0QixzQkFBc0I7SUFFM0IsSUFBSTtRQUNGL0IsT0FBT0MsSUFBSSxDQUFDO1FBRVosNkNBQTZDO1FBQzdDLElBQUk7WUFDRix1RUFBdUU7WUFDdkUsTUFBTTZELGlCQUFpQixDQUFDOzs7Ozs7Ozs7TUFTeEIsQ0FBQztZQUVELE1BQU0sRUFBRWpCLE9BQU9rQixXQUFXLEVBQUUsR0FBRyxNQUFNOUIsU0FBUytCLEdBQUcsQ0FBQyxlQUFlO2dCQUFFQyxLQUFLSDtZQUFlO1lBRXZGLElBQUlDLGFBQWE7Z0JBQ2YvRCxPQUFPNkMsS0FBSyxDQUFDLHdDQUF3Q2tCO2dCQUVyRCxxREFBcUQ7Z0JBQ3JEL0QsT0FBT0MsSUFBSSxDQUFDO2dCQUNaLE1BQU0sRUFBRTRDLE9BQU9xQixXQUFXLEVBQUUsR0FBRyxNQUFNakMsU0FDbENnQixJQUFJLENBQUMsUUFDTGtCLE1BQU0sQ0FBQztvQkFDTkMsSUFBSTtvQkFDSkMsUUFBUTtvQkFDUkMsUUFBUTtvQkFDUnpCLE9BQU87b0JBQ1AwQixZQUFZLElBQUlDLE9BQU9DLFdBQVc7b0JBQ2xDQyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7Z0JBQ3BDO2dCQUVGLElBQUlQLGFBQWE7b0JBQ2YsNEVBQTRFO29CQUM1RWxFLE9BQU82QyxLQUFLLENBQUMsMkNBQTJDcUI7b0JBQ3hEbEUsT0FBTzZDLEtBQUssQ0FBQztvQkFDYjdDLE9BQU82QyxLQUFLLENBQUNpQjtnQkFDZixPQUFPO29CQUNMOUQsT0FBT0MsSUFBSSxDQUFDO29CQUVaLHVCQUF1QjtvQkFDdkIsTUFBTWdDLFNBQVNnQixJQUFJLENBQUMsUUFBUTBCLE1BQU0sR0FBR0MsRUFBRSxDQUFDLE1BQU07Z0JBQ2hEO1lBQ0YsT0FBTztnQkFDTDVFLE9BQU9DLElBQUksQ0FBQztZQUNkO1FBQ0YsRUFBRSxPQUFPNEUsVUFBZTtZQUN0QjdFLE9BQU82QyxLQUFLLENBQUMsd0JBQXdCZ0MsU0FBUy9CLE9BQU87UUFDdkQ7SUFDRixFQUFFLE9BQU9ELE9BQVk7UUFDbkI3QyxPQUFPNkMsS0FBSyxDQUFDLHFDQUFxQ0E7SUFDcEQ7QUFDRjtBQUVBLDhEQUE4RDtBQUM5RCxTQUFTaUMsa0JBQWtCVixFQUFVO0lBQ25DLGdEQUFnRDtJQUNoRCxJQUFJLENBQUNXLE1BQU1DLE9BQU9aLE1BQU07UUFDdEIsT0FBT1ksT0FBT1o7SUFDaEI7SUFFQSxrRkFBa0Y7SUFDbEYsTUFBTWEsaUJBQWlCYixHQUFHYyxLQUFLLENBQUM7SUFDaEMsSUFBSUQsa0JBQWtCLENBQUNGLE1BQU1DLE9BQU9DLGNBQWMsQ0FBQyxFQUFFLElBQUk7UUFDdkQsOENBQThDO1FBQzlDLE9BQU9ELE9BQU9DLGNBQWMsQ0FBQyxFQUFFO0lBQ2pDO0lBRUEsa0VBQWtFO0lBQ2xFLElBQUlFLE9BQU87SUFDWCxNQUFNQyxRQUFRLElBQUksNkNBQTZDO0lBRS9ELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJakIsR0FBR25ELE1BQU0sRUFBRW9FLElBQUs7UUFDbEMseUJBQXlCO1FBQ3pCLE1BQU1DLE9BQU9sQixHQUFHbUIsVUFBVSxDQUFDRjtRQUMzQixvRUFBb0U7UUFDcEVGLE9BQU9LLEtBQUtDLElBQUksQ0FBQ04sTUFBTUMsU0FBU0UsT0FBTztJQUN6QztJQUVBLGlEQUFpRDtJQUNqRCxPQUFPRSxLQUFLRSxHQUFHLENBQUNQO0FBQ2xCO0FBRUEseURBQXlEO0FBQ3pELFNBQVNRO0lBQ1AsT0FBTzVELHdCQUF3QixDQUFDQztBQUNsQztBQUVBLG9EQUFvRDtBQUNwRCxTQUFTNEQsb0JBQW9CL0MsS0FBVTtJQUNyQzdDLE9BQU82QyxLQUFLLENBQUMsOEJBQThCO1FBQ3pDQyxTQUFTRCxNQUFNQyxPQUFPO1FBQ3RCTSxNQUFNUCxNQUFNTyxJQUFJO1FBQ2hCRSxTQUFTVCxNQUFNUyxPQUFPLElBQUlULE1BQU1XLEtBQUssRUFBRWhDLFVBQVUsR0FBRztJQUN0RDtJQUVBLHFFQUFxRTtJQUNyRSxJQUFJcUIsTUFBTUMsT0FBTyxFQUFFVyxTQUFTLG1CQUN4QlosTUFBTUMsT0FBTyxFQUFFVyxTQUFTLG9CQUN4QlosaUJBQWlCYSxXQUFXO1FBQzlCMUQsT0FBT3lDLElBQUksQ0FBQztRQUNaVCxtQkFBbUI7SUFDckI7QUFDRjtBQUVBLDZCQUE2QjtBQUN0QixlQUFlNkQsZ0JBQ3BCQyxLQUFhLEVBQ2J6QixNQUF3RCxFQUN4RHJCLElBQXVDO0lBRXZDLE1BQU0rQyxhQUFhLElBQUl2QixPQUFPQyxXQUFXO0lBQ3pDLE1BQU11QixPQUFPbEIsa0JBQWtCZ0I7SUFFL0I5RixPQUFPQyxJQUFJLENBQUMsQ0FBQyxxQkFBcUIsRUFBRTZGLE1BQU0sSUFBSSxFQUFFekIsT0FBTyxDQUFDLEVBQUU7UUFDeEQyQjtRQUNBQyxXQUFXLENBQUMsQ0FBQ2pELE1BQU1zQjtRQUNuQjRCLFVBQVUsQ0FBQyxDQUFDbEQsTUFBTUg7SUFDcEI7SUFFQSxJQUFJOEMscUJBQXFCO1FBQ3ZCLElBQUk7WUFDRixNQUFNUSxhQUFrQjtnQkFDdEI5QjtnQkFDQUssWUFBWXFCO1lBQ2Q7WUFFQSxJQUFJL0MsTUFBTTtnQkFDUixJQUFJQSxLQUFLc0IsTUFBTSxLQUFLOEIsV0FBVztvQkFDN0JELFdBQVc3QixNQUFNLEdBQUd0QixLQUFLc0IsTUFBTTtnQkFDakM7Z0JBRUEsSUFBSXRCLEtBQUtILEtBQUssS0FBS3VELFdBQVc7b0JBQzVCRCxXQUFXdEQsS0FBSyxHQUFHRyxLQUFLSCxLQUFLO2dCQUMvQjtZQUNGO1lBRUE3QyxPQUFPc0IsS0FBSyxDQUFDLENBQUMsb0JBQW9CLEVBQUV3RSxNQUFNLFdBQVcsQ0FBQyxFQUFFSztZQUV4RCx3Q0FBd0M7WUFDeEMsSUFBSUUsVUFBVTtZQUNkLE1BQU1DLGFBQWE7WUFDbkIsSUFBSUMsVUFBVTtZQUVkLE1BQU9GLFVBQVVDLGNBQWMsQ0FBQ0MsUUFBUztnQkFDdkMsTUFBTSxFQUFFMUQsS0FBSyxFQUFFLEdBQUcsTUFBTVosU0FDckJnQixJQUFJLENBQUMsUUFDTHVELE1BQU0sQ0FBQ0wsWUFDUHZCLEVBQUUsQ0FBQyxNQUFNb0I7Z0JBRVosSUFBSW5ELE9BQU87b0JBQ1Q3QyxPQUFPeUMsSUFBSSxDQUFDLENBQUMscUNBQXFDLEVBQUU0RCxVQUFVLEVBQUUsRUFBRSxDQUFDLEVBQUV4RDtvQkFDckV3RDtvQkFFQSxJQUFJQSxVQUFVQyxZQUFZO3dCQUN4QixtREFBbUQ7d0JBQ25ELE1BQU0sSUFBSUcsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUyxNQUFNbEIsS0FBS29CLEdBQUcsQ0FBQyxHQUFHUDtvQkFDckUsT0FBTzt3QkFDTFQsb0JBQW9CL0M7d0JBQ3BCO29CQUNGO2dCQUNGLE9BQU87b0JBQ0w3QyxPQUFPQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUU2RixNQUFNLGdDQUFnQyxFQUFFekIsT0FBTyxDQUFDO29CQUNuRWtDLFVBQVU7Z0JBQ1o7WUFDRjtZQUVBLE9BQU9BO1FBQ1QsRUFBRSxPQUFPMUQsT0FBTztZQUNkK0Msb0JBQW9CL0M7WUFDcEIsZ0NBQWdDO1lBQ2hDN0MsT0FBT0MsSUFBSSxDQUFDLENBQUMsMENBQTBDLEVBQUU2RixNQUFNLENBQUM7UUFDbEU7SUFDRjtJQUVBLDZEQUE2RDtJQUM3RCxJQUFJLENBQUMvQyxZQUFZLENBQUMrQyxNQUFNLEVBQUU7UUFDeEIvQyxZQUFZLENBQUMrQyxNQUFNLEdBQUc7WUFDcEIxQixJQUFJMEI7WUFDSnpCLFFBQVFBO1lBQ1JLLFlBQVlxQjtRQUNkO0lBQ0YsT0FBTztRQUNMaEQsWUFBWSxDQUFDK0MsTUFBTSxDQUFDekIsTUFBTSxHQUFHQTtRQUM3QnRCLFlBQVksQ0FBQytDLE1BQU0sQ0FBQ3BCLFVBQVUsR0FBR3FCO0lBQ25DO0lBRUEsSUFBSS9DLE1BQU07UUFDUixJQUFJQSxLQUFLc0IsTUFBTSxLQUFLOEIsV0FBVztZQUM3QnJELFlBQVksQ0FBQytDLE1BQU0sQ0FBQ3hCLE1BQU0sR0FBR3RCLEtBQUtzQixNQUFNO1FBQzFDO1FBRUEsSUFBSXRCLEtBQUtILEtBQUssS0FBS3VELFdBQVc7WUFDNUJyRCxZQUFZLENBQUMrQyxNQUFNLENBQUNqRCxLQUFLLEdBQUdHLEtBQUtILEtBQUs7UUFDeEM7SUFDRjtJQUVBN0MsT0FBT0MsSUFBSSxDQUFDLENBQUMsc0JBQXNCLEVBQUU2RixNQUFNLFdBQVcsRUFBRXpCLE9BQU8sQ0FBQztJQUNoRSxPQUFPO0FBQ1Q7QUFFQSwwQkFBMEI7QUFDbkIsZUFBZXdDLGFBQWFmLEtBQWE7SUFDOUMsTUFBTUUsT0FBT2xCLGtCQUFrQmdCO0lBRS9COUYsT0FBT0MsSUFBSSxDQUFDLENBQUMsd0JBQXdCLEVBQUU2RixNQUFNLFNBQVMsRUFBRUUsS0FBSyxDQUFDLENBQUM7SUFFL0QsSUFBSUwscUJBQXFCO1FBQ3ZCLElBQUk7WUFDRjNGLE9BQU9zQixLQUFLLENBQUMsQ0FBQywwQkFBMEIsRUFBRXdFLE1BQU0sQ0FBQztZQUVqRCxnREFBZ0Q7WUFDaEQsSUFBSU8sVUFBVTtZQUNkLE1BQU1DLGFBQWE7WUFFbkIsTUFBT0QsVUFBVUMsV0FBWTtnQkFDM0IsTUFBTSxFQUFFdEQsSUFBSSxFQUFFSCxLQUFLLEVBQUUsR0FBRyxNQUFNWixTQUMzQmdCLElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUMscUNBQ1AwQixFQUFFLENBQUMsTUFBTW9CLE1BQ1RjLE1BQU07Z0JBRVQsSUFBSWpFLE9BQU87b0JBQ1Q3QyxPQUFPeUMsSUFBSSxDQUFDLENBQUMsa0NBQWtDLEVBQUU0RCxVQUFVLEVBQUUsRUFBRSxDQUFDLEVBQUV4RDtvQkFDbEV3RDtvQkFFQSxJQUFJQSxVQUFVQyxZQUFZO3dCQUN4QixtREFBbUQ7d0JBQ25ELE1BQU0sSUFBSUcsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUyxNQUFNbEIsS0FBS29CLEdBQUcsQ0FBQyxHQUFHUDtvQkFDckUsT0FBTzt3QkFDTFQsb0JBQW9CL0M7d0JBQ3BCO29CQUNGO2dCQUNGLE9BQU8sSUFBSUcsTUFBTTtvQkFDZmhELE9BQU9DLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRTZGLE1BQU0sbUJBQW1CLEVBQUU5QyxLQUFLcUIsTUFBTSxDQUFDLENBQUMsRUFBRTt3QkFDM0Q0QixXQUFXLENBQUMsQ0FBQ2pELEtBQUtzQixNQUFNO3dCQUN4QjRCLFVBQVUsQ0FBQyxDQUFDbEQsS0FBS0gsS0FBSzt3QkFDdEJrRSxXQUFXL0QsS0FBSzBCLFVBQVU7b0JBQzVCO29CQUVBLE9BQU87d0JBQ0xMLFFBQVFyQixLQUFLcUIsTUFBTTt3QkFDbkJDLFFBQVF0QixLQUFLc0IsTUFBTTt3QkFDbkJ6QixPQUFPRyxLQUFLSCxLQUFLO29CQUNuQjtnQkFDRixPQUFPO29CQUNMN0MsT0FBT3lDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRXFELE1BQU0sc0JBQXNCLENBQUM7b0JBRWhEO2dCQUNGO1lBQ0Y7WUFFQSxnRUFBZ0U7WUFDaEUsb0NBQW9DO1lBQ3BDOUYsT0FBT0MsSUFBSSxDQUFDLENBQUMsMkRBQTJELEVBQUU2RixNQUFNLENBQUM7UUFDbkYsRUFBRSxPQUFPakQsT0FBTztZQUNkK0Msb0JBQW9CL0M7WUFDcEI3QyxPQUFPQyxJQUFJLENBQUMsQ0FBQywwQ0FBMEMsRUFBRTZGLE1BQU0sWUFBWSxDQUFDO1FBQzlFO0lBQ0Y7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSS9DLFlBQVksQ0FBQytDLE1BQU0sRUFBRTtRQUN2QjlGLE9BQU9DLElBQUksQ0FBQyxDQUFDLFVBQVUsRUFBRTZGLE1BQU0sd0JBQXdCLEVBQUUvQyxZQUFZLENBQUMrQyxNQUFNLENBQUN6QixNQUFNLENBQUMsQ0FBQztRQUNyRixPQUFPO1lBQ0xBLFFBQVF0QixZQUFZLENBQUMrQyxNQUFNLENBQUN6QixNQUFNO1lBQ2xDQyxRQUFRdkIsWUFBWSxDQUFDK0MsTUFBTSxDQUFDeEIsTUFBTTtZQUNsQ3pCLE9BQU9FLFlBQVksQ0FBQytDLE1BQU0sQ0FBQ2pELEtBQUs7UUFDbEM7SUFDRjtJQUVBN0MsT0FBT3lDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRXFELE1BQU0seUJBQXlCLENBQUM7SUFDbkQsT0FBTztRQUFFekIsUUFBUTtJQUFZO0FBQy9CO0FBRUEsbUJBQW1CO0FBQ1osZUFBZTJDLFVBQVVsQixLQUFhO0lBQzNDLE1BQU1FLE9BQU9sQixrQkFBa0JnQjtJQUMvQixNQUFNbUIsWUFBWSxJQUFJekMsT0FBT0MsV0FBVztJQUV4Q3pFLE9BQU9DLElBQUksQ0FBQyxDQUFDLGtCQUFrQixFQUFFNkYsTUFBTSxTQUFTLEVBQUVFLEtBQUssQ0FBQyxDQUFDO0lBRXpELElBQUlMLHFCQUFxQjtRQUN2QixJQUFJO1lBQ0YseUNBQXlDO1lBQ3pDLElBQUlVLFVBQVU7WUFDZCxNQUFNQyxhQUFhO1lBQ25CLElBQUlDLFVBQVU7WUFFZCxNQUFPRixVQUFVQyxjQUFjLENBQUNDLFFBQVM7Z0JBQ3ZDLDBCQUEwQjtnQkFDMUIsTUFBTSxFQUFFMUQsS0FBSyxFQUFFLEdBQUcsTUFBTVosU0FDckJnQixJQUFJLENBQUMsUUFDTGtCLE1BQU0sQ0FBQztvQkFDTkMsSUFBSTRCO29CQUNKM0IsUUFBUTtvQkFDUkUsWUFBWTBDO29CQUNadkMsWUFBWXVDO2dCQUNkO2dCQUVGLElBQUlwRSxPQUFPO29CQUNUN0MsT0FBT3lDLElBQUksQ0FBQyxDQUFDLDhCQUE4QixFQUFFNEQsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFeEQ7b0JBQzlEd0Q7b0JBRUEsSUFBSUEsVUFBVUMsWUFBWTt3QkFDeEIsbURBQW1EO3dCQUNuRCxNQUFNLElBQUlHLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVMsTUFBTWxCLEtBQUtvQixHQUFHLENBQUMsR0FBR1A7b0JBQ3JFLE9BQU87d0JBQ0xULG9CQUFvQi9DO3dCQUNwQjtvQkFDRjtnQkFDRixPQUFPO29CQUNMN0MsT0FBT0MsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFNkYsTUFBTSxxQkFBcUIsQ0FBQztvQkFDL0NTLFVBQVU7Z0JBQ1o7WUFDRjtZQUVBLElBQUlBLFNBQVM7Z0JBQ1gsT0FBTztZQUNUO1lBRUEscUNBQXFDO1lBQ3JDdkcsT0FBT0MsSUFBSSxDQUFDLENBQUMscUVBQXFFLENBQUM7UUFDckYsRUFBRSxPQUFPNEMsT0FBTztZQUNkK0Msb0JBQW9CL0M7WUFDcEI3QyxPQUFPQyxJQUFJLENBQUMsQ0FBQywwQ0FBMEMsRUFBRTZGLE1BQU0sU0FBUyxDQUFDO1FBQzNFO0lBQ0Y7SUFFQSxnQ0FBZ0M7SUFDaEMvQyxZQUFZLENBQUMrQyxNQUFNLEdBQUc7UUFDcEIxQixJQUFJMEI7UUFDSnpCLFFBQVE7UUFDUkUsWUFBWTBDO1FBQ1p2QyxZQUFZdUM7SUFDZDtJQUVBakgsT0FBT0MsSUFBSSxDQUFDLENBQUMsc0JBQXNCLEVBQUU2RixNQUFNLENBQUM7SUFDNUMsT0FBTztBQUNUO0FBRUEsMENBQTBDO0FBQ25DLFNBQVNvQjtJQUNkLE9BQU87UUFBRSxHQUFHbkUsWUFBWTtJQUFDO0FBQzNCO0FBRUEsNERBQTREO0FBQ3JELGVBQWVvRTtJQUNwQixJQUFJeEIscUJBQXFCO1FBQ3ZCLElBQUk7WUFDRjNGLE9BQU9zQixLQUFLLENBQUM7WUFFYixpQkFBaUI7WUFDakIsTUFBTSxFQUFFMEIsSUFBSSxFQUFFSCxLQUFLLEVBQUUsR0FBRyxNQUFNWixTQUMzQmdCLElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUMsVUFDUGtFLEtBQUssQ0FBQyxjQUFjO2dCQUFFQyxXQUFXO1lBQU0sR0FDdkNsRSxLQUFLLENBQUM7WUFFVCxJQUFJTixPQUFPO2dCQUNUK0Msb0JBQW9CL0M7WUFDdEIsT0FBTyxJQUFJRyxNQUFNO2dCQUNmLHVCQUF1QjtnQkFDdkIsTUFBTXNFLGVBQXVDLENBQUM7Z0JBQzlDdEUsS0FBS3VFLE9BQU8sQ0FBQ0MsQ0FBQUE7b0JBQ1hGLFlBQVksQ0FBQ0UsSUFBSW5ELE1BQU0sQ0FBQyxHQUFHLENBQUNpRCxZQUFZLENBQUNFLElBQUluRCxNQUFNLENBQUMsSUFBSSxLQUFLO2dCQUMvRDtnQkFFQXJFLE9BQU9DLElBQUksQ0FBQyx3QkFBd0JxSDtnQkFDcEMsT0FBT0E7WUFDVDtRQUNGLEVBQUUsT0FBT3pFLE9BQU87WUFDZCtDLG9CQUFvQi9DO1FBQ3RCO0lBQ0Y7SUFFQSw4QkFBOEI7SUFDOUIsTUFBTXlFLGVBQXVDLENBQUM7SUFDOUMxRyxPQUFPNkcsTUFBTSxDQUFDMUUsY0FBY3dFLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDbENGLFlBQVksQ0FBQ0UsSUFBSW5ELE1BQU0sQ0FBQyxHQUFHLENBQUNpRCxZQUFZLENBQUNFLElBQUluRCxNQUFNLENBQUMsSUFBSSxLQUFLO0lBQy9EO0lBRUFyRSxPQUFPQyxJQUFJLENBQUMsa0NBQWtDcUg7SUFDOUMsT0FBT0E7QUFDVDtBQUVBLGtDQUFrQztBQUMzQixlQUFlSSxjQUFjdkUsUUFBUSxFQUFFO0lBQzVDLElBQUl3QyxxQkFBcUI7UUFDdkIsSUFBSTtZQUNGM0YsT0FBT3NCLEtBQUssQ0FBQyxDQUFDLFNBQVMsRUFBRTZCLE1BQU0sMEJBQTBCLENBQUM7WUFFMUQsTUFBTSxFQUFFSCxJQUFJLEVBQUVILEtBQUssRUFBRSxHQUFHLE1BQU1aLFNBQzNCZ0IsSUFBSSxDQUFDLFFBQ0xDLE1BQU0sQ0FBQyxLQUNQa0UsS0FBSyxDQUFDLGNBQWM7Z0JBQUVDLFdBQVc7WUFBTSxHQUN2Q2xFLEtBQUssQ0FBQ0E7WUFFVCxJQUFJTixPQUFPO2dCQUNUK0Msb0JBQW9CL0M7WUFDdEIsT0FBTyxJQUFJRyxNQUFNO2dCQUNmaEQsT0FBT0MsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFK0MsS0FBSy9CLE1BQU0sQ0FBQywwQkFBMEIsQ0FBQztnQkFDaEUsT0FBTytCO1lBQ1Q7UUFDRixFQUFFLE9BQU9ILE9BQU87WUFDZCtDLG9CQUFvQi9DO1FBQ3RCO0lBQ0Y7SUFFQSw2QkFBNkI7SUFDN0IsTUFBTThFLE9BQU8vRyxPQUFPNkcsTUFBTSxDQUFDMUUsY0FDeEI2RSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDQSxFQUFFdkQsVUFBVSxJQUFJLEVBQUMsRUFBR3dELGFBQWEsQ0FBQ0YsRUFBRXRELFVBQVUsSUFBSSxLQUNsRXlELEtBQUssQ0FBQyxHQUFHN0U7SUFFWm5ELE9BQU9DLElBQUksQ0FBQyxDQUFDLFVBQVUsRUFBRTBILEtBQUsxRyxNQUFNLENBQUMsbUNBQW1DLENBQUM7SUFDekUsT0FBTzBHO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10cmF2ZWwtYWdlbnQvLi9saWIvc3VwYWJhc2UudHM/Yzk5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuXG4vLyBDcmVhdGUgYSBsb2dnZXIgZm9yIHRoZSBTdXBhYmFzZSBtb2R1bGVcbmNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcignc3VwYWJhc2UnKTtcblxuLy8gRXhwbGljaXRseSBsb2cgYWxsIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgZGVidWdnaW5nXG5sb2dnZXIuaW5mbygnU3VwYWJhc2UgaW5pdGlhbGl6YXRpb24nLCB7XG4gIE5PREVfRU5WOiBwcm9jZXNzLmVudi5OT0RFX0VOVixcbiAgaGFzUHJvY2Vzc0VudjogdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICEhcHJvY2Vzcy5lbnYsXG4gIG5vZGVFbnY6IHByb2Nlc3MuZW52Lk5PREVfRU5WLFxuICBoYXNTYlVybDogJ05FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCcgaW4gcHJvY2Vzcy5lbnYsXG4gIGhhc1NiS2V5OiAnTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVknIGluIHByb2Nlc3MuZW52LFxuICBuZXh0Q29uZmlnOiB0eXBlb2YgcHJvY2Vzcy5lbnYuTkVYVF9DT05GSUdfQVZBSUxBQkxFID09PSAnc3RyaW5nJyxcbiAgZW52VmFyQ291bnQ6IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdORVhUXycpKS5sZW5ndGhcbn0pO1xuXG4vLyBTdXBhYmFzZSBjbGllbnQgc2V0dXBcbi8vIERpcmVjdGx5IGFjY2VzcyB2YXJpYWJsZXMgZm9yIGRlYnVnZ2luZyByYXRoZXIgdGhhbiB1c2luZyB8fCAnJyBwYXR0ZXJuIGluaXRpYWxseVxubGV0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xubGV0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZO1xuXG4vLyBEZWJ1ZyBTdXBhYmFzZSBzZXR1cCB3aXRob3V0IGV4cG9zaW5nIGtleXNcbmxvZ2dlci5kZWJ1ZygnU3VwYWJhc2UgY3JlZGVudGlhbHMnLCB7XG4gIHVybFByZWZpeDogc3VwYWJhc2VVcmw/LnN1YnN0cmluZygwLCAxMikgKyAnLi4uJyB8fCAndW5kZWZpbmVkJyxcbiAga2V5UHJlZml4OiBzdXBhYmFzZUFub25LZXk/LnN1YnN0cmluZygwLCA2KSArICcuLi4nIHx8ICd1bmRlZmluZWQnLFxufSk7XG5cbi8vIEZhbGxiYWNrIHRvIGVtcHR5IHN0cmluZyBpZiB1bmRlZmluZWRcbnN1cGFiYXNlVXJsID0gc3VwYWJhc2VVcmwgfHwgJyc7XG5zdXBhYmFzZUFub25LZXkgPSBzdXBhYmFzZUFub25LZXkgfHwgJyc7XG5cbi8vIERlYnVnIFN1cGFiYXNlIHNldHVwIHdpdGhvdXQgZXhwb3Npbmcga2V5c1xubG9nZ2VyLmluZm8oJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gY2hlY2snLCB7XG4gIGhhc1VybDogQm9vbGVhbihzdXBhYmFzZVVybCksXG4gIHVybExlbmd0aDogc3VwYWJhc2VVcmw/Lmxlbmd0aCB8fCAwLFxuICB1cmxQcmVmaXg6IHN1cGFiYXNlVXJsPy5zdWJzdHJpbmcoMCwgOCkgfHwgJycsXG4gIGhhc0tleTogQm9vbGVhbihzdXBhYmFzZUFub25LZXkpLFxuICBrZXlMZW5ndGg6IHN1cGFiYXNlQW5vbktleT8ubGVuZ3RoIHx8IDAsXG4gIGtleVByZWZpeDogc3VwYWJhc2VBbm9uS2V5Py5zdWJzdHJpbmcoMCwgNCkgfHwgJydcbn0pO1xuXG4vLyBUeXBlIGRlZmluaXRpb24gZm9yIGpvYiBkYXRhXG5leHBvcnQgdHlwZSBKb2JEYXRhID0ge1xuICBpZDogc3RyaW5nO1xuICBzdGF0dXM6ICdxdWV1ZWQnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJyB8ICdub3RfZm91bmQnO1xuICByZXN1bHQ/OiBhbnk7XG4gIGVycm9yPzogc3RyaW5nO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59O1xuXG4vLyBDaGVjayBpZiBTdXBhYmFzZSBpcyBjb25maWd1cmVkIHByb3Blcmx5XG5jb25zdCBpc1N1cGFiYXNlQ29uZmlndXJlZCA9IEJvb2xlYW4oc3VwYWJhc2VVcmwgJiYgc3VwYWJhc2VBbm9uS2V5KTtcblxuLy8gSW4tbWVtb3J5IHN0b3JlIHRvIHRyYWNrIGlmIFN1cGFiYXNlIGNvbm5lY3Rpdml0eSBmYWlsZWQgZHVyaW5nIHJ1bnRpbWVcbmxldCBzdXBhYmFzZURpc2FibGVkID0gZmFsc2U7XG5cbi8vIEluaXRpYWxpemUgdGhlIFN1cGFiYXNlIGNsaWVudCB3aXRoIGV4cGxpY2l0IG9wdGlvbnMgZm9yIGJldHRlciByZWxpYWJpbGl0eVxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gaXNTdXBhYmFzZUNvbmZpZ3VyZWRcbiAgPyBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRiOiB7XG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYydcbiAgICAgIH1cbiAgICB9KVxuICA6IGNyZWF0ZUNsaWVudCgnaHR0cHM6Ly9wbGFjZWhvbGRlci11cmwuc3VwYWJhc2UuY28nLCAncGxhY2Vob2xkZXIta2V5Jywge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuLy8gTG9nIGluaXRpYWxpemF0aW9uIHN0YXR1c1xuaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkge1xuICBsb2dnZXIud2FybignU3VwYWJhc2Ugbm90IHByb3Blcmx5IGNvbmZpZ3VyZWQuIFVzaW5nIGluLW1lbW9yeSBqb2Igc3RvcmFnZSBhcyBmYWxsYmFjay4nKTtcbn0gZWxzZSB7XG4gIGxvZ2dlci5pbmZvKCdTdXBhYmFzZSBjbGllbnQgaW5pdGlhbGl6ZWQsIHZlcmlmeWluZyBjb25uZWN0aW9uLi4uJyk7XG4gIC8vIEF0dGVtcHQgdG8gdmVyaWZ5IGNvbm5lY3Rpb24gYW5kIGVuc3VyZSB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgdmVyaWZ5U3VwYWJhc2VDb25uZWN0aW9uKCkuY2F0Y2goZXJyID0+IHtcbiAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byB2ZXJpZnkgU3VwYWJhc2UgY29ubmVjdGlvbjonLCBlcnIubWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBJbi1tZW1vcnkgZmFsbGJhY2sgc3RvcmUgZm9yIGRldmVsb3BtZW50IG9yIHdoZW4gU3VwYWJhc2UgaXNuJ3QgY29uZmlndXJlZFxuY29uc3QgaW5NZW1vcnlKb2JzOiBSZWNvcmQ8c3RyaW5nLCBKb2JEYXRhPiA9IHt9O1xuXG4vLyBGdW5jdGlvbiB0byB2ZXJpZnkgdGhlIFN1cGFiYXNlIGNvbm5lY3Rpb25cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVN1cGFiYXNlQ29ubmVjdGlvbigpIHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBsb2dnZXIuaW5mbygnQ2hlY2tpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB0byBkaXJlY3RseSBxdWVyeSBpZiB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAubGltaXQoMSk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAvLyBUYWJsZSBtaWdodCBub3QgZXhpc3RcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnNDJQMDEnKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdKb2JzIHRhYmxlIGRvZXMgbm90IGV4aXN0LCB3aWxsIGF0dGVtcHQgdG8gY3JlYXRlIGl0Jyk7XG4gICAgICAgIGF3YWl0IGVuc3VyZUpvYnNUYWJsZUV4aXN0cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdTdXBhYmFzZSBjb25uZWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6Jywge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuaW5mbygnU3VwYWJhc2UgY29ubmVjdGlvbiB2ZXJpZmllZCBzdWNjZXNzZnVsbHksIGpvYnMgdGFibGUgZXhpc3RzJyk7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSB0aGUgcmlnaHQgY29sdW1uc1xuICAgICAgYXdhaXQgY2hlY2tUYWJsZVN0cnVjdHVyZShkYXRhKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBTdXBhYmFzZSBjb25uZWN0aW9uOicsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBzdGFjazogZXJyb3Iuc3RhY2s/LnN1YnN0cmluZygwLCAyMDApXG4gICAgfSk7XG4gICAgXG4gICAgLy8gSWYgdGhpcyBpcyBhIG5ldHdvcmsgZXJyb3IsIGRpc2FibGUgU3VwYWJhc2VcbiAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2ZldGNoIGZhaWxlZCcpIHx8IFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbmV0d29yayBlcnJvcicpIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICBsb2dnZXIud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aW9uIGlzc3VlcycpO1xuICAgICAgc3VwYWJhc2VEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIENoZWNrIGFuZCBhZGFwdCB0byBleGlzdGluZyB0YWJsZSBzdHJ1Y3R1cmVcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrVGFibGVTdHJ1Y3R1cmUoc2FtcGxlRGF0YTogYW55W10pIHtcbiAgaWYgKHNhbXBsZURhdGEgJiYgc2FtcGxlRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgLy8gTG9nIHRoZSBzdHJ1Y3R1cmUgd2UgZm91bmQgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IGZpcnN0Um93ID0gc2FtcGxlRGF0YVswXTtcbiAgICBsb2dnZXIuZGVidWcoJ0ZvdW5kIGV4aXN0aW5nIGpvYnMgdGFibGUgd2l0aCBjb2x1bW5zOicsIE9iamVjdC5rZXlzKGZpcnN0Um93KS5qb2luKCcsICcpKTtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBjaGVjayBhbmQgY3JlYXRlIHRoZSBqb2JzIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUpvYnNUYWJsZUV4aXN0cygpIHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBsb2dnZXIuaW5mbygnQXR0ZW1wdGluZyB0byBjcmVhdGUgam9icyB0YWJsZS4uLicpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcGVybWlzc2lvbiB0byBleGVjdXRlIFNRTFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCwgdHJ5IHRvIGNyZWF0ZSBhIHNpbXBsZSB0YWJsZSB3aXRoIHRoZSBtaW5pbXVtIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgY29uc3QgY3JlYXRlVGFibGVTUUwgPSBgXG4gICAgICAgIENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGpvYnMgKFxuICAgICAgICAgIGlkIEJJR0lOVCBQUklNQVJZIEtFWSxcbiAgICAgICAgICBzdGF0dXMgVEVYVCxcbiAgICAgICAgICByZXN1bHQgSlNPTkIsXG4gICAgICAgICAgZXJyb3IgVEVYVCxcbiAgICAgICAgICBjcmVhdGVkX2F0IFRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSBERUZBVUxUIE5PVygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKClcbiAgICAgICAgKTtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ2V4ZWN1dGVfc3FsJywgeyBzcWw6IGNyZWF0ZVRhYmxlU1FMIH0pO1xuICAgICAgXG4gICAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGpvYnMgdGFibGUgdmlhIFNRTDonLCBjcmVhdGVFcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgYW4gYWx0ZXJuYXRpdmUgYXBwcm9hY2ggLSB1c2luZyB0aGUgaW5zZXJ0IEFQSVxuICAgICAgICBsb2dnZXIuaW5mbygnVHJ5aW5nIHRvIGNyZWF0ZSBqb2JzIHRhYmxlIHZpYSBpbnNlcnQuLi4nKTtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICBzdGF0dXM6ICd0ZXN0JyxcbiAgICAgICAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICAgIC8vIElmIFN1cGFiYXNlIGRvZXNuJ3QgbGV0IHVzIGNyZWF0ZSB0aGUgdGFibGUsIGxvZyB3aGF0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCBjcmVhdGUgam9icyB0YWJsZSBhdXRvbWF0aWNhbGx5OicsIGluc2VydEVycm9yKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1BsZWFzZSBjcmVhdGUgdGhlIGpvYnMgdGFibGUgbWFudWFsbHkgd2l0aCB0aGlzIFNRTDonKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoY3JlYXRlVGFibGVTUUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggaW5zZXJ0Jyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgdGVzdCByZWNvcmRcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdqb2JzJykuZGVsZXRlKCkuZXEoJ2lkJywgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggU1FMJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoc3FsRXJyb3I6IGFueSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBleGVjdXRpbmcgU1FMOicsIHNxbEVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZW5zdXJpbmcgam9icyB0YWJsZSBleGlzdHM6JywgZXJyb3IpO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGpvYiBJRCB0byBkYXRhYmFzZS1jb21wYXRpYmxlIElEXG5mdW5jdGlvbiBnZXREYkNvbXBhdGlibGVJZChpZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgLy8gSWYgdGhlIElEIGlzIGFscmVhZHkgbnVtZXJpYywgcmV0dXJuIGl0IGFzIGlzXG4gIGlmICghaXNOYU4oTnVtYmVyKGlkKSkpIHtcbiAgICByZXR1cm4gTnVtYmVyKGlkKTtcbiAgfVxuICBcbiAgLy8gRm9yIGpvYiBJRHMgdGhhdCBzdGFydCB3aXRoIGEgdGltZXN0YW1wIChqb2JfIG9yIGRlYnVnXyksIGV4dHJhY3QgdGhlIHRpbWVzdGFtcFxuICBjb25zdCB0aW1lc3RhbXBNYXRjaCA9IGlkLm1hdGNoKC9eKGpvYnxkZWJ1Z3x0ZXN0KV8oXFxkKykvKTtcbiAgaWYgKHRpbWVzdGFtcE1hdGNoICYmICFpc05hTihOdW1iZXIodGltZXN0YW1wTWF0Y2hbMl0pKSkge1xuICAgIC8vIFVzZSB0aGUgdGltZXN0YW1wIHBvcnRpb24gYXMgdGhlIG51bWVyaWMgSURcbiAgICByZXR1cm4gTnVtYmVyKHRpbWVzdGFtcE1hdGNoWzJdKTtcbiAgfVxuXG4gIC8vIEZvciBhbnkgb3RoZXIgSURzLCB1c2UgYSBoYXNoIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbnVtZXJpYyBJRFxuICBsZXQgaGFzaCA9IDA7XG4gIGNvbnN0IHByaW1lID0gMzE7IC8vIFVzZSBhIHByaW1lIG51bWJlciBmb3IgYmV0dGVyIGRpc3RyaWJ1dGlvblxuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIC8vIEdldCB0aGUgY2hhcmFjdGVyIGNvZGVcbiAgICBjb25zdCBjaGFyID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAvLyBNdWx0aXBseSB0aGUgY3VycmVudCBoYXNoIGJ5IHRoZSBwcmltZSBhbmQgYWRkIHRoZSBjaGFyYWN0ZXIgY29kZVxuICAgIGhhc2ggPSBNYXRoLmltdWwoaGFzaCwgcHJpbWUpICsgY2hhciB8IDA7XG4gIH1cbiAgXG4gIC8vIEVuc3VyZSBwb3NpdGl2ZSBudW1iZXIgYnkgdXNpbmcgYWJzb2x1dGUgdmFsdWVcbiAgcmV0dXJuIE1hdGguYWJzKGhhc2gpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgU3VwYWJhc2VcbmZ1bmN0aW9uIHNob3VsZFVzZVN1cGFiYXNlKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNTdXBhYmFzZUNvbmZpZ3VyZWQgJiYgIXN1cGFiYXNlRGlzYWJsZWQ7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgYW5kIGxvZyBTdXBhYmFzZSBlcnJvcnNcbmZ1bmN0aW9uIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3I6IGFueSk6IHZvaWQge1xuICBsb2dnZXIuZXJyb3IoJ1N1cGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQ6Jywge1xuICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgY29kZTogZXJyb3IuY29kZSxcbiAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzIHx8IGVycm9yLnN0YWNrPy5zdWJzdHJpbmcoMCwgMjAwKVxuICB9KTtcbiAgXG4gIC8vIElmIHRoaXMgaXMgYSBuZXR3b3JrIGVycm9yLCBkaXNhYmxlIFN1cGFiYXNlIGZvciBmdXR1cmUgb3BlcmF0aW9uc1xuICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2ZldGNoIGZhaWxlZCcpIHx8IFxuICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsgZXJyb3InKSB8fFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICBsb2dnZXIud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aW9uIGlzc3VlcycpO1xuICAgIHN1cGFiYXNlRGlzYWJsZWQgPSB0cnVlO1xuICB9XG59XG5cbi8vIFVwZGF0ZSB0aGUgc3RhdHVzIG9mIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSm9iU3RhdHVzKFxuICBqb2JJZDogc3RyaW5nLCBcbiAgc3RhdHVzOiAncXVldWVkJyB8ICdwcm9jZXNzaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCcsIFxuICBkYXRhPzogeyByZXN1bHQ/OiBhbnk7IGVycm9yPzogc3RyaW5nIH1cbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCB1cGRhdGVUaW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBkYklkID0gZ2V0RGJDb21wYXRpYmxlSWQoam9iSWQpO1xuICBcbiAgbG9nZ2VyLmluZm8oYFVwZGF0aW5nIGpvYiBzdGF0dXM6ICR7am9iSWR9IC0+ICR7c3RhdHVzfWAsIHsgXG4gICAgZGJJZCwgXG4gICAgaGFzUmVzdWx0OiAhIWRhdGE/LnJlc3VsdCwgXG4gICAgaGFzRXJyb3I6ICEhZGF0YT8uZXJyb3IgXG4gIH0pO1xuXG4gIGlmIChzaG91bGRVc2VTdXBhYmFzZSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICB1cGRhdGVkX2F0OiB1cGRhdGVUaW1lXG4gICAgICB9O1xuICAgICAgXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwZGF0ZURhdGEucmVzdWx0ID0gZGF0YS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRhLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cGRhdGVEYXRhLmVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBsb2dnZXIuZGVidWcoYFN1cGFiYXNlIHVwZGF0ZSBqb2IgJHtqb2JJZH0gd2l0aCBkYXRhOmAsIHVwZGF0ZURhdGEpO1xuICAgICAgXG4gICAgICAvLyBJbXBsZW1lbnQgcmV0cnkgbG9naWMgZm9yIGpvYiB1cGRhdGVzXG4gICAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcbiAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG4gICAgICBcbiAgICAgIHdoaWxlIChyZXRyaWVzIDwgbWF4UmV0cmllcyAmJiAhc3VjY2Vzcykge1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdqb2JzJylcbiAgICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgICAgLmVxKCdpZCcsIGRiSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byB1cGRhdGUgam9iIHN0YXR1cyAoYXR0ZW1wdCAke3JldHJpZXMgKyAxfSk6YCwgZXJyb3IpO1xuICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocmV0cmllcyA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgYmVmb3JlIHJldHJ5aW5nIChleHBvbmVudGlhbCBiYWNrb2ZmKVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gc3RhdHVzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IHRvICR7c3RhdHVzfWApO1xuICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlXG4gICAgICBsb2dnZXIuaW5mbyhgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGlmIFN1cGFiYXNlIGlzIG5vdCBhdmFpbGFibGVcbiAgaWYgKCFpbk1lbW9yeUpvYnNbam9iSWRdKSB7XG4gICAgaW5NZW1vcnlKb2JzW2pvYklkXSA9IHtcbiAgICAgIGlkOiBqb2JJZCxcbiAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgdXBkYXRlZF9hdDogdXBkYXRlVGltZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW5NZW1vcnlKb2JzW2pvYklkXS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgaW5NZW1vcnlKb2JzW2pvYklkXS51cGRhdGVkX2F0ID0gdXBkYXRlVGltZTtcbiAgfVxuICBcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5NZW1vcnlKb2JzW2pvYklkXS5yZXN1bHQgPSBkYXRhLnJlc3VsdDtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGEuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5NZW1vcnlKb2JzW2pvYklkXS5lcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICBsb2dnZXIuaW5mbyhgVXBkYXRlZCBpbi1tZW1vcnkgam9iICR7am9iSWR9IHN0YXR1cyB0byAke3N0YXR1c31gKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEdldCB0aGUgc3RhdHVzIG9mIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iU3RhdHVzKGpvYklkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IHJlc3VsdD86IGFueTsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICBjb25zdCBkYklkID0gZ2V0RGJDb21wYXRpYmxlSWQoam9iSWQpO1xuICBcbiAgbG9nZ2VyLmluZm8oYEdldHRpbmcgc3RhdHVzIGZvciBqb2I6ICR7am9iSWR9IChkYiBpZDogJHtkYklkfSlgKTtcbiAgXG4gIGlmIChzaG91bGRVc2VTdXBhYmFzZSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgUXVlcnlpbmcgU3VwYWJhc2UgZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgXG4gICAgICAvLyBJbXBsZW1lbnQgcmV0cnkgbG9naWMgZm9yIGpvYiBzdGF0dXMgZmV0Y2hpbmdcbiAgICAgIGxldCByZXRyaWVzID0gMDtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzO1xuICAgICAgXG4gICAgICB3aGlsZSAocmV0cmllcyA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnam9icycpXG4gICAgICAgICAgLnNlbGVjdCgnc3RhdHVzLCByZXN1bHQsIGVycm9yLCB1cGRhdGVkX2F0JylcbiAgICAgICAgICAuZXEoJ2lkJywgZGJJZClcbiAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRmFpbGVkIHRvIGdldCBqb2Igc3RhdHVzIChhdHRlbXB0ICR7cmV0cmllcyArIDF9KTpgLCBlcnJvcik7XG4gICAgICAgICAgcmV0cmllcysrO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZXRyaWVzIDwgbWF4UmV0cmllcykge1xuICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwICogTWF0aC5wb3coMiwgcmV0cmllcykpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gc3RhdHVzIHJldHJpZXZlZDogJHtkYXRhLnN0YXR1c31gLCB7XG4gICAgICAgICAgICBoYXNSZXN1bHQ6ICEhZGF0YS5yZXN1bHQsXG4gICAgICAgICAgICBoYXNFcnJvcjogISFkYXRhLmVycm9yLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnVwZGF0ZWRfYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3VsdDogZGF0YS5yZXN1bHQsXG4gICAgICAgICAgICBlcnJvcjogZGF0YS5lcnJvclxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEpvYiAke2pvYklkfSBub3QgZm91bmQgaW4gZGF0YWJhc2VgKTtcbiAgICAgICAgICAvLyBObyBkYXRhIGZvdW5kLCBicmVhayB0aGUgbG9vcFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoaXQgbWF4IHJldHJpZXMgb3Igbm8gZGF0YSB3YXMgZm91bmRcbiAgICAgIC8vIFRyeSBmYWxsYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZVxuICAgICAgbG9nZ2VyLmluZm8oYFN1cGFiYXNlIGxvb2t1cCBmYWlsZWQsIGNoZWNraW5nIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgICBsb2dnZXIuaW5mbyhgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH0gYWZ0ZXIgZXJyb3JgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlXG4gIGlmIChpbk1lbW9yeUpvYnNbam9iSWRdKSB7XG4gICAgbG9nZ2VyLmluZm8oYEZvdW5kIGpvYiAke2pvYklkfSBpbiBtZW1vcnkgd2l0aCBzdGF0dXM6ICR7aW5NZW1vcnlKb2JzW2pvYklkXS5zdGF0dXN9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogaW5NZW1vcnlKb2JzW2pvYklkXS5zdGF0dXMsXG4gICAgICByZXN1bHQ6IGluTWVtb3J5Sm9ic1tqb2JJZF0ucmVzdWx0LFxuICAgICAgZXJyb3I6IGluTWVtb3J5Sm9ic1tqb2JJZF0uZXJyb3JcbiAgICB9O1xuICB9XG4gIFxuICBsb2dnZXIud2FybihgSm9iICR7am9iSWR9IG5vdCBmb3VuZCBpbiBhbnkgc3RvcmFnZWApO1xuICByZXR1cm4geyBzdGF0dXM6ICdub3RfZm91bmQnIH07XG59XG5cbi8vIENyZWF0ZSBhIG5ldyBqb2JcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVKb2Ioam9iSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBkYklkID0gZ2V0RGJDb21wYXRpYmxlSWQoam9iSWQpO1xuICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIFxuICBsb2dnZXIuaW5mbyhgQ3JlYXRpbmcgbmV3IGpvYjogJHtqb2JJZH0gKGRiIGlkOiAke2RiSWR9KWApO1xuICBcbiAgaWYgKHNob3VsZFVzZVN1cGFiYXNlKCkpIHtcbiAgICB0cnkge1xuICAgICAgLy8gSW1wbGVtZW50IHJldHJ5IGxvZ2ljIGZvciBqb2IgY3JlYXRpb25cbiAgICAgIGxldCByZXRyaWVzID0gMDtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzO1xuICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgd2hpbGUgKHJldHJpZXMgPCBtYXhSZXRyaWVzICYmICFzdWNjZXNzKSB7XG4gICAgICAgIC8vIFRyeSB0byBpbnNlcnQgYSBuZXcgam9iXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgaWQ6IGRiSWQsXG4gICAgICAgICAgICBzdGF0dXM6ICdxdWV1ZWQnLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogdGltZXN0YW1wLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogdGltZXN0YW1wXG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRmFpbGVkIHRvIGNyZWF0ZSBqb2IgKGF0dGVtcHQgJHtyZXRyaWVzICsgMX0pOmAsIGVycm9yKTtcbiAgICAgICAgICByZXRyaWVzKys7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHJldHJpZXMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGEgYml0IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZilcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgSm9iICR7am9iSWR9IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoaXQgbWF4IHJldHJpZXNcbiAgICAgIGxvZ2dlci5pbmZvKGBTdXBhYmFzZSBqb2IgY3JlYXRpb24gZmFpbGVkIGFmdGVyIHJldHJpZXMsIGZhbGxpbmcgYmFjayB0byBpbi1tZW1vcnlgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgICBsb2dnZXIuaW5mbyhgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH0gY3JlYXRpb25gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlXG4gIGluTWVtb3J5Sm9ic1tqb2JJZF0gPSB7XG4gICAgaWQ6IGpvYklkLFxuICAgIHN0YXR1czogJ3F1ZXVlZCcsXG4gICAgY3JlYXRlZF9hdDogdGltZXN0YW1wLFxuICAgIHVwZGF0ZWRfYXQ6IHRpbWVzdGFtcFxuICB9O1xuICBcbiAgbG9nZ2VyLmluZm8oYENyZWF0ZWQgaW4tbWVtb3J5IGpvYiAke2pvYklkfWApO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gRXhwb3J0IHRoZSBpbi1tZW1vcnkgam9icyBmb3IgZGVidWdnaW5nXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5NZW1vcnlKb2JzKCkge1xuICByZXR1cm4geyAuLi5pbk1lbW9yeUpvYnMgfTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY291bnQgam9icyBieSBzdGF0dXMgLSB1c2VmdWwgZm9yIGRpYWdub3N0aWNzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY291bnRKb2JzQnlTdGF0dXMoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiB7XG4gIGlmIChzaG91bGRVc2VTdXBhYmFzZSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ291bnRpbmcgam9icyBieSBzdGF0dXMgZnJvbSBTdXBhYmFzZScpO1xuICAgICAgXG4gICAgICAvLyBGZXRjaCBhbGwgam9ic1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAuc2VsZWN0KCdzdGF0dXMnKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLmxpbWl0KDUwMCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAvLyBDb3VudCBqb2JzIGJ5IHN0YXR1c1xuICAgICAgICBjb25zdCBzdGF0dXNDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgICAgZGF0YS5mb3JFYWNoKGpvYiA9PiB7XG4gICAgICAgICAgc3RhdHVzQ291bnRzW2pvYi5zdGF0dXNdID0gKHN0YXR1c0NvdW50c1tqb2Iuc3RhdHVzXSB8fCAwKSArIDE7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbG9nZ2VyLmluZm8oJ0pvYiBjb3VudCBieSBzdGF0dXM6Jywgc3RhdHVzQ291bnRzKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1c0NvdW50cztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBpbi1tZW1vcnkgY291bnRcbiAgY29uc3Qgc3RhdHVzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIE9iamVjdC52YWx1ZXMoaW5NZW1vcnlKb2JzKS5mb3JFYWNoKGpvYiA9PiB7XG4gICAgc3RhdHVzQ291bnRzW2pvYi5zdGF0dXNdID0gKHN0YXR1c0NvdW50c1tqb2Iuc3RhdHVzXSB8fCAwKSArIDE7XG4gIH0pO1xuICBcbiAgbG9nZ2VyLmluZm8oJ0luLW1lbW9yeSBqb2IgY291bnQgYnkgc3RhdHVzOicsIHN0YXR1c0NvdW50cyk7XG4gIHJldHVybiBzdGF0dXNDb3VudHM7XG59XG5cbi8vIEdldCByZWNlbnQgam9icyBmb3IgZGlhZ25vc3RpY3NcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNlbnRKb2JzKGxpbWl0ID0gNTApOiBQcm9taXNlPEpvYkRhdGFbXT4ge1xuICBpZiAoc2hvdWxkVXNlU3VwYWJhc2UoKSkge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoYEZldGNoaW5nICR7bGltaXR9IHJlY2VudCBqb2JzIGZyb20gU3VwYWJhc2VgKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdChsaW1pdCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICBsb2dnZXIuaW5mbyhgUmV0cmlldmVkICR7ZGF0YS5sZW5ndGh9IHJlY2VudCBqb2JzIGZyb20gU3VwYWJhc2VgKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gaW4tbWVtb3J5IGpvYnNcbiAgY29uc3Qgam9icyA9IE9iamVjdC52YWx1ZXMoaW5NZW1vcnlKb2JzKVxuICAgIC5zb3J0KChhLCBiKSA9PiAoYi5jcmVhdGVkX2F0IHx8ICcnKS5sb2NhbGVDb21wYXJlKGEuY3JlYXRlZF9hdCB8fCAnJykpXG4gICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgXG4gIGxvZ2dlci5pbmZvKGBSZXRyaWV2ZWQgJHtqb2JzLmxlbmd0aH0gcmVjZW50IGpvYnMgZnJvbSBpbi1tZW1vcnkgc3RvcmFnZWApO1xuICByZXR1cm4gam9icztcbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImNyZWF0ZUxvZ2dlciIsImxvZ2dlciIsImluZm8iLCJOT0RFX0VOViIsImhhc1Byb2Nlc3NFbnYiLCJwcm9jZXNzIiwiZW52Iiwibm9kZUVudiIsImhhc1NiVXJsIiwiaGFzU2JLZXkiLCJuZXh0Q29uZmlnIiwiTkVYVF9DT05GSUdfQVZBSUxBQkxFIiwiZW52VmFyQ291bnQiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwia2V5Iiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInN1cGFiYXNlVXJsIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJkZWJ1ZyIsInVybFByZWZpeCIsInN1YnN0cmluZyIsImtleVByZWZpeCIsImhhc1VybCIsIkJvb2xlYW4iLCJ1cmxMZW5ndGgiLCJoYXNLZXkiLCJrZXlMZW5ndGgiLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsInN1cGFiYXNlRGlzYWJsZWQiLCJzdXBhYmFzZSIsImF1dGgiLCJwZXJzaXN0U2Vzc2lvbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJnbG9iYWwiLCJoZWFkZXJzIiwiZGIiLCJzY2hlbWEiLCJ3YXJuIiwidmVyaWZ5U3VwYWJhc2VDb25uZWN0aW9uIiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsIm1lc3NhZ2UiLCJpbk1lbW9yeUpvYnMiLCJkYXRhIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwiY29kZSIsImVuc3VyZUpvYnNUYWJsZUV4aXN0cyIsImRldGFpbHMiLCJjaGVja1RhYmxlU3RydWN0dXJlIiwic3RhY2siLCJpbmNsdWRlcyIsIlR5cGVFcnJvciIsInNhbXBsZURhdGEiLCJmaXJzdFJvdyIsImpvaW4iLCJjcmVhdGVUYWJsZVNRTCIsImNyZWF0ZUVycm9yIiwicnBjIiwic3FsIiwiaW5zZXJ0RXJyb3IiLCJpbnNlcnQiLCJpZCIsInN0YXR1cyIsInJlc3VsdCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlIiwiZXEiLCJzcWxFcnJvciIsImdldERiQ29tcGF0aWJsZUlkIiwiaXNOYU4iLCJOdW1iZXIiLCJ0aW1lc3RhbXBNYXRjaCIsIm1hdGNoIiwiaGFzaCIsInByaW1lIiwiaSIsImNoYXIiLCJjaGFyQ29kZUF0IiwiTWF0aCIsImltdWwiLCJhYnMiLCJzaG91bGRVc2VTdXBhYmFzZSIsImhhbmRsZVN1cGFiYXNlRXJyb3IiLCJ1cGRhdGVKb2JTdGF0dXMiLCJqb2JJZCIsInVwZGF0ZVRpbWUiLCJkYklkIiwiaGFzUmVzdWx0IiwiaGFzRXJyb3IiLCJ1cGRhdGVEYXRhIiwidW5kZWZpbmVkIiwicmV0cmllcyIsIm1heFJldHJpZXMiLCJzdWNjZXNzIiwidXBkYXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicG93IiwiZ2V0Sm9iU3RhdHVzIiwic2luZ2xlIiwidXBkYXRlZEF0IiwiY3JlYXRlSm9iIiwidGltZXN0YW1wIiwiZ2V0SW5NZW1vcnlKb2JzIiwiY291bnRKb2JzQnlTdGF0dXMiLCJvcmRlciIsImFzY2VuZGluZyIsInN0YXR1c0NvdW50cyIsImZvckVhY2giLCJqb2IiLCJ2YWx1ZXMiLCJnZXRSZWNlbnRKb2JzIiwiam9icyIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fjob-status%2Froute&page=%2Fapi%2Fjob-status%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fjob-status%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();