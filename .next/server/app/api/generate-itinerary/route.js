"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/generate-itinerary/route";
exports.ids = ["app/api/generate-itinerary/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_ethanhoppe_Desktop_AItravelagent_app_api_generate_itinerary_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/generate-itinerary/route.ts */ \"(rsc)/./app/api/generate-itinerary/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/generate-itinerary/route\",\n        pathname: \"/api/generate-itinerary\",\n        filename: \"route\",\n        bundlePath: \"app/api/generate-itinerary/route\"\n    },\n    resolvedPagePath: \"/Users/ethanhoppe/Desktop/AItravelagent/app/api/generate-itinerary/route.ts\",\n    nextConfigOutput,\n    userland: _Users_ethanhoppe_Desktop_AItravelagent_app_api_generate_itinerary_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/generate-itinerary/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZnZW5lcmF0ZS1pdGluZXJhcnklMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmdlbmVyYXRlLWl0aW5lcmFyeSUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmdlbmVyYXRlLWl0aW5lcmFyeSUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmV0aGFuaG9wcGUlMkZEZXNrdG9wJTJGQUl0cmF2ZWxhZ2VudCUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZldGhhbmhvcHBlJTJGRGVza3RvcCUyRkFJdHJhdmVsYWdlbnQmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQzJCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Lz80Y2UyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi9Vc2Vycy9ldGhhbmhvcHBlL0Rlc2t0b3AvQUl0cmF2ZWxhZ2VudC9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZ2VuZXJhdGUtaXRpbmVyYXJ5L3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZ2VuZXJhdGUtaXRpbmVyYXJ5XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9nZW5lcmF0ZS1pdGluZXJhcnkvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvZXRoYW5ob3BwZS9EZXNrdG9wL0FJdHJhdmVsYWdlbnQvYXBwL2FwaS9nZW5lcmF0ZS1pdGluZXJhcnkvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/generate-itinerary/route.ts":
/*!*********************************************!*\
  !*** ./app/api/generate-itinerary/route.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   maxDuration: () => (/* binding */ maxDuration),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _job_processor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../job-processor */ \"(rsc)/./app/api/job-processor.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n\n\n\n// Configure runtime for serverless function\nconst runtime = \"nodejs\";\nconst maxDuration = 60; // Set max duration to 60 seconds\n// Use API key from environment variables\nconst OPENAI_API_KEY = process.env.OPENAI_API_KEY || \"\";\n// Check if running in production environment\nconst isProduction = \"development\" === \"production\";\n// Check if Supabase is properly configured\nconst isSupabaseConfigured = Boolean( true && \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\");\nasync function POST(request) {\n    try {\n        // Log key information for debugging\n        console.log(`========== ITINERARY GENERATION REQUEST ==========`);\n        console.log(`API Request started: ${new Date().toISOString()}`);\n        console.log(\"Environment:\", {\n            nodeEnv: \"development\",\n            isProduction: \"development\" === \"production\"\n        });\n        // Log environment variables (without exposing actual values)\n        console.log(\"Supabase connection details:\", {\n            hasSupabaseUrl: !!\"https://toaiekqwflojwicejvne.supabase.co\",\n            hasSupabaseKey: !!\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\",\n            urlPrefix: \"https://toaiekqwflojwicejvne.supabase.co\"?.substring(0, 10) || 0,\n            keyPrefix: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\"?.substring(0, 5) || 0,\n            urlLength: \"https://toaiekqwflojwicejvne.supabase.co\"?.length || 0,\n            keyLength: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\"?.length || 0\n        });\n        console.log(\"OpenAI API Key:\", {\n            hasKey: !!process.env.OPENAI_API_KEY,\n            keyLength: process.env.OPENAI_API_KEY?.length || 0,\n            keyPrefix: process.env.OPENAI_API_KEY?.substring(0, 5) || \"missing\"\n        });\n        // Only test Supabase connection if properly configured\n        if (Boolean( true && \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\")) {\n            try {\n                console.log(\"Testing Supabase connection...\");\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"jobs\").select(\"count\").limit(1);\n                if (error) {\n                    console.error(\"❌ Supabase connection test failed:\", {\n                        message: error.message,\n                        hint: error.hint || \"\",\n                        code: error.code || \"\"\n                    });\n                } else {\n                    console.log(\"✅ Supabase connection test successful:\", data);\n                }\n            } catch (connError) {\n                console.error(\"❌ Supabase connection test exception:\", {\n                    message: connError.message,\n                    details: connError.toString(),\n                    name: connError.name,\n                    stack: connError.stack?.substring(0, 200)\n                });\n            }\n        } else {\n            console.log(\"⚠️ Skipping Supabase connection test - not configured\");\n        }\n        // Parse the request body\n        const surveyData = await request.json();\n        console.log(\"Received survey data:\", {\n            destination: surveyData.destination,\n            startDate: surveyData.startDate,\n            endDate: surveyData.endDate,\n            purpose: surveyData.purpose,\n            budget: surveyData.budget,\n            preferences: surveyData.preferences\n        });\n        // Create a unique job ID\n        const jobId = (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.generateJobId)();\n        console.log(`Generated new job ID: ${jobId}`);\n        // If we're in development or testing, return mock data immediately\n        if ( true && !OPENAI_API_KEY.startsWith(\"sk-\")) {\n            console.log(\"Development mode: Returning mock data\");\n            const mockItinerary = createMockItinerary(surveyData);\n            const updateResult = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"completed\", {\n                result: {\n                    itinerary: mockItinerary,\n                    prompt: generatePrompt(surveyData)\n                }\n            });\n            if (!updateResult) {\n                console.error(\"Failed to update job status in development mode\");\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Failed to update job status\"\n                }, {\n                    status: 500\n                });\n            }\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                jobId,\n                status: \"completed\"\n            });\n        }\n        // Create a new job\n        console.log(\"Creating new job with ID:\", jobId);\n        let jobCreated = false;\n        let retryCount = 0;\n        const maxRetries = 3;\n        // Add retry logic for job creation\n        while(!jobCreated && retryCount < maxRetries){\n            try {\n                jobCreated = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createJob)(jobId);\n                if (!jobCreated) {\n                    console.error(`Failed to create job on attempt ${retryCount + 1}/${maxRetries}`);\n                    retryCount++;\n                    if (retryCount < maxRetries) {\n                        // Exponential backoff\n                        await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, retryCount)));\n                    }\n                }\n            } catch (error) {\n                console.error(`Error creating job on attempt ${retryCount + 1}/${maxRetries}:`, error);\n                retryCount++;\n                if (retryCount < maxRetries) {\n                    // Exponential backoff\n                    await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, retryCount)));\n                }\n            }\n        }\n        if (!jobCreated) {\n            console.error(\"Failed to create job after multiple attempts\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to create job in database after multiple attempts\"\n            }, {\n                status: 500\n            });\n        }\n        console.log(`Job ${jobId} created successfully, current status: queued`);\n        // Verify the job was created properly by fetching its status\n        let statusCheck;\n        try {\n            statusCheck = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.getJobStatus)(jobId);\n            console.log(`Initial job status check: ${statusCheck.status}`);\n            if (statusCheck.status === \"not_found\") {\n                console.error(`Critical error: Job ${jobId} was not found immediately after creation`);\n                // Try to recreate the job one more time in case of race condition\n                jobCreated = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createJob)(jobId);\n                if (jobCreated) {\n                    console.log(`Job ${jobId} recreated successfully after initial not_found status`);\n                    statusCheck = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.getJobStatus)(jobId);\n                    console.log(`Second job status check: ${statusCheck.status}`);\n                }\n            }\n        } catch (statusCheckError) {\n            console.error(\"Error checking initial job status:\", statusCheckError);\n        }\n        // In production or when immediate request handling is needed, process synchronously\n        if (isProduction) {\n            console.log(`Running in production mode for job ${jobId}`);\n            // Update status to processing and immediately return response\n            const statusUpdateSuccess = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"processing\");\n            if (!statusUpdateSuccess) {\n                console.error(`Failed to update job ${jobId} status to processing`);\n            } else {\n                console.log(`Successfully updated job ${jobId} status to processing`);\n            }\n            // Start processing directly without setTimeout (which can cause issues in serverless environments)\n            // We don't await this so the request can return quickly\n            (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.processItineraryJob)(jobId, surveyData, generatePrompt, OPENAI_API_KEY).then(()=>{\n                console.log(`Background processing completed for job ${jobId}`);\n            }).catch((error)=>{\n                console.error(`Background processing error for job ${jobId}:`, error);\n                (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"failed\", {\n                    error: error.message || \"Internal server error\"\n                }).catch((e)=>console.error(`Failed to update job status after error for ${jobId}:`, e));\n            });\n            console.log(`Job ${jobId} started processing directly`);\n        } else {\n            // In development, use setTimeout for background processing (more reliable locally)\n            console.log(`Running in development mode for job ${jobId} with setTimeout...`);\n            setTimeout(async ()=>{\n                try {\n                    console.log(`Background processing started for job ${jobId}`);\n                    // First update to processing status to indicate we've started\n                    await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"processing\");\n                    // Process the job\n                    await (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.processItineraryJob)(jobId, surveyData, generatePrompt, OPENAI_API_KEY);\n                    console.log(`Background processing completed successfully for job ${jobId}`);\n                } catch (error) {\n                    console.error(`Background processing error for job ${jobId}:`, error);\n                    // Make extra sure we update the job status on error\n                    try {\n                        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"failed\", {\n                            error: error.message || \"Internal server error\"\n                        });\n                    } catch (updateError) {\n                        console.error(`Failed to update job status after error for ${jobId}:`, updateError);\n                    }\n                }\n            }, 100); // Small delay to ensure job is created first\n        }\n        // Return immediately with the job ID\n        console.log(`Returning response for job ${jobId} with status: queued`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            jobId,\n            status: \"queued\",\n            message: \"Your itinerary is being generated. Poll the job-status endpoint for updates.\"\n        });\n    } catch (error) {\n        console.error(\"Error initiating itinerary generation:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: `Failed to initiate itinerary generation: ${error.message || \"Unknown error\"}`\n        }, {\n            status: 500\n        });\n    }\n}\n// Function to generate a prompt based on survey data\nfunction generatePrompt(surveyData) {\n    // Calculate trip duration - adding 1 to include both start and end date\n    const startDate = new Date(surveyData.startDate);\n    const endDate = new Date(surveyData.endDate);\n    // Set time to noon to avoid timezone issues\n    startDate.setHours(12, 0, 0, 0);\n    endDate.setHours(12, 0, 0, 0);\n    // Calculate days including both start and end date\n    // Using Math.floor instead of Math.round and adding 1 to include both start and end date\n    const diffTime = endDate.getTime() - startDate.getTime();\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    const durationDays = diffDays + 1; // Add 1 to include both start and end date\n    console.log(\"Date calculation:\", {\n        startDate: surveyData.startDate,\n        endDate: surveyData.endDate,\n        startTimestamp: startDate.getTime(),\n        endTimestamp: endDate.getTime(),\n        diffTime,\n        diffDays,\n        durationDays\n    });\n    // Format preferences\n    const preferencesText = surveyData.preferences.length > 0 ? `They particularly enjoy ${surveyData.preferences.join(\", \")}.` : \"\";\n    // Format budget level\n    let budgetLevel = \"\";\n    switch(surveyData.budget){\n        case \"budget\":\n            budgetLevel = \"budget-friendly options, looking for economical accommodations, affordable dining, and free or low-cost activities\";\n            break;\n        case \"moderate\":\n            budgetLevel = \"mid-range options, with comfortable accommodations, good quality restaurants, and a mix of paid and free activities\";\n            break;\n        case \"luxury\":\n            budgetLevel = \"high-end options, with luxury accommodations, fine dining, and premium experiences\";\n            break;\n        default:\n            budgetLevel = \"a mix of affordable and premium options\";\n    }\n    // Format trip purpose\n    let purposeText = \"\";\n    switch(surveyData.purpose){\n        case \"vacation\":\n            purposeText = \"a relaxing vacation\";\n            break;\n        case \"honeymoon\":\n            purposeText = \"their honeymoon, so include romantic activities and settings\";\n            break;\n        case \"family\":\n            purposeText = \"a family trip, so include family-friendly activities\";\n            break;\n        case \"solo\":\n            purposeText = \"a solo adventure, with opportunities for both exploration and meeting people\";\n            break;\n        case \"business\":\n            purposeText = \"a business trip with some leisure time\";\n            break;\n        case \"weekend\":\n            purposeText = \"a quick weekend getaway\";\n            break;\n        case \"roadtrip\":\n            purposeText = \"a road trip, including notable stops and routes\";\n            break;\n        default:\n            purposeText = \"a vacation\";\n    }\n    // Construct the prompt\n    const prompt = `\nCreate a detailed ${durationDays}-day travel itinerary for a trip to ${surveyData.destination} from ${formatDate(startDate)} to ${formatDate(endDate)}.\n\nThis trip is for ${purposeText}. ${preferencesText} The traveler is looking for ${budgetLevel}.\n\nIMPORTANT: You MUST create exactly ${durationDays} days in the itinerary, with dates from ${surveyData.startDate} to ${surveyData.endDate} inclusive.\n\nFor each day, provide:\n1. Morning activity or attraction with: name, description, location, approximate cost\n2. Lunch recommendation with: restaurant name, cuisine type, price range\n3. Afternoon activity or attraction with: name, description, location, approximate cost\n4. Dinner recommendation with: restaurant name, cuisine type, price range\n5. Evening activity (if applicable) with: name, description, location, approximate cost\n\nAlso include:\n- Recommended accommodation options with estimated nightly rates\n- Transportation suggestions within the destination\n- Total estimated budget breakdown for accommodation, food, activities, and transport\n\nReturn this as a JSON object exactly as shown below. Do not include any markdown formatting, code blocks, or additional text. Use ONLY double quotes for all property names and string values - never use single quotes.\n\nVERY IMPORTANT: \n- Do NOT use $ symbols in price fields. Instead use text descriptions like \"Budget\", \"Moderate\", \"High-end\" or numbers without currency symbols.\n- For price ranges, use format like \"10-20\" or \"Budget to Moderate\" instead of \"$10-$20\".\n- When mentioning locations with periods in their names (like St. Louis), make sure the JSON remains valid.\n\n{\n  \"title\": \"Trip title\",\n  \"destination\": \"Destination name\",\n  \"dates\": {\n    \"start\": \"YYYY-MM-DD\",\n    \"end\": \"YYYY-MM-DD\"\n  },\n  \"days\": [\n    {\n      \"date\": \"YYYY-MM-DD\",\n      \"activities\": [\n        {\n          \"id\": \"unique-id\",\n          \"time\": \"Morning/Afternoon/Evening\",\n          \"title\": \"Activity name\",\n          \"description\": \"Detailed description\",\n          \"location\": \"Address or area\",\n          \"coordinates\": { \"lat\": 41.3851, \"lng\": 2.1734 },\n          \"cost\": 0\n        }\n      ]\n    }\n  ],\n  \"accommodation\": [\n    {\n      \"name\": \"Accommodation name\",\n      \"description\": \"Description\",\n      \"location\": \"Address\",\n      \"pricePerNight\": 0\n    }\n  ],\n  \"transportation\": [\n    {\n      \"type\": \"Type of transport\",\n      \"description\": \"Description\",\n      \"estimatedCost\": 0\n    }\n  ],\n  \"budget\": {\n    \"accommodation\": 0,\n    \"food\": 0,\n    \"activities\": 0,\n    \"transport\": 0,\n    \"total\": 0\n  }\n}\n\nEnsure all costs are in USD and are realistic estimates. For coordinates, use approximate latitude and longitude for each location. Remember to provide a properly formatted JSON response with all property names in double quotes.\n`;\n    return prompt;\n}\n// Helper function to format dates\nfunction formatDate(date) {\n    return date.toLocaleDateString(\"en-US\", {\n        weekday: \"long\",\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    });\n}\n// Create mock itinerary data for development\nfunction createMockItinerary(surveyData) {\n    const startDate = new Date(surveyData.startDate);\n    const endDate = new Date(surveyData.endDate);\n    // Set time to noon to avoid timezone issues\n    startDate.setHours(12, 0, 0, 0);\n    endDate.setHours(12, 0, 0, 0);\n    // Calculate days including both start and end date\n    // Using Math.floor instead of Math.round and adding 1 to include both start and end date\n    const diffTime = endDate.getTime() - startDate.getTime();\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    const durationDays = diffDays + 1; // Add 1 to include both start and end date\n    console.log(\"Mock Date calculation:\", {\n        startDate: surveyData.startDate,\n        endDate: surveyData.endDate,\n        diffTime,\n        diffDays,\n        durationDays\n    });\n    const days = [];\n    // Generate mock days\n    for(let i = 0; i < durationDays; i++){\n        const currentDate = new Date(startDate);\n        currentDate.setDate(startDate.getDate() + i);\n        days.push({\n            date: currentDate.toISOString().split(\"T\")[0],\n            activities: [\n                {\n                    id: `act-${i}-1`,\n                    time: \"Morning\",\n                    title: `Explore ${surveyData.destination} - Day ${i + 1} Morning`,\n                    description: \"Start your day with a visit to a popular local attraction.\",\n                    location: `${surveyData.destination} City Center`,\n                    coordinates: {\n                        lat: 40.7128,\n                        lng: -74.0060\n                    },\n                    cost: 25\n                },\n                {\n                    id: `act-${i}-2`,\n                    time: \"Afternoon\",\n                    title: `${surveyData.destination} Afternoon Activity`,\n                    description: \"Enjoy a relaxing afternoon activity based on your preferences.\",\n                    location: `${surveyData.destination} Park`,\n                    coordinates: {\n                        lat: 40.7828,\n                        lng: -73.9654\n                    },\n                    cost: 15\n                },\n                {\n                    id: `act-${i}-3`,\n                    time: \"Evening\",\n                    title: `${surveyData.destination} Night Experience`,\n                    description: \"Experience the local nightlife and culture.\",\n                    location: `${surveyData.destination} Entertainment District`,\n                    coordinates: {\n                        lat: 40.7590,\n                        lng: -73.9845\n                    },\n                    cost: 50\n                }\n            ]\n        });\n    }\n    // Create mock budget based on preferences\n    let accommodationCost = 0;\n    switch(surveyData.budget){\n        case \"budget\":\n            accommodationCost = 75;\n            break;\n        case \"moderate\":\n            accommodationCost = 150;\n            break;\n        case \"luxury\":\n            accommodationCost = 300;\n            break;\n        default:\n            accommodationCost = 150;\n    }\n    const totalAccommodation = accommodationCost * durationDays;\n    const totalFood = 60 * durationDays;\n    const totalActivities = 90 * durationDays;\n    const totalTransport = 30 * durationDays;\n    return {\n        title: `${surveyData.destination} ${surveyData.purpose.charAt(0).toUpperCase() + surveyData.purpose.slice(1)} Trip`,\n        destination: surveyData.destination,\n        dates: {\n            start: surveyData.startDate,\n            end: surveyData.endDate\n        },\n        days,\n        accommodation: [\n            {\n                name: `${surveyData.destination} Hotel`,\n                description: \"A comfortable hotel in a convenient location.\",\n                location: `Central ${surveyData.destination}`,\n                pricePerNight: accommodationCost\n            },\n            {\n                name: `${surveyData.destination} Boutique Stay`,\n                description: \"A charming boutique accommodation with local character.\",\n                location: `Historic District, ${surveyData.destination}`,\n                pricePerNight: accommodationCost * 1.2\n            }\n        ],\n        transportation: [\n            {\n                type: \"Public Transit\",\n                description: \"Convenient and affordable public transportation network.\",\n                estimatedCost: totalTransport * 0.5\n            },\n            {\n                type: \"Taxi/Rideshare\",\n                description: \"On-demand rides for convenience.\",\n                estimatedCost: totalTransport * 0.5\n            }\n        ],\n        budget: {\n            accommodation: totalAccommodation,\n            food: totalFood,\n            activities: totalActivities,\n            transport: totalTransport,\n            total: totalAccommodation + totalFood + totalActivities + totalTransport\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkM7QUFDMkI7QUFDcUI7QUFFM0YsNENBQTRDO0FBQ3JDLE1BQU1PLFVBQVUsU0FBUztBQUN6QixNQUFNQyxjQUFjLEdBQUcsQ0FBQyxpQ0FBaUM7QUFFaEUseUNBQXlDO0FBQ3pDLE1BQU1DLGlCQUFpQkMsUUFBUUMsR0FBRyxDQUFDRixjQUFjLElBQUk7QUFFckQsNkNBQTZDO0FBQzdDLE1BQU1HLGVBQWVGLGtCQUF5QjtBQUU5QywyQ0FBMkM7QUFDM0MsTUFBTUcsdUJBQXVCQyxRQUMzQkosS0FBb0MsSUFDcENBLGtOQUF5QztBQWFwQyxlQUFlTyxLQUFLQyxPQUFnQjtJQUN6QyxJQUFJO1FBQ0Ysb0NBQW9DO1FBQ3BDQyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxrREFBa0QsQ0FBQztRQUNoRUQsUUFBUUMsR0FBRyxDQUFDLENBQUMscUJBQXFCLEVBQUUsSUFBSUMsT0FBT0MsV0FBVyxHQUFHLENBQUM7UUFDOURILFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0I7WUFDMUJHLFNBcENOO1lBcUNNWCxjQUFjRixrQkFBeUI7UUFDekM7UUFFQSw2REFBNkQ7UUFDN0RTLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBZ0M7WUFDMUNJLGdCQUFnQixDQUFDLENBQUNkLDBDQUFvQztZQUN0RGUsZ0JBQWdCLENBQUMsQ0FBQ2Ysa05BQXlDO1lBQzNEZ0IsV0FBV2hCLDBDQUFvQyxFQUFFaUIsVUFBVSxHQUFHLE9BQU87WUFDckVDLFdBQVdsQixrTkFBeUMsRUFBRWlCLFVBQVUsR0FBRyxNQUFNO1lBQ3pFRSxXQUFXbkIsMENBQW9DLEVBQUVvQixVQUFVO1lBQzNEQyxXQUFXckIsa05BQXlDLEVBQUVvQixVQUFVO1FBQ2xFO1FBRUFYLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUI7WUFDN0JZLFFBQVEsQ0FBQyxDQUFDdEIsUUFBUUMsR0FBRyxDQUFDRixjQUFjO1lBQ3BD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Q25IMUUsYUFBYUYsV0FBV0UsV0FBVztRQUNuQzJFLE9BQU87WUFDTEMsT0FBTzlFLFdBQVdHLFNBQVM7WUFDM0I0RSxLQUFLL0UsV0FBV0ksT0FBTztRQUN6QjtRQUNBZ0Q7UUFDQTRCLGVBQWU7WUFDYjtnQkFDRWxGLE1BQU0sQ0FBQyxFQUFFRSxXQUFXRSxXQUFXLENBQUMsTUFBTSxDQUFDO2dCQUN2QzZELGFBQWE7Z0JBQ2JDLFVBQVUsQ0FBQyxRQUFRLEVBQUVoRSxXQUFXRSxXQUFXLENBQUMsQ0FBQztnQkFDN0MrRSxlQUFlWjtZQUNqQjtZQUNBO2dCQUNFdkUsTUFBTSxDQUFDLEVBQUVFLFdBQVdFLFdBQVcsQ0FBQyxjQUFjLENBQUM7Z0JBQy9DNkQsYUFBYTtnQkFDYkMsVUFBVSxDQUFDLG1CQUFtQixFQUFFaEUsV0FBV0UsV0FBVyxDQUFDLENBQUM7Z0JBQ3hEK0UsZUFBZVosb0JBQW9CO1lBQ3JDO1NBQ0Q7UUFDRGEsZ0JBQWdCO1lBQ2Q7Z0JBQ0VDLE1BQU07Z0JBQ05wQixhQUFhO2dCQUNicUIsZUFBZVgsaUJBQWlCO1lBQ2xDO1lBQ0E7Z0JBQ0VVLE1BQU07Z0JBQ05wQixhQUFhO2dCQUNicUIsZUFBZVgsaUJBQWlCO1lBQ2xDO1NBQ0Q7UUFDRG5FLFFBQVE7WUFDTjBFLGVBQWVWO1lBQ2ZlLE1BQU1kO1lBQ05aLFlBQVlhO1lBQ1pjLFdBQVdiO1lBQ1hjLE9BQU9qQixxQkFBcUJDLFlBQVlDLGtCQUFrQkM7UUFDNUQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Ly4vYXBwL2FwaS9nZW5lcmF0ZS1pdGluZXJhcnkvcm91dGUudHM/ZDgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBnZW5lcmF0ZUpvYklkLCBwcm9jZXNzSXRpbmVyYXJ5Sm9iIH0gZnJvbSAnLi4vam9iLXByb2Nlc3Nvcic7XG5pbXBvcnQgeyBjcmVhdGVKb2IsIHVwZGF0ZUpvYlN0YXR1cywgZ2V0Sm9iU3RhdHVzLCBzdXBhYmFzZSB9IGZyb20gJy4uLy4uLy4uL2xpYi9zdXBhYmFzZSc7XG5cbi8vIENvbmZpZ3VyZSBydW50aW1lIGZvciBzZXJ2ZXJsZXNzIGZ1bmN0aW9uXG5leHBvcnQgY29uc3QgcnVudGltZSA9ICdub2RlanMnO1xuZXhwb3J0IGNvbnN0IG1heER1cmF0aW9uID0gNjA7IC8vIFNldCBtYXggZHVyYXRpb24gdG8gNjAgc2Vjb25kc1xuXG4vLyBVc2UgQVBJIGtleSBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3QgT1BFTkFJX0FQSV9LRVkgPSBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSB8fCAnJztcblxuLy8gQ2hlY2sgaWYgcnVubmluZyBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG5jb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG4vLyBDaGVjayBpZiBTdXBhYmFzZSBpcyBwcm9wZXJseSBjb25maWd1cmVkXG5jb25zdCBpc1N1cGFiYXNlQ29uZmlndXJlZCA9IEJvb2xlYW4oXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCAmJiBcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVlcbik7XG5cbi8vIFN1cnZleSBkYXRhIHR5cGVcbnR5cGUgU3VydmV5RGF0YSA9IHtcbiAgZGVzdGluYXRpb246IHN0cmluZztcbiAgc3RhcnREYXRlOiBzdHJpbmc7XG4gIGVuZERhdGU6IHN0cmluZztcbiAgcHVycG9zZTogc3RyaW5nO1xuICBidWRnZXQ6IHN0cmluZztcbiAgcHJlZmVyZW5jZXM6IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogUmVxdWVzdCkge1xuICB0cnkge1xuICAgIC8vIExvZyBrZXkgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnNvbGUubG9nKGA9PT09PT09PT09IElUSU5FUkFSWSBHRU5FUkFUSU9OIFJFUVVFU1QgPT09PT09PT09PWApO1xuICAgIGNvbnNvbGUubG9nKGBBUEkgUmVxdWVzdCBzdGFydGVkOiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gKTtcbiAgICBjb25zb2xlLmxvZygnRW52aXJvbm1lbnQ6Jywge1xuICAgICAgbm9kZUVudjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXG4gICAgICBpc1Byb2R1Y3Rpb246IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcbiAgICB9KTtcbiAgICBcbiAgICAvLyBMb2cgZW52aXJvbm1lbnQgdmFyaWFibGVzICh3aXRob3V0IGV4cG9zaW5nIGFjdHVhbCB2YWx1ZXMpXG4gICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNvbm5lY3Rpb24gZGV0YWlsczonLCB7XG4gICAgICBoYXNTdXBhYmFzZVVybDogISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gICAgICBoYXNTdXBhYmFzZUtleTogISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgICAgIHVybFByZWZpeDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMPy5zdWJzdHJpbmcoMCwgMTApIHx8ICdtaXNzaW5nJyxcbiAgICAgIGtleVByZWZpeDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVk/LnN1YnN0cmluZygwLCA1KSB8fCAnbWlzc2luZycsXG4gICAgICB1cmxMZW5ndGg6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTD8ubGVuZ3RoIHx8IDAsXG4gICAgICBrZXlMZW5ndGg6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZPy5sZW5ndGggfHwgMFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdPcGVuQUkgQVBJIEtleTonLCB7XG4gICAgICBoYXNLZXk6ICEhcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVksXG4gICAgICBrZXlMZW5ndGg6IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZPy5sZW5ndGggfHwgMCxcbiAgICAgIGtleVByZWZpeDogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVk/LnN1YnN0cmluZygwLCA1KSB8fCAnbWlzc2luZydcbiAgICB9KTtcblxuICAgIC8vIE9ubHkgdGVzdCBTdXBhYmFzZSBjb25uZWN0aW9uIGlmIHByb3Blcmx5IGNvbmZpZ3VyZWRcbiAgICBpZiAoQm9vbGVhbihwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgJiYgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnVGVzdGluZyBTdXBhYmFzZSBjb25uZWN0aW9uLi4uJyk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2pvYnMnKS5zZWxlY3QoJ2NvdW50JykubGltaXQoMSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBoaW50OiBlcnJvci5oaW50IHx8ICcnLFxuICAgICAgICAgICAgY29kZTogZXJyb3IuY29kZSB8fCAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3VwYWJhc2UgY29ubmVjdGlvbiB0ZXN0IHN1Y2Nlc3NmdWw6JywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGNvbm5FcnJvcjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3QgZXhjZXB0aW9uOicsIHtcbiAgICAgICAgICBtZXNzYWdlOiBjb25uRXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBkZXRhaWxzOiBjb25uRXJyb3IudG9TdHJpbmcoKSxcbiAgICAgICAgICBuYW1lOiBjb25uRXJyb3IubmFtZSxcbiAgICAgICAgICBzdGFjazogY29ubkVycm9yLnN0YWNrPy5zdWJzdHJpbmcoMCwgMjAwKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBTa2lwcGluZyBTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3QgLSBub3QgY29uZmlndXJlZCcpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHRoZSByZXF1ZXN0IGJvZHlcbiAgICBjb25zdCBzdXJ2ZXlEYXRhOiBTdXJ2ZXlEYXRhID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIHN1cnZleSBkYXRhOicsIHtcbiAgICAgIGRlc3RpbmF0aW9uOiBzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9uLFxuICAgICAgc3RhcnREYXRlOiBzdXJ2ZXlEYXRhLnN0YXJ0RGF0ZSxcbiAgICAgIGVuZERhdGU6IHN1cnZleURhdGEuZW5kRGF0ZSxcbiAgICAgIHB1cnBvc2U6IHN1cnZleURhdGEucHVycG9zZSxcbiAgICAgIGJ1ZGdldDogc3VydmV5RGF0YS5idWRnZXQsXG4gICAgICBwcmVmZXJlbmNlczogc3VydmV5RGF0YS5wcmVmZXJlbmNlcyBcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBqb2IgSURcbiAgICBjb25zdCBqb2JJZCA9IGdlbmVyYXRlSm9iSWQoKTtcbiAgICBjb25zb2xlLmxvZyhgR2VuZXJhdGVkIG5ldyBqb2IgSUQ6ICR7am9iSWR9YCk7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCBvciB0ZXN0aW5nLCByZXR1cm4gbW9jayBkYXRhIGltbWVkaWF0ZWx5XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFPUEVOQUlfQVBJX0tFWS5zdGFydHNXaXRoKCdzay0nKSkge1xuICAgICAgY29uc29sZS5sb2coJ0RldmVsb3BtZW50IG1vZGU6IFJldHVybmluZyBtb2NrIGRhdGEnKTtcbiAgICAgIGNvbnN0IG1vY2tJdGluZXJhcnkgPSBjcmVhdGVNb2NrSXRpbmVyYXJ5KHN1cnZleURhdGEpO1xuICAgICAgY29uc3QgdXBkYXRlUmVzdWx0ID0gYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnY29tcGxldGVkJywgeyBcbiAgICAgICAgcmVzdWx0OiB7IFxuICAgICAgICAgIGl0aW5lcmFyeTogbW9ja0l0aW5lcmFyeSwgXG4gICAgICAgICAgcHJvbXB0OiBnZW5lcmF0ZVByb21wdChzdXJ2ZXlEYXRhKSBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghdXBkYXRlUmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgam9iIHN0YXR1cyBpbiBkZXZlbG9wbWVudCBtb2RlJyk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIHVwZGF0ZSBqb2Igc3RhdHVzJyB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBqb2JJZCwgc3RhdHVzOiAnY29tcGxldGVkJyB9KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgam9iXG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIG5ldyBqb2Igd2l0aCBJRDonLCBqb2JJZCk7XG4gICAgbGV0IGpvYkNyZWF0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gICAgXG4gICAgLy8gQWRkIHJldHJ5IGxvZ2ljIGZvciBqb2IgY3JlYXRpb25cbiAgICB3aGlsZSAoIWpvYkNyZWF0ZWQgJiYgcmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGpvYkNyZWF0ZWQgPSBhd2FpdCBjcmVhdGVKb2Ioam9iSWQpO1xuICAgICAgICBpZiAoIWpvYkNyZWF0ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGpvYiBvbiBhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9LyR7bWF4UmV0cmllc31gKTtcbiAgICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgICAgaWYgKHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWF0aW5nIGpvYiBvbiBhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9LyR7bWF4UmV0cmllc306YCwgZXJyb3IpO1xuICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIGlmIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoIWpvYkNyZWF0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgam9iIGFmdGVyIG11bHRpcGxlIGF0dGVtcHRzJyk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIGpvYiBpbiBkYXRhYmFzZSBhZnRlciBtdWx0aXBsZSBhdHRlbXB0cycgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LCBjdXJyZW50IHN0YXR1czogcXVldWVkYCk7XG5cbiAgICAvLyBWZXJpZnkgdGhlIGpvYiB3YXMgY3JlYXRlZCBwcm9wZXJseSBieSBmZXRjaGluZyBpdHMgc3RhdHVzXG4gICAgbGV0IHN0YXR1c0NoZWNrO1xuICAgIHRyeSB7XG4gICAgICBzdGF0dXNDaGVjayA9IGF3YWl0IGdldEpvYlN0YXR1cyhqb2JJZCk7XG4gICAgICBjb25zb2xlLmxvZyhgSW5pdGlhbCBqb2Igc3RhdHVzIGNoZWNrOiAke3N0YXR1c0NoZWNrLnN0YXR1c31gKTtcbiAgICAgIFxuICAgICAgaWYgKHN0YXR1c0NoZWNrLnN0YXR1cyA9PT0gJ25vdF9mb3VuZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQ3JpdGljYWwgZXJyb3I6IEpvYiAke2pvYklkfSB3YXMgbm90IGZvdW5kIGltbWVkaWF0ZWx5IGFmdGVyIGNyZWF0aW9uYCk7XG4gICAgICAgIC8vIFRyeSB0byByZWNyZWF0ZSB0aGUgam9iIG9uZSBtb3JlIHRpbWUgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvblxuICAgICAgICBqb2JDcmVhdGVkID0gYXdhaXQgY3JlYXRlSm9iKGpvYklkKTtcbiAgICAgICAgaWYgKGpvYkNyZWF0ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IHJlY3JlYXRlZCBzdWNjZXNzZnVsbHkgYWZ0ZXIgaW5pdGlhbCBub3RfZm91bmQgc3RhdHVzYCk7XG4gICAgICAgICAgc3RhdHVzQ2hlY2sgPSBhd2FpdCBnZXRKb2JTdGF0dXMoam9iSWQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTZWNvbmQgam9iIHN0YXR1cyBjaGVjazogJHtzdGF0dXNDaGVjay5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChzdGF0dXNDaGVja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBpbml0aWFsIGpvYiBzdGF0dXM6Jywgc3RhdHVzQ2hlY2tFcnJvcik7XG4gICAgfVxuXG4gICAgLy8gSW4gcHJvZHVjdGlvbiBvciB3aGVuIGltbWVkaWF0ZSByZXF1ZXN0IGhhbmRsaW5nIGlzIG5lZWRlZCwgcHJvY2VzcyBzeW5jaHJvbm91c2x5XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgY29uc29sZS5sb2coYFJ1bm5pbmcgaW4gcHJvZHVjdGlvbiBtb2RlIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1cyB0byBwcm9jZXNzaW5nIGFuZCBpbW1lZGlhdGVseSByZXR1cm4gcmVzcG9uc2VcbiAgICAgIGNvbnN0IHN0YXR1c1VwZGF0ZVN1Y2Nlc3MgPSBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdwcm9jZXNzaW5nJyk7XG4gICAgICBpZiAoIXN0YXR1c1VwZGF0ZVN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBqb2IgJHtqb2JJZH0gc3RhdHVzIHRvIHByb2Nlc3NpbmdgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgdXBkYXRlZCBqb2IgJHtqb2JJZH0gc3RhdHVzIHRvIHByb2Nlc3NpbmdgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RhcnQgcHJvY2Vzc2luZyBkaXJlY3RseSB3aXRob3V0IHNldFRpbWVvdXQgKHdoaWNoIGNhbiBjYXVzZSBpc3N1ZXMgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMpXG4gICAgICAvLyBXZSBkb24ndCBhd2FpdCB0aGlzIHNvIHRoZSByZXF1ZXN0IGNhbiByZXR1cm4gcXVpY2tseVxuICAgICAgcHJvY2Vzc0l0aW5lcmFyeUpvYihqb2JJZCwgc3VydmV5RGF0YSwgZ2VuZXJhdGVQcm9tcHQsIE9QRU5BSV9BUElfS0VZKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEJhY2tncm91bmQgcHJvY2Vzc2luZyBjb21wbGV0ZWQgZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEJhY2tncm91bmQgcHJvY2Vzc2luZyBlcnJvciBmb3Igam9iICR7am9iSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ludGVybmFsIHNlcnZlciBlcnJvcidcbiAgICAgICAgICB9KS5jYXRjaChlID0+IGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgam9iIHN0YXR1cyBhZnRlciBlcnJvciBmb3IgJHtqb2JJZH06YCwgZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IHN0YXJ0ZWQgcHJvY2Vzc2luZyBkaXJlY3RseWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBkZXZlbG9wbWVudCwgdXNlIHNldFRpbWVvdXQgZm9yIGJhY2tncm91bmQgcHJvY2Vzc2luZyAobW9yZSByZWxpYWJsZSBsb2NhbGx5KVxuICAgICAgY29uc29sZS5sb2coYFJ1bm5pbmcgaW4gZGV2ZWxvcG1lbnQgbW9kZSBmb3Igam9iICR7am9iSWR9IHdpdGggc2V0VGltZW91dC4uLmApO1xuICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEJhY2tncm91bmQgcHJvY2Vzc2luZyBzdGFydGVkIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICAgICAgICAvLyBGaXJzdCB1cGRhdGUgdG8gcHJvY2Vzc2luZyBzdGF0dXMgdG8gaW5kaWNhdGUgd2UndmUgc3RhcnRlZFxuICAgICAgICAgIGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ3Byb2Nlc3NpbmcnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBqb2JcbiAgICAgICAgICBhd2FpdCBwcm9jZXNzSXRpbmVyYXJ5Sm9iKGpvYklkLCBzdXJ2ZXlEYXRhLCBnZW5lcmF0ZVByb21wdCwgT1BFTkFJX0FQSV9LRVkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBCYWNrZ3JvdW5kIHByb2Nlc3NpbmcgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBCYWNrZ3JvdW5kIHByb2Nlc3NpbmcgZXJyb3IgZm9yIGpvYiAke2pvYklkfTpgLCBlcnJvcik7XG4gICAgICAgICAgLy8gTWFrZSBleHRyYSBzdXJlIHdlIHVwZGF0ZSB0aGUgam9iIHN0YXR1cyBvbiBlcnJvclxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnSW50ZXJuYWwgc2VydmVyIGVycm9yJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgam9iIHN0YXR1cyBhZnRlciBlcnJvciBmb3IgJHtqb2JJZH06YCwgdXBkYXRlRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGpvYiBpcyBjcmVhdGVkIGZpcnN0XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IHdpdGggdGhlIGpvYiBJRFxuICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgcmVzcG9uc2UgZm9yIGpvYiAke2pvYklkfSB3aXRoIHN0YXR1czogcXVldWVkYCk7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICBqb2JJZCwgXG4gICAgICBzdGF0dXM6ICdxdWV1ZWQnLFxuICAgICAgbWVzc2FnZTogJ1lvdXIgaXRpbmVyYXJ5IGlzIGJlaW5nIGdlbmVyYXRlZC4gUG9sbCB0aGUgam9iLXN0YXR1cyBlbmRwb2ludCBmb3IgdXBkYXRlcy4nXG4gICAgfSk7XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWF0aW5nIGl0aW5lcmFyeSBnZW5lcmF0aW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiBgRmFpbGVkIHRvIGluaXRpYXRlIGl0aW5lcmFyeSBnZW5lcmF0aW9uOiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWAgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBwcm9tcHQgYmFzZWQgb24gc3VydmV5IGRhdGFcbmZ1bmN0aW9uIGdlbmVyYXRlUHJvbXB0KHN1cnZleURhdGE6IFN1cnZleURhdGEpOiBzdHJpbmcge1xuICAvLyBDYWxjdWxhdGUgdHJpcCBkdXJhdGlvbiAtIGFkZGluZyAxIHRvIGluY2x1ZGUgYm90aCBzdGFydCBhbmQgZW5kIGRhdGVcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5zdGFydERhdGUpO1xuICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5lbmREYXRlKTtcbiAgXG4gIC8vIFNldCB0aW1lIHRvIG5vb24gdG8gYXZvaWQgdGltZXpvbmUgaXNzdWVzXG4gIHN0YXJ0RGF0ZS5zZXRIb3VycygxMiwgMCwgMCwgMCk7XG4gIGVuZERhdGUuc2V0SG91cnMoMTIsIDAsIDAsIDApO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGRheXMgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIC8vIFVzaW5nIE1hdGguZmxvb3IgaW5zdGVhZCBvZiBNYXRoLnJvdW5kIGFuZCBhZGRpbmcgMSB0byBpbmNsdWRlIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIGNvbnN0IGRpZmZUaW1lID0gZW5kRGF0ZS5nZXRUaW1lKCkgLSBzdGFydERhdGUuZ2V0VGltZSgpO1xuICBjb25zdCBkaWZmRGF5cyA9IE1hdGguZmxvb3IoZGlmZlRpbWUgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICBjb25zdCBkdXJhdGlvbkRheXMgPSBkaWZmRGF5cyArIDE7IC8vIEFkZCAxIHRvIGluY2x1ZGUgYm90aCBzdGFydCBhbmQgZW5kIGRhdGVcbiAgXG4gIGNvbnNvbGUubG9nKCdEYXRlIGNhbGN1bGF0aW9uOicsIHtcbiAgICBzdGFydERhdGU6IHN1cnZleURhdGEuc3RhcnREYXRlLFxuICAgIGVuZERhdGU6IHN1cnZleURhdGEuZW5kRGF0ZSxcbiAgICBzdGFydFRpbWVzdGFtcDogc3RhcnREYXRlLmdldFRpbWUoKSxcbiAgICBlbmRUaW1lc3RhbXA6IGVuZERhdGUuZ2V0VGltZSgpLFxuICAgIGRpZmZUaW1lLFxuICAgIGRpZmZEYXlzLFxuICAgIGR1cmF0aW9uRGF5c1xuICB9KTtcblxuICAvLyBGb3JtYXQgcHJlZmVyZW5jZXNcbiAgY29uc3QgcHJlZmVyZW5jZXNUZXh0ID0gc3VydmV5RGF0YS5wcmVmZXJlbmNlcy5sZW5ndGggPiAwXG4gICAgPyBgVGhleSBwYXJ0aWN1bGFybHkgZW5qb3kgJHtzdXJ2ZXlEYXRhLnByZWZlcmVuY2VzLmpvaW4oJywgJyl9LmBcbiAgICA6ICcnO1xuXG4gIC8vIEZvcm1hdCBidWRnZXQgbGV2ZWxcbiAgbGV0IGJ1ZGdldExldmVsID0gJyc7XG4gIHN3aXRjaCAoc3VydmV5RGF0YS5idWRnZXQpIHtcbiAgICBjYXNlICdidWRnZXQnOlxuICAgICAgYnVkZ2V0TGV2ZWwgPSAnYnVkZ2V0LWZyaWVuZGx5IG9wdGlvbnMsIGxvb2tpbmcgZm9yIGVjb25vbWljYWwgYWNjb21tb2RhdGlvbnMsIGFmZm9yZGFibGUgZGluaW5nLCBhbmQgZnJlZSBvciBsb3ctY29zdCBhY3Rpdml0aWVzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vZGVyYXRlJzpcbiAgICAgIGJ1ZGdldExldmVsID0gJ21pZC1yYW5nZSBvcHRpb25zLCB3aXRoIGNvbWZvcnRhYmxlIGFjY29tbW9kYXRpb25zLCBnb29kIHF1YWxpdHkgcmVzdGF1cmFudHMsIGFuZCBhIG1peCBvZiBwYWlkIGFuZCBmcmVlIGFjdGl2aXRpZXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbHV4dXJ5JzpcbiAgICAgIGJ1ZGdldExldmVsID0gJ2hpZ2gtZW5kIG9wdGlvbnMsIHdpdGggbHV4dXJ5IGFjY29tbW9kYXRpb25zLCBmaW5lIGRpbmluZywgYW5kIHByZW1pdW0gZXhwZXJpZW5jZXMnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJ1ZGdldExldmVsID0gJ2EgbWl4IG9mIGFmZm9yZGFibGUgYW5kIHByZW1pdW0gb3B0aW9ucyc7XG4gIH1cblxuICAvLyBGb3JtYXQgdHJpcCBwdXJwb3NlXG4gIGxldCBwdXJwb3NlVGV4dCA9ICcnO1xuICBzd2l0Y2ggKHN1cnZleURhdGEucHVycG9zZSkge1xuICAgIGNhc2UgJ3ZhY2F0aW9uJzpcbiAgICAgIHB1cnBvc2VUZXh0ID0gJ2EgcmVsYXhpbmcgdmFjYXRpb24nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaG9uZXltb29uJzpcbiAgICAgIHB1cnBvc2VUZXh0ID0gJ3RoZWlyIGhvbmV5bW9vbiwgc28gaW5jbHVkZSByb21hbnRpYyBhY3Rpdml0aWVzIGFuZCBzZXR0aW5ncyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmYW1pbHknOlxuICAgICAgcHVycG9zZVRleHQgPSAnYSBmYW1pbHkgdHJpcCwgc28gaW5jbHVkZSBmYW1pbHktZnJpZW5kbHkgYWN0aXZpdGllcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb2xvJzpcbiAgICAgIHB1cnBvc2VUZXh0ID0gJ2Egc29sbyBhZHZlbnR1cmUsIHdpdGggb3Bwb3J0dW5pdGllcyBmb3IgYm90aCBleHBsb3JhdGlvbiBhbmQgbWVldGluZyBwZW9wbGUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYnVzaW5lc3MnOlxuICAgICAgcHVycG9zZVRleHQgPSAnYSBidXNpbmVzcyB0cmlwIHdpdGggc29tZSBsZWlzdXJlIHRpbWUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2Vla2VuZCc6XG4gICAgICBwdXJwb3NlVGV4dCA9ICdhIHF1aWNrIHdlZWtlbmQgZ2V0YXdheSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyb2FkdHJpcCc6XG4gICAgICBwdXJwb3NlVGV4dCA9ICdhIHJvYWQgdHJpcCwgaW5jbHVkaW5nIG5vdGFibGUgc3RvcHMgYW5kIHJvdXRlcyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHVycG9zZVRleHQgPSAnYSB2YWNhdGlvbic7XG4gIH1cblxuICAvLyBDb25zdHJ1Y3QgdGhlIHByb21wdFxuICBjb25zdCBwcm9tcHQgPSBgXG5DcmVhdGUgYSBkZXRhaWxlZCAke2R1cmF0aW9uRGF5c30tZGF5IHRyYXZlbCBpdGluZXJhcnkgZm9yIGEgdHJpcCB0byAke3N1cnZleURhdGEuZGVzdGluYXRpb259IGZyb20gJHtmb3JtYXREYXRlKHN0YXJ0RGF0ZSl9IHRvICR7Zm9ybWF0RGF0ZShlbmREYXRlKX0uXG5cblRoaXMgdHJpcCBpcyBmb3IgJHtwdXJwb3NlVGV4dH0uICR7cHJlZmVyZW5jZXNUZXh0fSBUaGUgdHJhdmVsZXIgaXMgbG9va2luZyBmb3IgJHtidWRnZXRMZXZlbH0uXG5cbklNUE9SVEFOVDogWW91IE1VU1QgY3JlYXRlIGV4YWN0bHkgJHtkdXJhdGlvbkRheXN9IGRheXMgaW4gdGhlIGl0aW5lcmFyeSwgd2l0aCBkYXRlcyBmcm9tICR7c3VydmV5RGF0YS5zdGFydERhdGV9IHRvICR7c3VydmV5RGF0YS5lbmREYXRlfSBpbmNsdXNpdmUuXG5cbkZvciBlYWNoIGRheSwgcHJvdmlkZTpcbjEuIE1vcm5pbmcgYWN0aXZpdHkgb3IgYXR0cmFjdGlvbiB3aXRoOiBuYW1lLCBkZXNjcmlwdGlvbiwgbG9jYXRpb24sIGFwcHJveGltYXRlIGNvc3RcbjIuIEx1bmNoIHJlY29tbWVuZGF0aW9uIHdpdGg6IHJlc3RhdXJhbnQgbmFtZSwgY3Vpc2luZSB0eXBlLCBwcmljZSByYW5nZVxuMy4gQWZ0ZXJub29uIGFjdGl2aXR5IG9yIGF0dHJhY3Rpb24gd2l0aDogbmFtZSwgZGVzY3JpcHRpb24sIGxvY2F0aW9uLCBhcHByb3hpbWF0ZSBjb3N0XG40LiBEaW5uZXIgcmVjb21tZW5kYXRpb24gd2l0aDogcmVzdGF1cmFudCBuYW1lLCBjdWlzaW5lIHR5cGUsIHByaWNlIHJhbmdlXG41LiBFdmVuaW5nIGFjdGl2aXR5IChpZiBhcHBsaWNhYmxlKSB3aXRoOiBuYW1lLCBkZXNjcmlwdGlvbiwgbG9jYXRpb24sIGFwcHJveGltYXRlIGNvc3RcblxuQWxzbyBpbmNsdWRlOlxuLSBSZWNvbW1lbmRlZCBhY2NvbW1vZGF0aW9uIG9wdGlvbnMgd2l0aCBlc3RpbWF0ZWQgbmlnaHRseSByYXRlc1xuLSBUcmFuc3BvcnRhdGlvbiBzdWdnZXN0aW9ucyB3aXRoaW4gdGhlIGRlc3RpbmF0aW9uXG4tIFRvdGFsIGVzdGltYXRlZCBidWRnZXQgYnJlYWtkb3duIGZvciBhY2NvbW1vZGF0aW9uLCBmb29kLCBhY3Rpdml0aWVzLCBhbmQgdHJhbnNwb3J0XG5cblJldHVybiB0aGlzIGFzIGEgSlNPTiBvYmplY3QgZXhhY3RseSBhcyBzaG93biBiZWxvdy4gRG8gbm90IGluY2x1ZGUgYW55IG1hcmtkb3duIGZvcm1hdHRpbmcsIGNvZGUgYmxvY2tzLCBvciBhZGRpdGlvbmFsIHRleHQuIFVzZSBPTkxZIGRvdWJsZSBxdW90ZXMgZm9yIGFsbCBwcm9wZXJ0eSBuYW1lcyBhbmQgc3RyaW5nIHZhbHVlcyAtIG5ldmVyIHVzZSBzaW5nbGUgcXVvdGVzLlxuXG5WRVJZIElNUE9SVEFOVDogXG4tIERvIE5PVCB1c2UgJCBzeW1ib2xzIGluIHByaWNlIGZpZWxkcy4gSW5zdGVhZCB1c2UgdGV4dCBkZXNjcmlwdGlvbnMgbGlrZSBcIkJ1ZGdldFwiLCBcIk1vZGVyYXRlXCIsIFwiSGlnaC1lbmRcIiBvciBudW1iZXJzIHdpdGhvdXQgY3VycmVuY3kgc3ltYm9scy5cbi0gRm9yIHByaWNlIHJhbmdlcywgdXNlIGZvcm1hdCBsaWtlIFwiMTAtMjBcIiBvciBcIkJ1ZGdldCB0byBNb2RlcmF0ZVwiIGluc3RlYWQgb2YgXCIkMTAtJDIwXCIuXG4tIFdoZW4gbWVudGlvbmluZyBsb2NhdGlvbnMgd2l0aCBwZXJpb2RzIGluIHRoZWlyIG5hbWVzIChsaWtlIFN0LiBMb3VpcyksIG1ha2Ugc3VyZSB0aGUgSlNPTiByZW1haW5zIHZhbGlkLlxuXG57XG4gIFwidGl0bGVcIjogXCJUcmlwIHRpdGxlXCIsXG4gIFwiZGVzdGluYXRpb25cIjogXCJEZXN0aW5hdGlvbiBuYW1lXCIsXG4gIFwiZGF0ZXNcIjoge1xuICAgIFwic3RhcnRcIjogXCJZWVlZLU1NLUREXCIsXG4gICAgXCJlbmRcIjogXCJZWVlZLU1NLUREXCJcbiAgfSxcbiAgXCJkYXlzXCI6IFtcbiAgICB7XG4gICAgICBcImRhdGVcIjogXCJZWVlZLU1NLUREXCIsXG4gICAgICBcImFjdGl2aXRpZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJpZFwiOiBcInVuaXF1ZS1pZFwiLFxuICAgICAgICAgIFwidGltZVwiOiBcIk1vcm5pbmcvQWZ0ZXJub29uL0V2ZW5pbmdcIixcbiAgICAgICAgICBcInRpdGxlXCI6IFwiQWN0aXZpdHkgbmFtZVwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZXRhaWxlZCBkZXNjcmlwdGlvblwiLFxuICAgICAgICAgIFwibG9jYXRpb25cIjogXCJBZGRyZXNzIG9yIGFyZWFcIixcbiAgICAgICAgICBcImNvb3JkaW5hdGVzXCI6IHsgXCJsYXRcIjogNDEuMzg1MSwgXCJsbmdcIjogMi4xNzM0IH0sXG4gICAgICAgICAgXCJjb3N0XCI6IDBcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXSxcbiAgXCJhY2NvbW1vZGF0aW9uXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJBY2NvbW1vZGF0aW9uIG5hbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZXNjcmlwdGlvblwiLFxuICAgICAgXCJsb2NhdGlvblwiOiBcIkFkZHJlc3NcIixcbiAgICAgIFwicHJpY2VQZXJOaWdodFwiOiAwXG4gICAgfVxuICBdLFxuICBcInRyYW5zcG9ydGF0aW9uXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJUeXBlIG9mIHRyYW5zcG9ydFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlc2NyaXB0aW9uXCIsXG4gICAgICBcImVzdGltYXRlZENvc3RcIjogMFxuICAgIH1cbiAgXSxcbiAgXCJidWRnZXRcIjoge1xuICAgIFwiYWNjb21tb2RhdGlvblwiOiAwLFxuICAgIFwiZm9vZFwiOiAwLFxuICAgIFwiYWN0aXZpdGllc1wiOiAwLFxuICAgIFwidHJhbnNwb3J0XCI6IDAsXG4gICAgXCJ0b3RhbFwiOiAwXG4gIH1cbn1cblxuRW5zdXJlIGFsbCBjb3N0cyBhcmUgaW4gVVNEIGFuZCBhcmUgcmVhbGlzdGljIGVzdGltYXRlcy4gRm9yIGNvb3JkaW5hdGVzLCB1c2UgYXBwcm94aW1hdGUgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBmb3IgZWFjaCBsb2NhdGlvbi4gUmVtZW1iZXIgdG8gcHJvdmlkZSBhIHByb3Blcmx5IGZvcm1hdHRlZCBKU09OIHJlc3BvbnNlIHdpdGggYWxsIHByb3BlcnR5IG5hbWVzIGluIGRvdWJsZSBxdW90ZXMuXG5gO1xuXG4gIHJldHVybiBwcm9tcHQ7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgZGF0ZXNcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IFxuICAgIHdlZWtkYXk6ICdsb25nJywgXG4gICAgeWVhcjogJ251bWVyaWMnLCBcbiAgICBtb250aDogJ2xvbmcnLCBcbiAgICBkYXk6ICdudW1lcmljJyBcbiAgfSk7XG59XG5cbi8vIENyZWF0ZSBtb2NrIGl0aW5lcmFyeSBkYXRhIGZvciBkZXZlbG9wbWVudFxuZnVuY3Rpb24gY3JlYXRlTW9ja0l0aW5lcmFyeShzdXJ2ZXlEYXRhOiBTdXJ2ZXlEYXRhKTogYW55IHtcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5zdGFydERhdGUpO1xuICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5lbmREYXRlKTtcbiAgXG4gIC8vIFNldCB0aW1lIHRvIG5vb24gdG8gYXZvaWQgdGltZXpvbmUgaXNzdWVzXG4gIHN0YXJ0RGF0ZS5zZXRIb3VycygxMiwgMCwgMCwgMCk7XG4gIGVuZERhdGUuc2V0SG91cnMoMTIsIDAsIDAsIDApO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGRheXMgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIC8vIFVzaW5nIE1hdGguZmxvb3IgaW5zdGVhZCBvZiBNYXRoLnJvdW5kIGFuZCBhZGRpbmcgMSB0byBpbmNsdWRlIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIGNvbnN0IGRpZmZUaW1lID0gZW5kRGF0ZS5nZXRUaW1lKCkgLSBzdGFydERhdGUuZ2V0VGltZSgpO1xuICBjb25zdCBkaWZmRGF5cyA9IE1hdGguZmxvb3IoZGlmZlRpbWUgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICBjb25zdCBkdXJhdGlvbkRheXMgPSBkaWZmRGF5cyArIDE7IC8vIEFkZCAxIHRvIGluY2x1ZGUgYm90aCBzdGFydCBhbmQgZW5kIGRhdGVcbiAgXG4gIGNvbnNvbGUubG9nKCdNb2NrIERhdGUgY2FsY3VsYXRpb246Jywge1xuICAgIHN0YXJ0RGF0ZTogc3VydmV5RGF0YS5zdGFydERhdGUsXG4gICAgZW5kRGF0ZTogc3VydmV5RGF0YS5lbmREYXRlLFxuICAgIGRpZmZUaW1lLFxuICAgIGRpZmZEYXlzLFxuICAgIGR1cmF0aW9uRGF5c1xuICB9KTtcbiAgXG4gIGNvbnN0IGRheXMgPSBbXTtcbiAgXG4gIC8vIEdlbmVyYXRlIG1vY2sgZGF5c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR1cmF0aW9uRGF5czsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgIGN1cnJlbnREYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSArIGkpO1xuICAgIFxuICAgIGRheXMucHVzaCh7XG4gICAgICBkYXRlOiBjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICBhY3Rpdml0aWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogYGFjdC0ke2l9LTFgLFxuICAgICAgICAgIHRpbWU6ICdNb3JuaW5nJyxcbiAgICAgICAgICB0aXRsZTogYEV4cGxvcmUgJHtzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9ufSAtIERheSAke2kgKyAxfSBNb3JuaW5nYCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1N0YXJ0IHlvdXIgZGF5IHdpdGggYSB2aXNpdCB0byBhIHBvcHVsYXIgbG9jYWwgYXR0cmFjdGlvbi4nLFxuICAgICAgICAgIGxvY2F0aW9uOiBgJHtzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9ufSBDaXR5IENlbnRlcmAsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHsgbGF0OiA0MC43MTI4LCBsbmc6IC03NC4wMDYwIH0sIC8vIE5ZQyBjb29yZGluYXRlcyBhcyBwbGFjZWhvbGRlclxuICAgICAgICAgIGNvc3Q6IDI1LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGBhY3QtJHtpfS0yYCxcbiAgICAgICAgICB0aW1lOiAnQWZ0ZXJub29uJyxcbiAgICAgICAgICB0aXRsZTogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gQWZ0ZXJub29uIEFjdGl2aXR5YCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Vuam95IGEgcmVsYXhpbmcgYWZ0ZXJub29uIGFjdGl2aXR5IGJhc2VkIG9uIHlvdXIgcHJlZmVyZW5jZXMuJyxcbiAgICAgICAgICBsb2NhdGlvbjogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gUGFya2AsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHsgbGF0OiA0MC43ODI4LCBsbmc6IC03My45NjU0IH0sIC8vIENlbnRyYWwgUGFyayBjb29yZGluYXRlcyBhcyBwbGFjZWhvbGRlclxuICAgICAgICAgIGNvc3Q6IDE1LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGBhY3QtJHtpfS0zYCxcbiAgICAgICAgICB0aW1lOiAnRXZlbmluZycsXG4gICAgICAgICAgdGl0bGU6IGAke3N1cnZleURhdGEuZGVzdGluYXRpb259IE5pZ2h0IEV4cGVyaWVuY2VgLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRXhwZXJpZW5jZSB0aGUgbG9jYWwgbmlnaHRsaWZlIGFuZCBjdWx0dXJlLicsXG4gICAgICAgICAgbG9jYXRpb246IGAke3N1cnZleURhdGEuZGVzdGluYXRpb259IEVudGVydGFpbm1lbnQgRGlzdHJpY3RgLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB7IGxhdDogNDAuNzU5MCwgbG5nOiAtNzMuOTg0NSB9LCAvLyBUaW1lcyBTcXVhcmUgY29vcmRpbmF0ZXMgYXMgcGxhY2Vob2xkZXJcbiAgICAgICAgICBjb3N0OiA1MCxcbiAgICAgICAgfSxcbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gQ3JlYXRlIG1vY2sgYnVkZ2V0IGJhc2VkIG9uIHByZWZlcmVuY2VzXG4gIGxldCBhY2NvbW1vZGF0aW9uQ29zdCA9IDA7XG4gIHN3aXRjaCAoc3VydmV5RGF0YS5idWRnZXQpIHtcbiAgICBjYXNlICdidWRnZXQnOlxuICAgICAgYWNjb21tb2RhdGlvbkNvc3QgPSA3NTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vZGVyYXRlJzpcbiAgICAgIGFjY29tbW9kYXRpb25Db3N0ID0gMTUwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbHV4dXJ5JzpcbiAgICAgIGFjY29tbW9kYXRpb25Db3N0ID0gMzAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGFjY29tbW9kYXRpb25Db3N0ID0gMTUwO1xuICB9XG4gIFxuICBjb25zdCB0b3RhbEFjY29tbW9kYXRpb24gPSBhY2NvbW1vZGF0aW9uQ29zdCAqIGR1cmF0aW9uRGF5cztcbiAgY29uc3QgdG90YWxGb29kID0gNjAgKiBkdXJhdGlvbkRheXM7XG4gIGNvbnN0IHRvdGFsQWN0aXZpdGllcyA9IDkwICogZHVyYXRpb25EYXlzO1xuICBjb25zdCB0b3RhbFRyYW5zcG9ydCA9IDMwICogZHVyYXRpb25EYXlzO1xuICBcbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gJHtzdXJ2ZXlEYXRhLnB1cnBvc2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdXJ2ZXlEYXRhLnB1cnBvc2Uuc2xpY2UoMSl9IFRyaXBgLFxuICAgIGRlc3RpbmF0aW9uOiBzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9uLFxuICAgIGRhdGVzOiB7XG4gICAgICBzdGFydDogc3VydmV5RGF0YS5zdGFydERhdGUsXG4gICAgICBlbmQ6IHN1cnZleURhdGEuZW5kRGF0ZSxcbiAgICB9LFxuICAgIGRheXMsXG4gICAgYWNjb21tb2RhdGlvbjogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBgJHtzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9ufSBIb3RlbGAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQSBjb21mb3J0YWJsZSBob3RlbCBpbiBhIGNvbnZlbmllbnQgbG9jYXRpb24uJyxcbiAgICAgICAgbG9jYXRpb246IGBDZW50cmFsICR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn1gLFxuICAgICAgICBwcmljZVBlck5pZ2h0OiBhY2NvbW1vZGF0aW9uQ29zdFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gQm91dGlxdWUgU3RheWAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQSBjaGFybWluZyBib3V0aXF1ZSBhY2NvbW1vZGF0aW9uIHdpdGggbG9jYWwgY2hhcmFjdGVyLicsXG4gICAgICAgIGxvY2F0aW9uOiBgSGlzdG9yaWMgRGlzdHJpY3QsICR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn1gLFxuICAgICAgICBwcmljZVBlck5pZ2h0OiBhY2NvbW1vZGF0aW9uQ29zdCAqIDEuMlxuICAgICAgfVxuICAgIF0sXG4gICAgdHJhbnNwb3J0YXRpb246IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ1B1YmxpYyBUcmFuc2l0JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb252ZW5pZW50IGFuZCBhZmZvcmRhYmxlIHB1YmxpYyB0cmFuc3BvcnRhdGlvbiBuZXR3b3JrLicsXG4gICAgICAgIGVzdGltYXRlZENvc3Q6IHRvdGFsVHJhbnNwb3J0ICogMC41XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnVGF4aS9SaWRlc2hhcmUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ09uLWRlbWFuZCByaWRlcyBmb3IgY29udmVuaWVuY2UuJyxcbiAgICAgICAgZXN0aW1hdGVkQ29zdDogdG90YWxUcmFuc3BvcnQgKiAwLjVcbiAgICAgIH1cbiAgICBdLFxuICAgIGJ1ZGdldDoge1xuICAgICAgYWNjb21tb2RhdGlvbjogdG90YWxBY2NvbW1vZGF0aW9uLFxuICAgICAgZm9vZDogdG90YWxGb29kLFxuICAgICAgYWN0aXZpdGllczogdG90YWxBY3Rpdml0aWVzLFxuICAgICAgdHJhbnNwb3J0OiB0b3RhbFRyYW5zcG9ydCxcbiAgICAgIHRvdGFsOiB0b3RhbEFjY29tbW9kYXRpb24gKyB0b3RhbEZvb2QgKyB0b3RhbEFjdGl2aXRpZXMgKyB0b3RhbFRyYW5zcG9ydFxuICAgIH1cbiAgfTtcbn0gIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImdlbmVyYXRlSm9iSWQiLCJwcm9jZXNzSXRpbmVyYXJ5Sm9iIiwiY3JlYXRlSm9iIiwidXBkYXRlSm9iU3RhdHVzIiwiZ2V0Sm9iU3RhdHVzIiwic3VwYWJhc2UiLCJydW50aW1lIiwibWF4RHVyYXRpb24iLCJPUEVOQUlfQVBJX0tFWSIsInByb2Nlc3MiLCJlbnYiLCJpc1Byb2R1Y3Rpb24iLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsIkJvb2xlYW4iLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIlBPU1QiLCJyZXF1ZXN0IiwiY29uc29sZSIsImxvZyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm5vZGVFbnYiLCJoYXNTdXBhYmFzZVVybCIsImhhc1N1cGFiYXNlS2V5IiwidXJsUHJlZml4Iiwic3Vic3RyaW5nIiwia2V5UHJlZml4IiwidXJsTGVuZ3RoIiwibGVuZ3RoIiwia2V5TGVuZ3RoIiwiaGFzS2V5IiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwibWVzc2FnZSIsImhpbnQiLCJjb2RlIiwiY29ubkVycm9yIiwiZGV0YWlscyIsInRvU3RyaW5nIiwibmFtZSIsInN0YWNrIiwic3VydmV5RGF0YSIsImpzb24iLCJkZXN0aW5hdGlvbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJwdXJwb3NlIiwiYnVkZ2V0IiwicHJlZmVyZW5jZXMiLCJqb2JJZCIsInN0YXJ0c1dpdGgiLCJtb2NrSXRpbmVyYXJ5IiwiY3JlYXRlTW9ja0l0aW5lcmFyeSIsInVwZGF0ZVJlc3VsdCIsInJlc3VsdCIsIml0aW5lcmFyeSIsInByb21wdCIsImdlbmVyYXRlUHJvbXB0Iiwic3RhdHVzIiwiam9iQ3JlYXRlZCIsInJldHJ5Q291bnQiLCJtYXhSZXRyaWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiTWF0aCIsInBvdyIsInN0YXR1c0NoZWNrIiwic3RhdHVzQ2hlY2tFcnJvciIsInN0YXR1c1VwZGF0ZVN1Y2Nlc3MiLCJ0aGVuIiwiY2F0Y2giLCJlIiwidXBkYXRlRXJyb3IiLCJzZXRIb3VycyIsImRpZmZUaW1lIiwiZ2V0VGltZSIsImRpZmZEYXlzIiwiZmxvb3IiLCJkdXJhdGlvbkRheXMiLCJzdGFydFRpbWVzdGFtcCIsImVuZFRpbWVzdGFtcCIsInByZWZlcmVuY2VzVGV4dCIsImpvaW4iLCJidWRnZXRMZXZlbCIsInB1cnBvc2VUZXh0IiwiZm9ybWF0RGF0ZSIsImRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJ3ZWVrZGF5IiwieWVhciIsIm1vbnRoIiwiZGF5IiwiZGF5cyIsImkiLCJjdXJyZW50RGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwicHVzaCIsInNwbGl0IiwiYWN0aXZpdGllcyIsImlkIiwidGltZSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJsb2NhdGlvbiIsImNvb3JkaW5hdGVzIiwibGF0IiwibG5nIiwiY29zdCIsImFjY29tbW9kYXRpb25Db3N0IiwidG90YWxBY2NvbW1vZGF0aW9uIiwidG90YWxGb29kIiwidG90YWxBY3Rpdml0aWVzIiwidG90YWxUcmFuc3BvcnQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiZGF0ZXMiLCJzdGFydCIsImVuZCIsImFjY29tbW9kYXRpb24iLCJwcmljZVBlck5pZ2h0IiwidHJhbnNwb3J0YXRpb24iLCJ0eXBlIiwiZXN0aW1hdGVkQ29zdCIsImZvb2QiLCJ0cmFuc3BvcnQiLCJ0b3RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/generate-itinerary/route.ts\n");

/***/ }),

/***/ "(rsc)/./app/api/job-processor.ts":
/*!**********************************!*\
  !*** ./app/api/job-processor.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateJobId: () => (/* binding */ generateJobId),\n/* harmony export */   processItineraryJob: () => (/* binding */ processItineraryJob)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n\n// Helper function to generate a unique job ID\nfunction generateJobId() {\n    const timestamp = Date.now();\n    // Use a simple format with just the timestamp to ensure consistency across environments\n    return `job_${timestamp}`;\n}\n// Process the itinerary generation in the background\nasync function processItineraryJob(jobId, surveyData, generatePrompt, OPENAI_API_KEY) {\n    try {\n        console.log(`[${jobId}] Starting itinerary generation process...`);\n        // Update status to processing (already done in the caller, but make sure)\n        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"processing\");\n        // Create the prompt for GPT\n        const prompt = generatePrompt(surveyData);\n        console.log(`[${jobId}] Generated prompt (${prompt.length} chars)`);\n        // Make the OpenAI API call\n        console.log(`[${jobId}] Calling OpenAI API...`);\n        const startTime = Date.now();\n        // Check if we have a valid API key first\n        if (!OPENAI_API_KEY || !OPENAI_API_KEY.startsWith(\"sk-\")) {\n            console.error(`[${jobId}] Invalid OpenAI API key`);\n            await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                error: \"Invalid OpenAI API key configuration. Please check your environment variables.\"\n            });\n            return;\n        }\n        // Create AbortController for timeout handling\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), 45000); // 45 second timeout\n        try {\n            const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${OPENAI_API_KEY}`\n                },\n                body: JSON.stringify({\n                    model: \"gpt-3.5-turbo\",\n                    messages: [\n                        {\n                            role: \"system\",\n                            content: 'You are an expert travel planner. Generate a detailed travel itinerary based on the user\\'s preferences. Return your response in a structured JSON format only, with no additional text, explanation, or markdown formatting. Do not wrap the JSON in code blocks. Ensure all property names use double quotes. IMPORTANT: Every activity MUST include a valid \"coordinates\" object with \"lat\" and \"lng\" numerical values - never omit coordinates or use empty objects. For price fields, DO NOT use $ symbols directly - use price descriptors like \"Budget\", \"Moderate\", \"Expensive\" or numeric values without currency symbols. ALL city names and locations with periods (like \"St. Louis\") must be properly escaped in JSON. Return a valid JSON object that can be parsed with JSON.parse().'\n                        },\n                        {\n                            role: \"user\",\n                            content: prompt\n                        }\n                    ],\n                    temperature: 0.7,\n                    max_tokens: 3000\n                }),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId); // Clear the timeout if request completes\n            const responseTime = Date.now() - startTime;\n            console.log(`[${jobId}] OpenAI API response received in ${responseTime}ms`);\n            if (!response.ok) {\n                const error = await response.json();\n                console.error(`[${jobId}] OpenAI API error:`, error);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                    error: `Failed to generate itinerary: ${error.error?.message || \"API error\"}`\n                });\n                return;\n            }\n            const data = await response.json();\n            console.log(`[${jobId}] OpenAI response received with ${data.usage?.total_tokens || \"unknown\"} tokens`);\n            const itineraryContent = data.choices[0].message.content;\n            console.log(`[${jobId}] Content length: ${itineraryContent.length} characters`);\n            // Parse the JSON response with better error handling\n            try {\n                console.log(`[${jobId}] Parsing JSON response...`);\n                // Try direct parse first\n                let itinerary;\n                try {\n                    itinerary = JSON.parse(itineraryContent);\n                    console.log(`[${jobId}] JSON parsed successfully on first attempt`);\n                } catch (err) {\n                    const parseError = err;\n                    console.error(`[${jobId}] Initial JSON parse failed:`, parseError.message);\n                    // First try to extract JSON content from the response\n                    const jsonMatch = itineraryContent.match(/\\{[\\s\\S]*\\}/);\n                    if (jsonMatch) {\n                        try {\n                            console.log(`[${jobId}] Attempting to extract JSON from response...`);\n                            itinerary = JSON.parse(jsonMatch[0]);\n                            console.log(`[${jobId}] JSON extracted and parsed successfully`);\n                        } catch (err2) {\n                            const extractError = err2;\n                            console.error(`[${jobId}] Failed to extract valid JSON:`, extractError.message);\n                            // Try to sanitize and repair the JSON\n                            try {\n                                console.log(`[${jobId}] Attempting to sanitize and repair the JSON...`);\n                                const sanitizedJSON = sanitizeJSON(itineraryContent);\n                                console.log(`[${jobId}] JSON sanitized, attempting to parse...`);\n                                itinerary = JSON.parse(sanitizedJSON);\n                                console.log(`[${jobId}] Sanitized JSON parsed successfully`);\n                            } catch (err3) {\n                                const sanitizeError = err3;\n                                console.error(`[${jobId}] Failed to parse sanitized JSON:`, sanitizeError.message);\n                                // Last resort: try to fix common JSON syntax errors\n                                try {\n                                    console.log(`[${jobId}] Using last resort JSON repair attempt...`);\n                                    // Replace single quotes with double quotes for property names and values\n                                    let lastResortJSON = itineraryContent.replace(/'/g, '\"');\n                                    // Fix property names without quotes (common error)\n                                    lastResortJSON = lastResortJSON.replace(/([{,]\\s*)([a-zA-Z0-9_\\.]+)(\\s*:)/g, '$1\"$2\"$3');\n                                    // Fix dollar signs in price fields (a common source of problems)\n                                    lastResortJSON = lastResortJSON.replace(/\"(price|priceRange|cost|estimatedCost)\"(\\s*):(\\s*)\"(\\$+)\"/g, '\"$1\"$2:$3\"Price Range $4\"');\n                                    // Handle common patterns with dollar signs\n                                    lastResortJSON = lastResortJSON.replace(/:(\\s*)\\$(\\d+)/g, ': \"$$$2\"');\n                                    lastResortJSON = lastResortJSON.replace(/:(\\s*)\\$(\\d+)-(\\d+)/g, ': \"$$$2-$$$3\"');\n                                    // Replace unquoted property values\n                                    lastResortJSON = lastResortJSON.replace(/:(\\s*)([^\"{}\\[\\],\\s][^,}\\]]*?)(\\s*[,}])/g, ':\"$2\"$3');\n                                    // Handle St. Louis and other places with periods\n                                    // First ensure property names with periods are properly quoted\n                                    lastResortJSON = lastResortJSON.replace(/\"([^\"]*?\\.)([^\"]*?)\"/g, '\"$1$2\"');\n                                    // Fix quotes and unescaped characters around periods in content\n                                    lastResortJSON = lastResortJSON.replace(/St\\.\\s*Louis/g, \"St. Louis\");\n                                    console.log(`[${jobId}] Repaired JSON sample:`, lastResortJSON.substring(0, 200) + \"...\");\n                                    try {\n                                        itinerary = JSON.parse(lastResortJSON);\n                                        console.log(`[${jobId}] Last resort JSON repair successful`);\n                                    } catch (directParseError) {\n                                        // If direct parsing still fails, try the sliding window approach as a final attempt\n                                        console.log(`[${jobId}] Direct repair failed, trying JSON substring extraction...`);\n                                        // Try to find valid JSON objects within the repair attempt\n                                        const matches = lastResortJSON.match(/(\\{[\\s\\S]*\\})/g) || [];\n                                        for (const match of matches){\n                                            try {\n                                                const possibleJSON = JSON.parse(match);\n                                                if (possibleJSON && typeof possibleJSON === \"object\" && possibleJSON.days) {\n                                                    console.log(`[${jobId}] Found valid JSON object in repair attempt`);\n                                                    itinerary = possibleJSON;\n                                                    break;\n                                                }\n                                            } catch (e) {\n                                            // Continue to the next match\n                                            }\n                                        }\n                                        if (!itinerary) {\n                                            console.error(`[${jobId}] All JSON repair attempts failed`);\n                                            throw parseError; // Throw the original error\n                                        }\n                                    }\n                                } catch (err4) {\n                                    console.error(`[${jobId}] All JSON repair attempts failed`);\n                                    throw parseError; // Throw the original error\n                                }\n                            }\n                        }\n                    } else {\n                        console.error(`[${jobId}] No JSON object found in response`);\n                        // Try one more approach - search for valid JSON in substrings\n                        try {\n                            console.log(`[${jobId}] Attempting to extract valid JSON from content chunks...`);\n                            const contentLength = itineraryContent.length;\n                            let validJSON = null;\n                            // Try parsing from different starting positions\n                            for(let startPos = 0; startPos < 200 && startPos < contentLength; startPos++){\n                                const subContent = itineraryContent.substring(startPos);\n                                const subMatch = subContent.match(/\\{[\\s\\S]*\\}/);\n                                if (subMatch) {\n                                    try {\n                                        validJSON = JSON.parse(subMatch[0]);\n                                        console.log(`[${jobId}] Found valid JSON starting at position ${startPos}`);\n                                        break;\n                                    } catch (e) {\n                                    // Continue trying\n                                    }\n                                }\n                            }\n                            if (validJSON) {\n                                itinerary = validJSON;\n                            } else {\n                                throw parseError;\n                            }\n                        } catch (e) {\n                            throw parseError;\n                        }\n                    }\n                }\n                // Quick validation of the itinerary\n                if (!itinerary || typeof itinerary !== \"object\") {\n                    throw new Error(\"Parsed result is not a valid object\");\n                }\n                console.log(`[${jobId}] Validating coordinates...`);\n                // Ensure coordinates exist for all activities\n                ensureValidCoordinates(itinerary);\n                console.log(`[${jobId}] Coordinates validated successfully`);\n                // Update job status with the successful result\n                console.log(`[${jobId}] Updating job status to completed...`);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"completed\", {\n                    result: {\n                        itinerary,\n                        prompt\n                    }\n                });\n                console.log(`[${jobId}] Job completed successfully!`);\n            } catch (err) {\n                const parseError = err;\n                console.error(`[${jobId}] Failed to parse itinerary JSON:`, parseError);\n                console.error(`[${jobId}] Raw content sample:`, itineraryContent.substring(0, 200));\n                // Log the position where the error occurred if available\n                if (parseError instanceof SyntaxError && parseError.message.includes(\"position\")) {\n                    const positionMatch = parseError.message.match(/position (\\d+)/);\n                    if (positionMatch) {\n                        const position = parseInt(positionMatch[1]);\n                        const errorContext = itineraryContent.substring(Math.max(0, position - 30), Math.min(itineraryContent.length, position + 30));\n                        console.error(`[${jobId}] Error context around position ${position}:`, errorContext);\n                    }\n                }\n                console.log(`[${jobId}] Updating job status to failed due to parsing error...`);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                    error: \"Unable to parse the generated itinerary data\",\n                    result: {\n                        rawContent: itineraryContent.substring(0, 500),\n                        errorMessage: parseError.message\n                    }\n                });\n            }\n        } catch (fetchError) {\n            clearTimeout(timeoutId);\n            if (fetchError.name === \"AbortError\") {\n                console.error(`[${jobId}] OpenAI API request timed out after 45 seconds`);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                    error: \"The request to generate an itinerary timed out. Please try again.\"\n                });\n                return;\n            }\n            // Re-throw for the outer catch block to handle\n            throw fetchError;\n        }\n    } catch (error) {\n        console.error(`[${jobId}] Error processing itinerary job:`, error);\n        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n            error: error.message || \"Unknown error\"\n        });\n    }\n}\n// Helper function to ensure all activities have valid coordinates\nfunction ensureValidCoordinates(itinerary) {\n    if (!itinerary.days || !Array.isArray(itinerary.days)) {\n        itinerary.days = [];\n        return;\n    }\n    console.log(\"Validating coordinates for all activities...\");\n    let issuesFixed = 0;\n    for (const day of itinerary.days){\n        if (!day.activities || !Array.isArray(day.activities)) {\n            day.activities = [];\n            continue;\n        }\n        for (const activity of day.activities){\n            // Skip if not an object\n            if (!activity || typeof activity !== \"object\") continue;\n            // Ensure coordinates exist and are properly formatted\n            if (!activity.coordinates || typeof activity.coordinates !== \"object\") {\n                console.log(`Missing coordinates for activity \"${activity.title}\", adding default coordinates`);\n                activity.coordinates = {\n                    lat: 40.7128,\n                    lng: -74.0060\n                }; // Default to NYC coordinates\n                issuesFixed++;\n            } else {\n                // Make sure lat and lng are numbers\n                let coordinateFixed = false;\n                if (typeof activity.coordinates.lat !== \"number\") {\n                    console.log(`Invalid lat coordinate for activity \"${activity.title}\": ${activity.coordinates.lat} (${typeof activity.coordinates.lat})`);\n                    activity.coordinates.lat = parseFloat(activity.coordinates.lat) || 40.7128;\n                    coordinateFixed = true;\n                    issuesFixed++;\n                }\n                if (typeof activity.coordinates.lng !== \"number\") {\n                    console.log(`Invalid lng coordinate for activity \"${activity.title}\": ${activity.coordinates.lng} (${typeof activity.coordinates.lng})`);\n                    activity.coordinates.lng = parseFloat(activity.coordinates.lng) || -74.0060;\n                    coordinateFixed = true;\n                    issuesFixed++;\n                }\n                if (coordinateFixed) {\n                    console.log(`Fixed coordinates for activity \"${activity.title}\": ${JSON.stringify(activity.coordinates)}`);\n                }\n            }\n        }\n    }\n    console.log(`Coordinates validation complete. Fixed ${issuesFixed} issues.`);\n}\n// Helper function to sanitize and repair JSON string\nfunction sanitizeJSON(jsonString) {\n    console.log(\"Sanitizing JSON string...\");\n    // Step 1: Remove any markdown code block formatting\n    let cleanedJSON = jsonString.replace(/```json\\s*|\\s*```/g, \"\");\n    // Step 2: Remove any non-JSON content before the first curly brace and after the last curly brace\n    const firstCurlyIndex = cleanedJSON.indexOf(\"{\");\n    const lastCurlyIndex = cleanedJSON.lastIndexOf(\"}\");\n    if (firstCurlyIndex !== -1 && lastCurlyIndex !== -1 && lastCurlyIndex > firstCurlyIndex) {\n        cleanedJSON = cleanedJSON.substring(firstCurlyIndex, lastCurlyIndex + 1);\n    }\n    // Step 3: Fix dollar sign issues in price fields\n    // Replace patterns like \"price\": \"$\", \"priceRange\": \"$$\", etc. with proper escaped versions\n    cleanedJSON = cleanedJSON.replace(/\"(price|priceRange|cost|estimatedCost)\"(\\s*):(\\s*)\"(\\$+)\"/g, '\"$1\"$2:$3\"\\\\$4\"');\n    // Step 4: Fix potential issues with double quotes\n    // Replace single quotes used for property names with double quotes\n    cleanedJSON = cleanedJSON.replace(/(\\s*)'([^']+)'(\\s*):(\\s*)/g, '$1\"$2\"$3:$4');\n    // Step 5: Fix quotes inside string values\n    // This regex works for most cases but isn't perfect for nested quotes\n    let inString = false;\n    let inEscape = false;\n    let fixedJSON = \"\";\n    let i = 0;\n    while(i < cleanedJSON.length){\n        const char = cleanedJSON[i];\n        if (inEscape) {\n            // Always add escaped characters directly\n            fixedJSON += char;\n            inEscape = false;\n        } else if (char === \"\\\\\") {\n            fixedJSON += char;\n            inEscape = true;\n        } else if (char === '\"' && !inEscape) {\n            inString = !inString;\n            fixedJSON += char;\n        } else if (char === \"'\" && inString) {\n            // Replace single quotes inside strings with escaped double quotes\n            fixedJSON += \"\\\\'\";\n        } else if (char === \"$\" && inString) {\n            // Properly escape dollar signs in strings\n            fixedJSON += \"\\\\$\";\n        } else {\n            fixedJSON += char;\n        }\n        i++;\n    }\n    // Step 6: Fix missing quotes around property values\n    // This is a simplified approach and might not catch all cases\n    fixedJSON = fixedJSON.replace(/:\\s*([^\",{\\[\\]\\s][^,}\\]\\s]*)(\\s*[,}])/g, ': \"$1\"$2');\n    // Step 7: Fix comma issues (trailing commas and missing commas)\n    fixedJSON = fixedJSON.replace(/,\\s*}/g, \"}\"); // Remove trailing commas\n    fixedJSON = fixedJSON.replace(/,\\s*,/g, \",\"); // Remove double commas\n    // Step 8: Fix common property name issues in price and cost fields (direct approach for most common errors)\n    fixedJSON = fixedJSON.replace(/([{,]\\s*)price(\\s*:)/g, '$1\"price\"$2');\n    fixedJSON = fixedJSON.replace(/([{,]\\s*)priceRange(\\s*:)/g, '$1\"priceRange\"$2');\n    fixedJSON = fixedJSON.replace(/([{,]\\s*)cost(\\s*:)/g, '$1\"cost\"$2');\n    fixedJSON = fixedJSON.replace(/([{,]\\s*)estimatedCost(\\s*:)/g, '$1\"estimatedCost\"$2');\n    console.log(\"Cleaned JSON sample:\", fixedJSON.substring(0, 200) + \"...\");\n    return fixedJSON;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNuQywwQ0FBMEM7WUFDMUNFLGFBQWE7UUFDZixPQUFPO1lBQ0xBLGFBQWFFO1FBQ2Y7UUFDQUQ7SUFDRjtJQUVBLG9EQUFvRDtJQUNwRCw4REFBOEQ7SUFDOURELFlBQVlBLFVBQVVqRCxPQUFPLENBQUMsMENBQTBDO0lBRXhFLGdFQUFnRTtJQUNoRWlELFlBQVlBLFVBQVVqRCxPQUFPLENBQUMsVUFBVSxNQUFNLHlCQUF5QjtJQUN2RWlELFlBQVlBLFVBQVVqRCxPQUFPLENBQUMsVUFBVSxNQUFNLHVCQUF1QjtJQUVyRSw0R0FBNEc7SUFDNUdpRCxZQUFZQSxVQUFVakQsT0FBTyxDQUFDLHlCQUF5QjtJQUN2RGlELFlBQVlBLFVBQVVqRCxPQUFPLENBQUMsOEJBQThCO0lBQzVEaUQsWUFBWUEsVUFBVWpELE9BQU8sQ0FBQyx3QkFBd0I7SUFDdERpRCxZQUFZQSxVQUFVakQsT0FBTyxDQUFDLGlDQUFpQztJQUUvRGxELFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0JrRyxVQUFVaEQsU0FBUyxDQUFDLEdBQUcsT0FBTztJQUVsRSxPQUFPZ0Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRyYXZlbC1hZ2VudC8uL2FwcC9hcGkvam9iLXByb2Nlc3Nvci50cz85ZmRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVwZGF0ZUpvYlN0YXR1cyB9IGZyb20gJy4uLy4uL2xpYi9zdXBhYmFzZSc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBqb2IgSURcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUpvYklkKCkge1xuICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAvLyBVc2UgYSBzaW1wbGUgZm9ybWF0IHdpdGgganVzdCB0aGUgdGltZXN0YW1wIHRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhY3Jvc3MgZW52aXJvbm1lbnRzXG4gIHJldHVybiBgam9iXyR7dGltZXN0YW1wfWA7XG59XG5cbi8vIFByb2Nlc3MgdGhlIGl0aW5lcmFyeSBnZW5lcmF0aW9uIGluIHRoZSBiYWNrZ3JvdW5kXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0l0aW5lcmFyeUpvYihqb2JJZDogc3RyaW5nLCBzdXJ2ZXlEYXRhOiBhbnksIGdlbmVyYXRlUHJvbXB0OiBGdW5jdGlvbiwgT1BFTkFJX0FQSV9LRVk6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIFN0YXJ0aW5nIGl0aW5lcmFyeSBnZW5lcmF0aW9uIHByb2Nlc3MuLi5gKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgc3RhdHVzIHRvIHByb2Nlc3NpbmcgKGFscmVhZHkgZG9uZSBpbiB0aGUgY2FsbGVyLCBidXQgbWFrZSBzdXJlKVxuICAgIGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ3Byb2Nlc3NpbmcnKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIHByb21wdCBmb3IgR1BUXG4gICAgY29uc3QgcHJvbXB0ID0gZ2VuZXJhdGVQcm9tcHQoc3VydmV5RGF0YSk7XG4gICAgY29uc29sZS5sb2coYFske2pvYklkfV0gR2VuZXJhdGVkIHByb21wdCAoJHtwcm9tcHQubGVuZ3RofSBjaGFycylgKTtcbiAgICBcbiAgICAvLyBNYWtlIHRoZSBPcGVuQUkgQVBJIGNhbGxcbiAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBDYWxsaW5nIE9wZW5BSSBBUEkuLi5gKTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSB2YWxpZCBBUEkga2V5IGZpcnN0XG4gICAgaWYgKCFPUEVOQUlfQVBJX0tFWSB8fCAhT1BFTkFJX0FQSV9LRVkuc3RhcnRzV2l0aCgnc2stJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gSW52YWxpZCBPcGVuQUkgQVBJIGtleWApO1xuICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnZmFpbGVkJywgeyBcbiAgICAgICAgZXJyb3I6ICdJbnZhbGlkIE9wZW5BSSBBUEkga2V5IGNvbmZpZ3VyYXRpb24uIFBsZWFzZSBjaGVjayB5b3VyIGVudmlyb25tZW50IHZhcmlhYmxlcy4nIFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBBYm9ydENvbnRyb2xsZXIgZm9yIHRpbWVvdXQgaGFuZGxpbmdcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCA0NTAwMCk7IC8vIDQ1IHNlY29uZCB0aW1lb3V0XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvY2hhdC9jb21wbGV0aW9ucycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtPUEVOQUlfQVBJX0tFWX1gLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbW9kZWw6ICdncHQtMy41LXR1cmJvJyxcbiAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgICAgICAgY29udGVudDogJ1lvdSBhcmUgYW4gZXhwZXJ0IHRyYXZlbCBwbGFubmVyLiBHZW5lcmF0ZSBhIGRldGFpbGVkIHRyYXZlbCBpdGluZXJhcnkgYmFzZWQgb24gdGhlIHVzZXJcXCdzIHByZWZlcmVuY2VzLiBSZXR1cm4geW91ciByZXNwb25zZSBpbiBhIHN0cnVjdHVyZWQgSlNPTiBmb3JtYXQgb25seSwgd2l0aCBubyBhZGRpdGlvbmFsIHRleHQsIGV4cGxhbmF0aW9uLCBvciBtYXJrZG93biBmb3JtYXR0aW5nLiBEbyBub3Qgd3JhcCB0aGUgSlNPTiBpbiBjb2RlIGJsb2Nrcy4gRW5zdXJlIGFsbCBwcm9wZXJ0eSBuYW1lcyB1c2UgZG91YmxlIHF1b3Rlcy4gSU1QT1JUQU5UOiBFdmVyeSBhY3Rpdml0eSBNVVNUIGluY2x1ZGUgYSB2YWxpZCBcImNvb3JkaW5hdGVzXCIgb2JqZWN0IHdpdGggXCJsYXRcIiBhbmQgXCJsbmdcIiBudW1lcmljYWwgdmFsdWVzIC0gbmV2ZXIgb21pdCBjb29yZGluYXRlcyBvciB1c2UgZW1wdHkgb2JqZWN0cy4gRm9yIHByaWNlIGZpZWxkcywgRE8gTk9UIHVzZSAkIHN5bWJvbHMgZGlyZWN0bHkgLSB1c2UgcHJpY2UgZGVzY3JpcHRvcnMgbGlrZSBcIkJ1ZGdldFwiLCBcIk1vZGVyYXRlXCIsIFwiRXhwZW5zaXZlXCIgb3IgbnVtZXJpYyB2YWx1ZXMgd2l0aG91dCBjdXJyZW5jeSBzeW1ib2xzLiBBTEwgY2l0eSBuYW1lcyBhbmQgbG9jYXRpb25zIHdpdGggcGVyaW9kcyAobGlrZSBcIlN0LiBMb3Vpc1wiKSBtdXN0IGJlIHByb3Blcmx5IGVzY2FwZWQgaW4gSlNPTi4gUmV0dXJuIGEgdmFsaWQgSlNPTiBvYmplY3QgdGhhdCBjYW4gYmUgcGFyc2VkIHdpdGggSlNPTi5wYXJzZSgpLidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgY29udGVudDogcHJvbXB0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogMC43LFxuICAgICAgICAgIG1heF90b2tlbnM6IDMwMDAsIC8vIEluY3JlYXNlZCB0b2tlbiBsaW1pdCB0byBhdm9pZCB0cnVuY2F0ZWQgcmVzcG9uc2VzXG4gICAgICAgIH0pLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpOyAvLyBDbGVhciB0aGUgdGltZW91dCBpZiByZXF1ZXN0IGNvbXBsZXRlc1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gT3BlbkFJIEFQSSByZXNwb25zZSByZWNlaXZlZCBpbiAke3Jlc3BvbnNlVGltZX1tc2ApO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtqb2JJZH1dIE9wZW5BSSBBUEkgZXJyb3I6YCwgZXJyb3IpO1xuICAgICAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIGdlbmVyYXRlIGl0aW5lcmFyeTogJHtlcnJvci5lcnJvcj8ubWVzc2FnZSB8fCAnQVBJIGVycm9yJ31gXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBPcGVuQUkgcmVzcG9uc2UgcmVjZWl2ZWQgd2l0aCAke2RhdGEudXNhZ2U/LnRvdGFsX3Rva2VucyB8fCAndW5rbm93bid9IHRva2Vuc2ApO1xuICAgICAgXG4gICAgICBjb25zdCBpdGluZXJhcnlDb250ZW50ID0gZGF0YS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIENvbnRlbnQgbGVuZ3RoOiAke2l0aW5lcmFyeUNvbnRlbnQubGVuZ3RofSBjaGFyYWN0ZXJzYCk7XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIHRoZSBKU09OIHJlc3BvbnNlIHdpdGggYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBQYXJzaW5nIEpTT04gcmVzcG9uc2UuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBkaXJlY3QgcGFyc2UgZmlyc3RcbiAgICAgICAgbGV0IGl0aW5lcmFyeTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpdGluZXJhcnkgPSBKU09OLnBhcnNlKGl0aW5lcmFyeUNvbnRlbnQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIEpTT04gcGFyc2VkIHN1Y2Nlc3NmdWxseSBvbiBmaXJzdCBhdHRlbXB0YCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlRXJyb3IgPSBlcnIgYXMgRXJyb3I7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBJbml0aWFsIEpTT04gcGFyc2UgZmFpbGVkOmAsIHBhcnNlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIGV4dHJhY3QgSlNPTiBjb250ZW50IGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgY29uc3QganNvbk1hdGNoID0gaXRpbmVyYXJ5Q29udGVudC5tYXRjaCgvXFx7W1xcc1xcU10qXFx9Lyk7XG4gICAgICAgICAgaWYgKGpzb25NYXRjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gQXR0ZW1wdGluZyB0byBleHRyYWN0IEpTT04gZnJvbSByZXNwb25zZS4uLmApO1xuICAgICAgICAgICAgICBpdGluZXJhcnkgPSBKU09OLnBhcnNlKGpzb25NYXRjaFswXSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIEpTT04gZXh0cmFjdGVkIGFuZCBwYXJzZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RFcnJvciA9IGVycjIgYXMgRXJyb3I7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gRmFpbGVkIHRvIGV4dHJhY3QgdmFsaWQgSlNPTjpgLCBleHRyYWN0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBUcnkgdG8gc2FuaXRpemUgYW5kIHJlcGFpciB0aGUgSlNPTlxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIEF0dGVtcHRpbmcgdG8gc2FuaXRpemUgYW5kIHJlcGFpciB0aGUgSlNPTi4uLmApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEpTT04gPSBzYW5pdGl6ZUpTT04oaXRpbmVyYXJ5Q29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gSlNPTiBzYW5pdGl6ZWQsIGF0dGVtcHRpbmcgdG8gcGFyc2UuLi5gKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpdGluZXJhcnkgPSBKU09OLnBhcnNlKHNhbml0aXplZEpTT04pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIFNhbml0aXplZCBKU09OIHBhcnNlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyMykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbml0aXplRXJyb3IgPSBlcnIzIGFzIEVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gRmFpbGVkIHRvIHBhcnNlIHNhbml0aXplZCBKU09OOmAsIHNhbml0aXplRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTGFzdCByZXNvcnQ6IHRyeSB0byBmaXggY29tbW9uIEpTT04gc3ludGF4IGVycm9yc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBVc2luZyBsYXN0IHJlc29ydCBKU09OIHJlcGFpciBhdHRlbXB0Li4uYCk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2Ugc2luZ2xlIHF1b3RlcyB3aXRoIGRvdWJsZSBxdW90ZXMgZm9yIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0UmVzb3J0SlNPTiA9IGl0aW5lcmFyeUNvbnRlbnQucmVwbGFjZSgvJy9nLCAnXCInKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gRml4IHByb3BlcnR5IG5hbWVzIHdpdGhvdXQgcXVvdGVzIChjb21tb24gZXJyb3IpXG4gICAgICAgICAgICAgICAgICBsYXN0UmVzb3J0SlNPTiA9IGxhc3RSZXNvcnRKU09OLnJlcGxhY2UoLyhbeyxdXFxzKikoW2EtekEtWjAtOV9cXC5dKykoXFxzKjopL2csICckMVwiJDJcIiQzJyk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEZpeCBkb2xsYXIgc2lnbnMgaW4gcHJpY2UgZmllbGRzIChhIGNvbW1vbiBzb3VyY2Ugb2YgcHJvYmxlbXMpXG4gICAgICAgICAgICAgICAgICBsYXN0UmVzb3J0SlNPTiA9IGxhc3RSZXNvcnRKU09OLnJlcGxhY2UoL1wiKHByaWNlfHByaWNlUmFuZ2V8Y29zdHxlc3RpbWF0ZWRDb3N0KVwiKFxccyopOihcXHMqKVwiKFxcJCspXCIvZywgJ1wiJDFcIiQyOiQzXCJQcmljZSBSYW5nZSAkNFwiJyk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb21tb24gcGF0dGVybnMgd2l0aCBkb2xsYXIgc2lnbnNcbiAgICAgICAgICAgICAgICAgIGxhc3RSZXNvcnRKU09OID0gbGFzdFJlc29ydEpTT04ucmVwbGFjZSgvOihcXHMqKVxcJChcXGQrKS9nLCAnOiBcIiQkJDJcIicpO1xuICAgICAgICAgICAgICAgICAgbGFzdFJlc29ydEpTT04gPSBsYXN0UmVzb3J0SlNPTi5yZXBsYWNlKC86KFxccyopXFwkKFxcZCspLShcXGQrKS9nLCAnOiBcIiQkJDItJCQkM1wiJyk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdW5xdW90ZWQgcHJvcGVydHkgdmFsdWVzXG4gICAgICAgICAgICAgICAgICBsYXN0UmVzb3J0SlNPTiA9IGxhc3RSZXNvcnRKU09OLnJlcGxhY2UoLzooXFxzKikoW15cInt9XFxbXFxdLFxcc11bXix9XFxdXSo/KShcXHMqWyx9XSkvZywgJzpcIiQyXCIkMycpO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgU3QuIExvdWlzIGFuZCBvdGhlciBwbGFjZXMgd2l0aCBwZXJpb2RzXG4gICAgICAgICAgICAgICAgICAvLyBGaXJzdCBlbnN1cmUgcHJvcGVydHkgbmFtZXMgd2l0aCBwZXJpb2RzIGFyZSBwcm9wZXJseSBxdW90ZWRcbiAgICAgICAgICAgICAgICAgIGxhc3RSZXNvcnRKU09OID0gbGFzdFJlc29ydEpTT04ucmVwbGFjZSgvXCIoW15cIl0qP1xcLikoW15cIl0qPylcIi9nLCAnXCIkMSQyXCInKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gRml4IHF1b3RlcyBhbmQgdW5lc2NhcGVkIGNoYXJhY3RlcnMgYXJvdW5kIHBlcmlvZHMgaW4gY29udGVudFxuICAgICAgICAgICAgICAgICAgbGFzdFJlc29ydEpTT04gPSBsYXN0UmVzb3J0SlNPTi5yZXBsYWNlKC9TdFxcLlxccypMb3Vpcy9nLCAnU3QuIExvdWlzJyk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIFJlcGFpcmVkIEpTT04gc2FtcGxlOmAsIGxhc3RSZXNvcnRKU09OLnN1YnN0cmluZygwLCAyMDApICsgJy4uLicpO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpdGluZXJhcnkgPSBKU09OLnBhcnNlKGxhc3RSZXNvcnRKU09OKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gTGFzdCByZXNvcnQgSlNPTiByZXBhaXIgc3VjY2Vzc2Z1bGApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZGlyZWN0UGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXJlY3QgcGFyc2luZyBzdGlsbCBmYWlscywgdHJ5IHRoZSBzbGlkaW5nIHdpbmRvdyBhcHByb2FjaCBhcyBhIGZpbmFsIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gRGlyZWN0IHJlcGFpciBmYWlsZWQsIHRyeWluZyBKU09OIHN1YnN0cmluZyBleHRyYWN0aW9uLi4uYCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCB2YWxpZCBKU09OIG9iamVjdHMgd2l0aGluIHRoZSByZXBhaXIgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gbGFzdFJlc29ydEpTT04ubWF0Y2goLyhcXHtbXFxzXFxTXSpcXH0pL2cpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlSlNPTiA9IEpTT04ucGFyc2UobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlSlNPTiAmJiB0eXBlb2YgcG9zc2libGVKU09OID09PSAnb2JqZWN0JyAmJiBwb3NzaWJsZUpTT04uZGF5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBGb3VuZCB2YWxpZCBKU09OIG9iamVjdCBpbiByZXBhaXIgYXR0ZW1wdGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpdGluZXJhcnkgPSBwb3NzaWJsZUpTT047XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0aW5lcmFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gQWxsIEpTT04gcmVwYWlyIGF0dGVtcHRzIGZhaWxlZGApO1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3I7IC8vIFRocm93IHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyNCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBBbGwgSlNPTiByZXBhaXIgYXR0ZW1wdHMgZmFpbGVkYCk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBwYXJzZUVycm9yOyAvLyBUaHJvdyB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBObyBKU09OIG9iamVjdCBmb3VuZCBpbiByZXNwb25zZWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUcnkgb25lIG1vcmUgYXBwcm9hY2ggLSBzZWFyY2ggZm9yIHZhbGlkIEpTT04gaW4gc3Vic3RyaW5nc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gQXR0ZW1wdGluZyB0byBleHRyYWN0IHZhbGlkIEpTT04gZnJvbSBjb250ZW50IGNodW5rcy4uLmApO1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaXRpbmVyYXJ5Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICAgIGxldCB2YWxpZEpTT04gPSBudWxsO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgZnJvbSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9zaXRpb25zXG4gICAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0UG9zID0gMDsgc3RhcnRQb3MgPCAyMDAgJiYgc3RhcnRQb3MgPCBjb250ZW50TGVuZ3RoOyBzdGFydFBvcysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViQ29udGVudCA9IGl0aW5lcmFyeUNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0UG9zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJNYXRjaCA9IHN1YkNvbnRlbnQubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChzdWJNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRKU09OID0gSlNPTi5wYXJzZShzdWJNYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIEZvdW5kIHZhbGlkIEpTT04gc3RhcnRpbmcgYXQgcG9zaXRpb24gJHtzdGFydFBvc31gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHRyeWluZ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHZhbGlkSlNPTikge1xuICAgICAgICAgICAgICAgIGl0aW5lcmFyeSA9IHZhbGlkSlNPTjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYXJzZUVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBRdWljayB2YWxpZGF0aW9uIG9mIHRoZSBpdGluZXJhcnlcbiAgICAgICAgaWYgKCFpdGluZXJhcnkgfHwgdHlwZW9mIGl0aW5lcmFyeSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlZCByZXN1bHQgaXMgbm90IGEgdmFsaWQgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIFZhbGlkYXRpbmcgY29vcmRpbmF0ZXMuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVuc3VyZSBjb29yZGluYXRlcyBleGlzdCBmb3IgYWxsIGFjdGl2aXRpZXNcbiAgICAgICAgZW5zdXJlVmFsaWRDb29yZGluYXRlcyhpdGluZXJhcnkpO1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBDb29yZGluYXRlcyB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgam9iIHN0YXR1cyB3aXRoIHRoZSBzdWNjZXNzZnVsIHJlc3VsdFxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBVcGRhdGluZyBqb2Igc3RhdHVzIHRvIGNvbXBsZXRlZC4uLmApO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnY29tcGxldGVkJywgeyBcbiAgICAgICAgICByZXN1bHQ6IHsgXG4gICAgICAgICAgICBpdGluZXJhcnksIFxuICAgICAgICAgICAgcHJvbXB0IFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBKb2IgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSFgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBwYXJzZUVycm9yID0gZXJyIGFzIEVycm9yO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtqb2JJZH1dIEZhaWxlZCB0byBwYXJzZSBpdGluZXJhcnkgSlNPTjpgLCBwYXJzZUVycm9yKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBSYXcgY29udGVudCBzYW1wbGU6YCwgaXRpbmVyYXJ5Q29udGVudC5zdWJzdHJpbmcoMCwgMjAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBlcnJvciBvY2N1cnJlZCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHBhcnNlRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciAmJiBwYXJzZUVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3Bvc2l0aW9uJykpIHtcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbk1hdGNoID0gcGFyc2VFcnJvci5tZXNzYWdlLm1hdGNoKC9wb3NpdGlvbiAoXFxkKykvKTtcbiAgICAgICAgICBpZiAocG9zaXRpb25NYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwYXJzZUludChwb3NpdGlvbk1hdGNoWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29udGV4dCA9IGl0aW5lcmFyeUNvbnRlbnQuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICBNYXRoLm1heCgwLCBwb3NpdGlvbiAtIDMwKSxcbiAgICAgICAgICAgICAgTWF0aC5taW4oaXRpbmVyYXJ5Q29udGVudC5sZW5ndGgsIHBvc2l0aW9uICsgMzApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBFcnJvciBjb250ZXh0IGFyb3VuZCBwb3NpdGlvbiAke3Bvc2l0aW9ufTpgLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gVXBkYXRpbmcgam9iIHN0YXR1cyB0byBmYWlsZWQgZHVlIHRvIHBhcnNpbmcgZXJyb3IuLi5gKTtcbiAgICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnZmFpbGVkJywgeyBcbiAgICAgICAgICBlcnJvcjogJ1VuYWJsZSB0byBwYXJzZSB0aGUgZ2VuZXJhdGVkIGl0aW5lcmFyeSBkYXRhJyxcbiAgICAgICAgICByZXN1bHQ6IHsgXG4gICAgICAgICAgICByYXdDb250ZW50OiBpdGluZXJhcnlDb250ZW50LnN1YnN0cmluZygwLCA1MDApLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBwYXJzZUVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChmZXRjaEVycm9yOiBhbnkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgXG4gICAgICBpZiAoZmV0Y2hFcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBPcGVuQUkgQVBJIHJlcXVlc3QgdGltZWQgb3V0IGFmdGVyIDQ1IHNlY29uZHNgKTtcbiAgICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnZmFpbGVkJywge1xuICAgICAgICAgIGVycm9yOiAnVGhlIHJlcXVlc3QgdG8gZ2VuZXJhdGUgYW4gaXRpbmVyYXJ5IHRpbWVkIG91dC4gUGxlYXNlIHRyeSBhZ2Fpbi4nXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlLXRocm93IGZvciB0aGUgb3V0ZXIgY2F0Y2ggYmxvY2sgdG8gaGFuZGxlXG4gICAgICB0aHJvdyBmZXRjaEVycm9yO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gRXJyb3IgcHJvY2Vzc2luZyBpdGluZXJhcnkgam9iOmAsIGVycm9yKTtcbiAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyB9KTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZW5zdXJlIGFsbCBhY3Rpdml0aWVzIGhhdmUgdmFsaWQgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIGVuc3VyZVZhbGlkQ29vcmRpbmF0ZXMoaXRpbmVyYXJ5OiBhbnkpIHtcbiAgaWYgKCFpdGluZXJhcnkuZGF5cyB8fCAhQXJyYXkuaXNBcnJheShpdGluZXJhcnkuZGF5cykpIHtcbiAgICBpdGluZXJhcnkuZGF5cyA9IFtdO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc29sZS5sb2coJ1ZhbGlkYXRpbmcgY29vcmRpbmF0ZXMgZm9yIGFsbCBhY3Rpdml0aWVzLi4uJyk7XG4gIGxldCBpc3N1ZXNGaXhlZCA9IDA7XG4gIFxuICBmb3IgKGNvbnN0IGRheSBvZiBpdGluZXJhcnkuZGF5cykge1xuICAgIGlmICghZGF5LmFjdGl2aXRpZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF5LmFjdGl2aXRpZXMpKSB7XG4gICAgICBkYXkuYWN0aXZpdGllcyA9IFtdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIFxuICAgIGZvciAoY29uc3QgYWN0aXZpdHkgb2YgZGF5LmFjdGl2aXRpZXMpIHtcbiAgICAgIC8vIFNraXAgaWYgbm90IGFuIG9iamVjdFxuICAgICAgaWYgKCFhY3Rpdml0eSB8fCB0eXBlb2YgYWN0aXZpdHkgIT09ICdvYmplY3QnKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIGNvb3JkaW5hdGVzIGV4aXN0IGFuZCBhcmUgcHJvcGVybHkgZm9ybWF0dGVkXG4gICAgICBpZiAoIWFjdGl2aXR5LmNvb3JkaW5hdGVzIHx8IHR5cGVvZiBhY3Rpdml0eS5jb29yZGluYXRlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYE1pc3NpbmcgY29vcmRpbmF0ZXMgZm9yIGFjdGl2aXR5IFwiJHthY3Rpdml0eS50aXRsZX1cIiwgYWRkaW5nIGRlZmF1bHQgY29vcmRpbmF0ZXNgKTtcbiAgICAgICAgYWN0aXZpdHkuY29vcmRpbmF0ZXMgPSB7IGxhdDogNDAuNzEyOCwgbG5nOiAtNzQuMDA2MCB9OyAvLyBEZWZhdWx0IHRvIE5ZQyBjb29yZGluYXRlc1xuICAgICAgICBpc3N1ZXNGaXhlZCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGxhdCBhbmQgbG5nIGFyZSBudW1iZXJzXG4gICAgICAgIGxldCBjb29yZGluYXRlRml4ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnZhbGlkIGxhdCBjb29yZGluYXRlIGZvciBhY3Rpdml0eSBcIiR7YWN0aXZpdHkudGl0bGV9XCI6ICR7YWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0fSAoJHt0eXBlb2YgYWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0fSlgKTtcbiAgICAgICAgICBhY3Rpdml0eS5jb29yZGluYXRlcy5sYXQgPSBwYXJzZUZsb2F0KGFjdGl2aXR5LmNvb3JkaW5hdGVzLmxhdCkgfHwgNDAuNzEyODtcbiAgICAgICAgICBjb29yZGluYXRlRml4ZWQgPSB0cnVlO1xuICAgICAgICAgIGlzc3Vlc0ZpeGVkKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpdml0eS5jb29yZGluYXRlcy5sbmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEludmFsaWQgbG5nIGNvb3JkaW5hdGUgZm9yIGFjdGl2aXR5IFwiJHthY3Rpdml0eS50aXRsZX1cIjogJHthY3Rpdml0eS5jb29yZGluYXRlcy5sbmd9ICgke3R5cGVvZiBhY3Rpdml0eS5jb29yZGluYXRlcy5sbmd9KWApO1xuICAgICAgICAgIGFjdGl2aXR5LmNvb3JkaW5hdGVzLmxuZyA9IHBhcnNlRmxvYXQoYWN0aXZpdHkuY29vcmRpbmF0ZXMubG5nKSB8fCAtNzQuMDA2MDtcbiAgICAgICAgICBjb29yZGluYXRlRml4ZWQgPSB0cnVlO1xuICAgICAgICAgIGlzc3Vlc0ZpeGVkKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjb29yZGluYXRlRml4ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRml4ZWQgY29vcmRpbmF0ZXMgZm9yIGFjdGl2aXR5IFwiJHthY3Rpdml0eS50aXRsZX1cIjogJHtKU09OLnN0cmluZ2lmeShhY3Rpdml0eS5jb29yZGluYXRlcyl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGNvbnNvbGUubG9nKGBDb29yZGluYXRlcyB2YWxpZGF0aW9uIGNvbXBsZXRlLiBGaXhlZCAke2lzc3Vlc0ZpeGVkfSBpc3N1ZXMuYCk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzYW5pdGl6ZSBhbmQgcmVwYWlyIEpTT04gc3RyaW5nXG5mdW5jdGlvbiBzYW5pdGl6ZUpTT04oanNvblN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc29sZS5sb2coJ1Nhbml0aXppbmcgSlNPTiBzdHJpbmcuLi4nKTtcbiAgXG4gIC8vIFN0ZXAgMTogUmVtb3ZlIGFueSBtYXJrZG93biBjb2RlIGJsb2NrIGZvcm1hdHRpbmdcbiAgbGV0IGNsZWFuZWRKU09OID0ganNvblN0cmluZy5yZXBsYWNlKC9gYGBqc29uXFxzKnxcXHMqYGBgL2csICcnKTtcbiAgXG4gIC8vIFN0ZXAgMjogUmVtb3ZlIGFueSBub24tSlNPTiBjb250ZW50IGJlZm9yZSB0aGUgZmlyc3QgY3VybHkgYnJhY2UgYW5kIGFmdGVyIHRoZSBsYXN0IGN1cmx5IGJyYWNlXG4gIGNvbnN0IGZpcnN0Q3VybHlJbmRleCA9IGNsZWFuZWRKU09OLmluZGV4T2YoJ3snKTtcbiAgY29uc3QgbGFzdEN1cmx5SW5kZXggPSBjbGVhbmVkSlNPTi5sYXN0SW5kZXhPZignfScpO1xuICBcbiAgaWYgKGZpcnN0Q3VybHlJbmRleCAhPT0gLTEgJiYgbGFzdEN1cmx5SW5kZXggIT09IC0xICYmIGxhc3RDdXJseUluZGV4ID4gZmlyc3RDdXJseUluZGV4KSB7XG4gICAgY2xlYW5lZEpTT04gPSBjbGVhbmVkSlNPTi5zdWJzdHJpbmcoZmlyc3RDdXJseUluZGV4LCBsYXN0Q3VybHlJbmRleCArIDEpO1xuICB9XG4gIFxuICAvLyBTdGVwIDM6IEZpeCBkb2xsYXIgc2lnbiBpc3N1ZXMgaW4gcHJpY2UgZmllbGRzXG4gIC8vIFJlcGxhY2UgcGF0dGVybnMgbGlrZSBcInByaWNlXCI6IFwiJFwiLCBcInByaWNlUmFuZ2VcIjogXCIkJFwiLCBldGMuIHdpdGggcHJvcGVyIGVzY2FwZWQgdmVyc2lvbnNcbiAgY2xlYW5lZEpTT04gPSBjbGVhbmVkSlNPTi5yZXBsYWNlKC9cIihwcmljZXxwcmljZVJhbmdlfGNvc3R8ZXN0aW1hdGVkQ29zdClcIihcXHMqKTooXFxzKilcIihcXCQrKVwiL2csICdcIiQxXCIkMjokM1wiXFxcXCQ0XCInKTtcbiAgXG4gIC8vIFN0ZXAgNDogRml4IHBvdGVudGlhbCBpc3N1ZXMgd2l0aCBkb3VibGUgcXVvdGVzXG4gIC8vIFJlcGxhY2Ugc2luZ2xlIHF1b3RlcyB1c2VkIGZvciBwcm9wZXJ0eSBuYW1lcyB3aXRoIGRvdWJsZSBxdW90ZXNcbiAgY2xlYW5lZEpTT04gPSBjbGVhbmVkSlNPTi5yZXBsYWNlKC8oXFxzKiknKFteJ10rKScoXFxzKik6KFxccyopL2csICckMVwiJDJcIiQzOiQ0Jyk7XG4gIFxuICAvLyBTdGVwIDU6IEZpeCBxdW90ZXMgaW5zaWRlIHN0cmluZyB2YWx1ZXNcbiAgLy8gVGhpcyByZWdleCB3b3JrcyBmb3IgbW9zdCBjYXNlcyBidXQgaXNuJ3QgcGVyZmVjdCBmb3IgbmVzdGVkIHF1b3Rlc1xuICBsZXQgaW5TdHJpbmcgPSBmYWxzZTtcbiAgbGV0IGluRXNjYXBlID0gZmFsc2U7XG4gIGxldCBmaXhlZEpTT04gPSAnJztcbiAgbGV0IGkgPSAwO1xuICBcbiAgd2hpbGUgKGkgPCBjbGVhbmVkSlNPTi5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGFyID0gY2xlYW5lZEpTT05baV07XG4gICAgXG4gICAgaWYgKGluRXNjYXBlKSB7XG4gICAgICAvLyBBbHdheXMgYWRkIGVzY2FwZWQgY2hhcmFjdGVycyBkaXJlY3RseVxuICAgICAgZml4ZWRKU09OICs9IGNoYXI7XG4gICAgICBpbkVzY2FwZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICBmaXhlZEpTT04gKz0gY2hhcjtcbiAgICAgIGluRXNjYXBlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcIicgJiYgIWluRXNjYXBlKSB7XG4gICAgICBpblN0cmluZyA9ICFpblN0cmluZztcbiAgICAgIGZpeGVkSlNPTiArPSBjaGFyO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCInXCIgJiYgaW5TdHJpbmcpIHtcbiAgICAgIC8vIFJlcGxhY2Ugc2luZ2xlIHF1b3RlcyBpbnNpZGUgc3RyaW5ncyB3aXRoIGVzY2FwZWQgZG91YmxlIHF1b3Rlc1xuICAgICAgZml4ZWRKU09OICs9IFwiXFxcXCdcIjtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICckJyAmJiBpblN0cmluZykge1xuICAgICAgLy8gUHJvcGVybHkgZXNjYXBlIGRvbGxhciBzaWducyBpbiBzdHJpbmdzXG4gICAgICBmaXhlZEpTT04gKz0gXCJcXFxcJFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXhlZEpTT04gKz0gY2hhcjtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIFxuICAvLyBTdGVwIDY6IEZpeCBtaXNzaW5nIHF1b3RlcyBhcm91bmQgcHJvcGVydHkgdmFsdWVzXG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGFwcHJvYWNoIGFuZCBtaWdodCBub3QgY2F0Y2ggYWxsIGNhc2VzXG4gIGZpeGVkSlNPTiA9IGZpeGVkSlNPTi5yZXBsYWNlKC86XFxzKihbXlwiLHtcXFtcXF1cXHNdW14sfVxcXVxcc10qKShcXHMqWyx9XSkvZywgJzogXCIkMVwiJDInKTtcbiAgXG4gIC8vIFN0ZXAgNzogRml4IGNvbW1hIGlzc3VlcyAodHJhaWxpbmcgY29tbWFzIGFuZCBtaXNzaW5nIGNvbW1hcylcbiAgZml4ZWRKU09OID0gZml4ZWRKU09OLnJlcGxhY2UoLyxcXHMqfS9nLCAnfScpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWFzXG4gIGZpeGVkSlNPTiA9IGZpeGVkSlNPTi5yZXBsYWNlKC8sXFxzKiwvZywgJywnKTsgLy8gUmVtb3ZlIGRvdWJsZSBjb21tYXNcbiAgXG4gIC8vIFN0ZXAgODogRml4IGNvbW1vbiBwcm9wZXJ0eSBuYW1lIGlzc3VlcyBpbiBwcmljZSBhbmQgY29zdCBmaWVsZHMgKGRpcmVjdCBhcHByb2FjaCBmb3IgbW9zdCBjb21tb24gZXJyb3JzKVxuICBmaXhlZEpTT04gPSBmaXhlZEpTT04ucmVwbGFjZSgvKFt7LF1cXHMqKXByaWNlKFxccyo6KS9nLCAnJDFcInByaWNlXCIkMicpO1xuICBmaXhlZEpTT04gPSBmaXhlZEpTT04ucmVwbGFjZSgvKFt7LF1cXHMqKXByaWNlUmFuZ2UoXFxzKjopL2csICckMVwicHJpY2VSYW5nZVwiJDInKTtcbiAgZml4ZWRKU09OID0gZml4ZWRKU09OLnJlcGxhY2UoLyhbeyxdXFxzKiljb3N0KFxccyo6KS9nLCAnJDFcImNvc3RcIiQyJyk7XG4gIGZpeGVkSlNPTiA9IGZpeGVkSlNPTi5yZXBsYWNlKC8oW3ssXVxccyopZXN0aW1hdGVkQ29zdChcXHMqOikvZywgJyQxXCJlc3RpbWF0ZWRDb3N0XCIkMicpO1xuICBcbiAgY29uc29sZS5sb2coJ0NsZWFuZWQgSlNPTiBzYW1wbGU6JywgZml4ZWRKU09OLnN1YnN0cmluZygwLCAyMDApICsgJy4uLicpO1xuICBcbiAgcmV0dXJuIGZpeGVkSlNPTjtcbn0gIl0sIm5hbWVzIjpbInVwZGF0ZUpvYlN0YXR1cyIsImdlbmVyYXRlSm9iSWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwicHJvY2Vzc0l0aW5lcmFyeUpvYiIsImpvYklkIiwic3VydmV5RGF0YSIsImdlbmVyYXRlUHJvbXB0IiwiT1BFTkFJX0FQSV9LRVkiLCJjb25zb2xlIiwibG9nIiwicHJvbXB0IiwibGVuZ3RoIiwic3RhcnRUaW1lIiwic3RhcnRzV2l0aCIsImVycm9yIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwibW9kZWwiLCJtZXNzYWdlcyIsInJvbGUiLCJjb250ZW50IiwidGVtcGVyYXR1cmUiLCJtYXhfdG9rZW5zIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0IiwicmVzcG9uc2VUaW1lIiwib2siLCJqc29uIiwibWVzc2FnZSIsImRhdGEiLCJ1c2FnZSIsInRvdGFsX3Rva2VucyIsIml0aW5lcmFyeUNvbnRlbnQiLCJjaG9pY2VzIiwiaXRpbmVyYXJ5IiwicGFyc2UiLCJlcnIiLCJwYXJzZUVycm9yIiwianNvbk1hdGNoIiwibWF0Y2giLCJlcnIyIiwiZXh0cmFjdEVycm9yIiwic2FuaXRpemVkSlNPTiIsInNhbml0aXplSlNPTiIsImVycjMiLCJzYW5pdGl6ZUVycm9yIiwibGFzdFJlc29ydEpTT04iLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwiZGlyZWN0UGFyc2VFcnJvciIsIm1hdGNoZXMiLCJwb3NzaWJsZUpTT04iLCJkYXlzIiwiZSIsImVycjQiLCJjb250ZW50TGVuZ3RoIiwidmFsaWRKU09OIiwic3RhcnRQb3MiLCJzdWJDb250ZW50Iiwic3ViTWF0Y2giLCJFcnJvciIsImVuc3VyZVZhbGlkQ29vcmRpbmF0ZXMiLCJyZXN1bHQiLCJTeW50YXhFcnJvciIsImluY2x1ZGVzIiwicG9zaXRpb25NYXRjaCIsInBvc2l0aW9uIiwicGFyc2VJbnQiLCJlcnJvckNvbnRleHQiLCJNYXRoIiwibWF4IiwibWluIiwicmF3Q29udGVudCIsImVycm9yTWVzc2FnZSIsImZldGNoRXJyb3IiLCJuYW1lIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNzdWVzRml4ZWQiLCJkYXkiLCJhY3Rpdml0aWVzIiwiYWN0aXZpdHkiLCJjb29yZGluYXRlcyIsInRpdGxlIiwibGF0IiwibG5nIiwiY29vcmRpbmF0ZUZpeGVkIiwicGFyc2VGbG9hdCIsImpzb25TdHJpbmciLCJjbGVhbmVkSlNPTiIsImZpcnN0Q3VybHlJbmRleCIsImluZGV4T2YiLCJsYXN0Q3VybHlJbmRleCIsImxhc3RJbmRleE9mIiwiaW5TdHJpbmciLCJpbkVzY2FwZSIsImZpeGVkSlNPTiIsImkiLCJjaGFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/job-processor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createJob: () => (/* binding */ createJob),\n/* harmony export */   getJobStatus: () => (/* binding */ getJobStatus),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   updateJobStatus: () => (/* binding */ updateJobStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n// Explicitly log all environment variables for debugging\nconsole.log(\"NODE_ENV:\", \"development\");\nconsole.log(\"Environment Variables Overview:\", {\n    hasProcessEnv: typeof process !== \"undefined\" && !!process.env,\n    nodeEnv: \"development\",\n    hasSbUrl: \"NEXT_PUBLIC_SUPABASE_URL\" in process.env,\n    hasSbKey: \"NEXT_PUBLIC_SUPABASE_ANON_KEY\" in process.env,\n    nextConfig: \"string\" === \"string\",\n    envVarCount: Object.keys(process.env).filter((key)=>key.startsWith(\"NEXT_\")).length\n});\n// Supabase client setup\n// Directly access variables for debugging rather than using || '' pattern initially\nlet supabaseUrl = \"https://toaiekqwflojwicejvne.supabase.co\";\nlet supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\";\n// Debug Supabase setup without exposing keys\nconsole.log(\"Direct Supabase URL:\", supabaseUrl?.substring(0, 12) + \"...\" || 0);\nconsole.log(\"Direct Supabase Key:\", supabaseAnonKey?.substring(0, 6) + \"...\" || 0);\n// Fallback to empty string if undefined\nsupabaseUrl = supabaseUrl || \"\";\nsupabaseAnonKey = supabaseAnonKey || \"\";\n// Debug Supabase setup without exposing keys\nconsole.log(\"Supabase configuration check:\", {\n    hasUrl: Boolean(supabaseUrl),\n    urlLength: supabaseUrl?.length || 0,\n    urlPrefix: supabaseUrl?.substring(0, 8) || \"\",\n    hasKey: Boolean(supabaseAnonKey),\n    keyLength: supabaseAnonKey?.length || 0,\n    keyPrefix: supabaseAnonKey?.substring(0, 4) || \"\"\n});\n// Check if Supabase is configured properly\nconst isSupabaseConfigured = Boolean(supabaseUrl && supabaseAnonKey);\n// In-memory store to track if Supabase connectivity failed during runtime\nlet supabaseDisabled = false;\n// Initialize the Supabase client with explicit options for better reliability\nconst supabase = isSupabaseConfigured ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    },\n    global: {\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    },\n    db: {\n        schema: \"public\"\n    }\n}) : (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(\"https://placeholder-url.supabase.co\", \"placeholder-key\", {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    }\n});\n// Log initialization status\nif (!isSupabaseConfigured) {\n    console.log(\"Supabase not properly configured. Using in-memory job storage as fallback.\");\n} else {\n    console.log(\"Supabase client initialized, verifying connection...\");\n    // Attempt to verify connection and ensure the jobs table exists\n    verifySupabaseConnection().catch((err)=>{\n        console.warn(\"Failed to verify Supabase connection:\", err.message);\n    });\n}\n// In-memory fallback store for development or when Supabase isn't configured\nconst inMemoryJobs = {};\n// Function to verify the Supabase connection\nasync function verifySupabaseConnection() {\n    if (!isSupabaseConfigured) return;\n    try {\n        console.log(\"Checking Supabase connection...\");\n        // First try to directly query if the jobs table exists\n        const { data, error } = await supabase.from(\"jobs\").select(\"*\").limit(1);\n        if (error) {\n            // Table might not exist\n            if (error.code === \"42P01\") {\n                console.log(\"Jobs table does not exist, will attempt to create it\");\n                await ensureJobsTableExists();\n            } else {\n                console.error(\"Supabase connection verification failed:\", {\n                    message: error.message,\n                    code: error.code,\n                    details: error.details\n                });\n            }\n        } else {\n            console.log(\"Supabase connection verified successfully, jobs table exists\");\n            // Check to see if we have the right columns\n            await checkTableStructure(data);\n        }\n    } catch (error) {\n        console.error(\"Error verifying Supabase connection:\", {\n            message: error.message,\n            stack: error.stack?.substring(0, 200)\n        });\n        // If this is a network error, disable Supabase\n        if (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\") || error instanceof TypeError) {\n            console.warn(\"Disabling Supabase due to connection issues\");\n            supabaseDisabled = true;\n        }\n    }\n}\n// Check and adapt to existing table structure\nasync function checkTableStructure(sampleData) {\n    if (sampleData && sampleData.length > 0) {\n        // Log the structure we found for debugging\n        const firstRow = sampleData[0];\n        console.log(\"Found existing jobs table with columns:\", Object.keys(firstRow).join(\", \"));\n    }\n}\n// Function to check and create the jobs table if it doesn't exist\nasync function ensureJobsTableExists() {\n    if (!isSupabaseConfigured) return;\n    try {\n        console.log(\"Attempting to create jobs table...\");\n        // Check if we have permission to execute SQL\n        try {\n            // First, try to create a simple table with the minimum required fields\n            const createTableSQL = `\n        CREATE TABLE IF NOT EXISTS jobs (\n          id BIGINT PRIMARY KEY,\n          status TEXT,\n          result JSONB,\n          error TEXT,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n        );\n      `;\n            const { error: createError } = await supabase.rpc(\"execute_sql\", {\n                sql: createTableSQL\n            });\n            if (createError) {\n                console.error(\"Failed to create jobs table via SQL:\", createError);\n                // Try an alternative approach - using the insert API\n                console.log(\"Trying to create jobs table via insert...\");\n                const { error: insertError } = await supabase.from(\"jobs\").insert({\n                    id: 0,\n                    status: \"test\",\n                    result: null,\n                    error: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                });\n                if (insertError) {\n                    // If Supabase doesn't let us create the table, log what needs to be created\n                    console.error(\"Cannot create jobs table automatically:\", insertError);\n                    console.error(\"Please create the jobs table manually with this SQL:\");\n                    console.error(createTableSQL);\n                } else {\n                    console.log(\"Jobs table created successfully through insert\");\n                    // Clean up test record\n                    await supabase.from(\"jobs\").delete().eq(\"id\", 0);\n                }\n            } else {\n                console.log(\"Jobs table created successfully through SQL\");\n            }\n        } catch (sqlError) {\n            console.error(\"Error executing SQL:\", sqlError.message);\n        }\n    } catch (error) {\n        console.error(\"Error ensuring jobs table exists:\", error.message);\n    // This error is handled gracefully, we'll just use in-memory storage\n    }\n}\n// Convert string ID to a numeric hash if needed for Supabase compatibility\nfunction getDbCompatibleId(id) {\n    // If the ID is already numeric, return it as is\n    if (!isNaN(Number(id))) {\n        return Number(id);\n    }\n    // For job IDs that start with a timestamp (job_ or debug_), extract the timestamp\n    // This ensures consistent ID generation across environments\n    const timestampMatch = id.match(/^(job|debug|test)_(\\d+)/);\n    if (timestampMatch && !isNaN(Number(timestampMatch[2]))) {\n        // Use the timestamp portion as the numeric ID\n        return Number(timestampMatch[2]);\n    }\n    // For any other IDs, use a hash function to generate a numeric ID\n    // This is useful for non-standard job IDs\n    let hash = 0;\n    const prime = 31; // Use a prime number for better distribution\n    for(let i = 0; i < id.length; i++){\n        // Get the character code\n        const char = id.charCodeAt(i);\n        // Multiply the current hash by the prime and add the character code\n        hash = Math.imul(hash, prime) + char | 0;\n    }\n    // Ensure positive number by using absolute value and make it large enough to avoid collisions\n    return Math.abs(hash);\n}\n// Check if Supabase should be used\nfunction shouldUseSupabase() {\n    return isSupabaseConfigured && !supabaseDisabled;\n}\n// Handle Supabase errors consistently\nfunction handleSupabaseError(error) {\n    console.error(\"Supabase operation failed:\", {\n        message: error.message,\n        name: error.name,\n        code: error.code,\n        hint: error.hint,\n        details: error.details,\n        isTypeError: error instanceof TypeError\n    });\n    // If we get a fetch error, disable Supabase for this session\n    if (error instanceof TypeError && (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\"))) {\n        console.warn(\"Disabling Supabase due to connectivity issues. Using in-memory storage as fallback.\");\n        supabaseDisabled = true;\n    }\n}\n// Function to create or update a job\nasync function updateJobStatus(jobId, status, data) {\n    // Create in-memory fallback entry\n    const memoryJob = {\n        id: jobId,\n        status: status,\n        result: data?.result || undefined,\n        error: data?.error || undefined,\n        created_at: inMemoryJobs[jobId]?.created_at || new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    // Save to in-memory store\n    inMemoryJobs[jobId] = memoryJob;\n    // If we shouldn't use Supabase, return early with success\n    if (!shouldUseSupabase()) {\n        return true;\n    }\n    try {\n        const dbId = getDbCompatibleId(jobId);\n        // Ensure result is properly serialized before sending to Supabase\n        let safeResult = null;\n        if (data?.result) {\n            try {\n                // Log coordinates before serialization if they exist\n                if (data.result?.itinerary?.days) {\n                    console.log(\"Checking coordinates before serialization...\");\n                    const days = data.result.itinerary.days;\n                    let hasCoordinateIssues = false;\n                    for(let i = 0; i < days.length; i++){\n                        const day = days[i];\n                        if (day.activities && Array.isArray(day.activities)) {\n                            for(let j = 0; j < day.activities.length; j++){\n                                const activity = day.activities[j];\n                                if (!activity.coordinates || typeof activity.coordinates !== \"object\") {\n                                    console.error(`Missing coordinates in day ${i}, activity ${j}: ${activity.title}`);\n                                    hasCoordinateIssues = true;\n                                } else {\n                                    if (activity.coordinates.lat === undefined || activity.coordinates.lng === undefined) {\n                                        console.error(`Incomplete coordinates in day ${i}, activity ${j}: ${JSON.stringify(activity.coordinates)}`);\n                                        hasCoordinateIssues = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (!hasCoordinateIssues) {\n                        console.log(\"All coordinates look valid before serialization\");\n                    }\n                }\n                // Test serialization first to catch any issues\n                JSON.stringify(data.result);\n                safeResult = data.result;\n            } catch (e) {\n                console.error(\"Failed to serialize job result to JSON:\", e);\n                safeResult = {\n                    error: \"Result contained unserializable data\"\n                };\n            }\n        }\n        console.log(`Updating job ${jobId} (dbId: ${dbId}) status to ${status}`);\n        // First, get the current job to preserve created_at\n        let created_at = memoryJob.created_at;\n        try {\n            const { data: existingJob } = await supabase.from(\"jobs\").select(\"created_at\").eq(\"id\", dbId).single();\n            if (existingJob?.created_at) {\n                created_at = existingJob.created_at;\n                console.log(`Using existing created_at timestamp: ${created_at}`);\n            } else {\n                console.log(`No existing created_at found, using default created_at: ${created_at}`);\n            }\n        } catch (err) {\n            console.log(`Could not fetch existing job, using default created_at: ${created_at}`);\n        }\n        // Now update with the preserved created_at\n        const { error } = await supabase.from(\"jobs\").upsert({\n            id: dbId,\n            status,\n            result: safeResult,\n            error: data?.error || null,\n            created_at: created_at,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"id\"\n        });\n        if (error) {\n            console.error(\"Error updating job status in Supabase:\", {\n                code: error.code,\n                message: error.message,\n                details: error.details,\n                jobId,\n                dbId,\n                status\n            });\n        } else {\n            console.log(`Successfully updated job ${jobId} in Supabase`);\n        }\n    } catch (error) {\n        handleSupabaseError(error);\n    }\n    // Always return true since we saved to in-memory storage\n    return true;\n}\n// Get the status of a job\nasync function getJobStatus(jobId) {\n    // Enhanced logging for troubleshooting\n    console.log(`========== JOB STATUS CHECK ==========`);\n    console.log(`getJobStatus called for job: ${jobId}`);\n    console.log(`Environment: ${\"development\"}`);\n    console.log(`Supabase configured: ${isSupabaseConfigured}`);\n    console.log(`Supabase disabled flag: ${supabaseDisabled}`);\n    console.log(`shouldUseSupabase(): ${shouldUseSupabase()}`);\n    // Check in-memory storage first\n    const memoryJob = inMemoryJobs[jobId];\n    // Log in-memory job status\n    console.log(`In-memory job status for ${jobId}: ${memoryJob ? memoryJob.status : \"not found\"}`);\n    console.log(`In-memory jobs count: ${Object.keys(inMemoryJobs).length}`);\n    console.log(`All in-memory job IDs: ${Object.keys(inMemoryJobs).join(\", \").substring(0, 200)}`);\n    // Not even in memory\n    if (!memoryJob) {\n        console.log(`Job ${jobId} not found in memory, will check Supabase if available`);\n        // If Supabase is properly configured and not disabled, try to fetch from there\n        if (shouldUseSupabase()) {\n            try {\n                const dbId = getDbCompatibleId(jobId);\n                console.log(`Checking Supabase for job ${jobId} (DB ID: ${dbId})`);\n                const { data, error } = await supabase.from(\"jobs\").select(\"*\").eq(\"id\", dbId).maybeSingle();\n                if (error) {\n                    console.error(`Supabase error checking for job ${jobId}:`, {\n                        message: error.message,\n                        code: error.code,\n                        details: error.details\n                    });\n                    return {\n                        status: \"not_found\"\n                    };\n                }\n                if (!data) {\n                    console.log(`Job ${jobId} not found in Supabase either`);\n                    return {\n                        status: \"not_found\"\n                    };\n                }\n                console.log(`Found job ${jobId} in Supabase with status: ${data.status}`);\n                // Store in memory for future quick access\n                inMemoryJobs[jobId] = {\n                    id: jobId,\n                    status: data.status,\n                    result: data.result,\n                    error: data.error,\n                    created_at: data.created_at,\n                    updated_at: data.updated_at\n                };\n                return {\n                    status: data.status,\n                    result: data.result,\n                    error: data.error\n                };\n            } catch (error) {\n                console.error(`Exception checking Supabase for job ${jobId}:`, {\n                    message: error.message,\n                    stack: error.stack?.substring(0, 200)\n                });\n                return {\n                    status: \"not_found\"\n                };\n            }\n        } else {\n            console.log(`Supabase not available, job ${jobId} is not found`);\n            return {\n                status: \"not_found\"\n            };\n        }\n    }\n    // If Supabase is disabled or improperly configured, only use in-memory storage\n    if (!shouldUseSupabase()) {\n        console.log(`Using in-memory data for job ${jobId} (Supabase not available)`);\n        return {\n            status: memoryJob.status,\n            result: memoryJob.result,\n            error: memoryJob.error\n        };\n    }\n    // Add retry logic for fetching status from Supabase\n    const maxRetries = 3;\n    let attempts = 0;\n    while(attempts < maxRetries){\n        try {\n            const dbId = getDbCompatibleId(jobId);\n            console.log(`Fetching job status for ${jobId} (dbId: ${dbId}) from Supabase (attempt ${attempts + 1})`);\n            const { data, error } = await supabase.from(\"jobs\").select(\"*\").eq(\"id\", dbId).maybeSingle();\n            if (error) {\n                console.error(\"Error retrieving job status from Supabase:\", {\n                    message: error.message,\n                    code: error.code,\n                    details: error.details,\n                    jobId,\n                    dbId,\n                    attempt: attempts + 1\n                });\n                attempts++;\n                if (attempts < maxRetries) {\n                    // Wait before retrying (exponential backoff)\n                    await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, attempts)));\n                    continue;\n                }\n                // Fall back to in-memory after all retries\n                console.log(`All ${maxRetries} attempts to fetch job from Supabase failed, using in-memory data`);\n                handleSupabaseError(error);\n                return {\n                    status: memoryJob.status,\n                    result: memoryJob.result,\n                    error: memoryJob.error\n                };\n            }\n            if (!data) {\n                console.log(`Job ${jobId} not found in Supabase, using in-memory data`);\n                // Not found in DB but in memory, return memory version\n                return {\n                    status: memoryJob.status,\n                    result: memoryJob.result,\n                    error: memoryJob.error\n                };\n            }\n            console.log(`Successfully retrieved job ${jobId} status from Supabase: ${data.status}`);\n            // Update in-memory store to keep in sync\n            inMemoryJobs[jobId] = {\n                id: jobId,\n                status: data.status,\n                result: data.result,\n                error: data.error,\n                created_at: data.created_at,\n                updated_at: data.updated_at\n            };\n            return {\n                status: data.status,\n                result: data.result,\n                error: data.error\n            };\n        } catch (error) {\n            attempts++;\n            console.error(`Error fetching job status (attempt ${attempts}):`, {\n                message: error.message,\n                stack: error.stack?.substring(0, 200),\n                jobId,\n                attempt: attempts\n            });\n            if (attempts < maxRetries) {\n                // Wait before retrying (exponential backoff)\n                await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, attempts)));\n                continue;\n            }\n            // All retries failed, fall back to in-memory\n            handleSupabaseError(error);\n            console.log(`Falling back to in-memory data for job ${jobId} after ${maxRetries} failed Supabase attempts`);\n            return {\n                status: memoryJob.status,\n                result: memoryJob.result,\n                error: memoryJob.error\n            };\n        }\n    }\n    // This should never be reached due to the returns in the loop, but TypeScript needs it\n    console.log(`Code reached unreachable point in getJobStatus for job ${jobId}`);\n    return {\n        status: memoryJob.status,\n        result: memoryJob.result,\n        error: memoryJob.error\n    };\n}\n// Function to create a new job\nasync function createJob(jobId) {\n    // Get a DB-compatible ID\n    const dbId = getDbCompatibleId(jobId);\n    console.log(`Creating job ${jobId} (DB ID: ${dbId})`);\n    // Always create the job in memory first for redundancy\n    inMemoryJobs[jobId] = {\n        id: jobId,\n        status: \"queued\",\n        updated_at: new Date().toISOString()\n    };\n    console.log(`Job ${jobId} created in memory`);\n    // If Supabase is disabled, just return success from in-memory storage\n    if (!shouldUseSupabase()) {\n        console.log(`Using in-memory storage only for job ${jobId}`);\n        return true;\n    }\n    try {\n        console.log(`Inserting job ${jobId} into Supabase`);\n        // Try to insert the job into Supabase\n        const { error } = await supabase.from(\"jobs\").insert({\n            id: dbId,\n            status: \"queued\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        });\n        if (error) {\n            console.error(`Error creating job ${jobId} in Supabase:`, {\n                message: error.message,\n                code: error.code,\n                details: error.details\n            });\n            // For conflicts, the job might already exist\n            if (error.code === \"23505\") {\n                console.log(`Job ${jobId} already exists in Supabase, updating status instead`);\n                // Try to update the job instead\n                const { error: updateError } = await supabase.from(\"jobs\").update({\n                    status: \"queued\",\n                    updated_at: new Date().toISOString()\n                }).eq(\"id\", dbId);\n                if (updateError) {\n                    console.error(`Error updating existing job ${jobId} in Supabase:`, updateError);\n                    // Even if update fails, we have the job in memory\n                    handleSupabaseError(updateError);\n                    return true;\n                } else {\n                    console.log(`Successfully updated job ${jobId} in Supabase`);\n                    return true;\n                }\n            }\n            // For foreign key constraint failures, try to create with minimal fields\n            if (error.code === \"23503\") {\n                console.log(`Trying simplified job creation for ${jobId}`);\n                const { error: simpleError } = await supabase.from(\"jobs\").insert({\n                    id: dbId,\n                    status: \"queued\"\n                });\n                if (simpleError) {\n                    console.error(`Simplified job creation also failed for ${jobId}:`, simpleError);\n                    handleSupabaseError(simpleError);\n                    return true; // Still return true since we have in-memory backup\n                } else {\n                    console.log(`Simplified job creation succeeded for ${jobId}`);\n                    return true;\n                }\n            }\n            // For other errors, handle gracefully and use in-memory storage as fallback\n            handleSupabaseError(error);\n            return true; // Still return true since we have in-memory backup\n        }\n        console.log(`Successfully created job ${jobId} in Supabase`);\n        return true;\n    } catch (error) {\n        console.error(`Exception while creating job ${jobId}:`, {\n            message: error.message,\n            stack: error.stack?.substring(0, 200)\n        });\n        // In case of network or other exception, we already have the job in memory\n        handleSupabaseError(error);\n        return true; // Still return true since we have in-memory backup\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUQ7QUFFckQseURBQXlEO0FBQ3pEQyxRQUFRQyxHQUFHLENBQUMsYUFIWjtBQUlBRCxRQUFRQyxHQUFHLENBQUMsbUNBQW1DO0lBQzdDQyxlQUFlLE9BQU9DLFlBQVksZUFBZSxDQUFDLENBQUNBLFFBQVFDLEdBQUc7SUFDOURDLFNBTkY7SUFPRUMsVUFBVSw4QkFBOEJILFFBQVFDLEdBQUc7SUFDbkRHLFVBQVUsbUNBQW1DSixRQUFRQyxHQUFHO0lBQ3hESSxZQUFZLFFBQXdDLEtBQUs7SUFDekRFLGFBQWFDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUUMsR0FBRyxFQUFFUyxNQUFNLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLFVBQVUsQ0FBQyxVQUFVQyxNQUFNO0FBQ3JGO0FBRUEsd0JBQXdCO0FBQ3hCLG9GQUFvRjtBQUNwRixJQUFJQyxjQUFjZCwwQ0FBb0M7QUFDdEQsSUFBSWdCLGtCQUFrQmhCLGtOQUF5QztBQUUvRCw2Q0FBNkM7QUFDN0NILFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0JnQixhQUFhSSxVQUFVLEdBQUcsTUFBTSxTQUFTO0FBQzdFckIsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QmtCLGlCQUFpQkUsVUFBVSxHQUFHLEtBQUssU0FBUztBQUVoRix3Q0FBd0M7QUFDeENKLGNBQWNBLGVBQWU7QUFDN0JFLGtCQUFrQkEsbUJBQW1CO0FBRXJDLDZDQUE2QztBQUM3Q25CLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUM7SUFDM0NxQixRQUFRQyxRQUFRTjtJQUNoQk8sV0FBV1AsYUFBYUQsVUFBVTtJQUNsQ1MsV0FBV1IsYUFBYUksVUFBVSxHQUFHLE1BQU07SUFDM0NLLFFBQVFILFFBQVFKO0lBQ2hCUSxXQUFXUixpQkFBaUJILFVBQVU7SUFDdENZLFdBQVdULGlCQUFpQkUsVUFBVSxHQUFHLE1BQU07QUFDakQ7QUFZQSwyQ0FBMkM7QUFDM0MsTUFBTVEsdUJBQXVCTixRQUFRTixlQUFlRTtBQUVwRCwwRUFBMEU7QUFDMUUsSUFBSVcsbUJBQW1CO0FBRXZCLDhFQUE4RTtBQUN2RSxNQUFNQyxXQUFXRix1QkFDcEI5QixtRUFBWUEsQ0FBQ2tCLGFBQWFFLGlCQUFpQjtJQUN6Q2EsTUFBTTtRQUNKQyxnQkFBZ0I7UUFDaEJDLGtCQUFrQjtJQUNwQjtJQUNBQyxRQUFRO1FBQ05DLFNBQVM7WUFDUCxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBQyxJQUFJO1FBQ0ZDLFFBQVE7SUFDVjtBQUNGLEtBQ0F2QyxtRUFBWUEsQ0FBQyx1Q0FBdUMsbUJBQW1CO0lBQ3JFaUMsTUFBTTtRQUNKQyxnQkFBZ0I7UUFDaEJDLGtCQUFrQjtJQUNwQjtBQUNGLEdBQUc7QUFFUCw0QkFBNEI7QUFDNUIsSUFBSSxDQUFDTCxzQkFBc0I7SUFDekI3QixRQUFRQyxHQUFHLENBQUM7QUFDZCxPQUFPO0lBQ0xELFFBQVFDLEdBQUcsQ0FBQztJQUNaLGdFQUFnRTtJQUNoRXNDLDJCQUEyQkMsS0FBSyxDQUFDQyxDQUFBQTtRQUMvQnpDLFFBQVEwQyxJQUFJLENBQUMseUNBQXlDRCxJQUFJRSxPQUFPO0lBQ25FO0FBQ0Y7QUFFQSw2RUFBNkU7QUFDN0UsTUFBTUMsZUFBd0MsQ0FBQztBQUUvQyw2Q0FBNkM7QUFDN0MsZUFBZUw7SUFDYixJQUFJLENBQUNWLHNCQUFzQjtJQUUzQixJQUFJO1FBQ0Y3QixRQUFRQyxHQUFHLENBQUM7UUFFWix1REFBdUQ7UUFDdkQsTUFBTSxFQUFFNEMsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNZixTQUMzQmdCLElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDO1FBRVQsSUFBSUgsT0FBTztZQUNULHdCQUF3QjtZQUN4QixJQUFJQSxNQUFNSSxJQUFJLEtBQUssU0FBUztnQkFDMUJsRCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osTUFBTWtEO1lBQ1IsT0FBTztnQkFDTG5ELFFBQVE4QyxLQUFLLENBQUMsNENBQTRDO29CQUN4REgsU0FBU0csTUFBTUgsT0FBTztvQkFDdEJPLE1BQU1KLE1BQU1JLElBQUk7b0JBQ2hCRSxTQUFTTixNQUFNTSxPQUFPO2dCQUN4QjtZQUNGO1FBQ0YsT0FBTztZQUNMcEQsUUFBUUMsR0FBRyxDQUFDO1lBQ1osNENBQTRDO1lBQzVDLE1BQU1vRCxvQkFBb0JSO1FBQzVCO0lBQ0YsRUFBRSxPQUFPQyxPQUFZO1FBQ25COUMsUUFBUThDLEtBQUssQ0FBQyx3Q0FBd0M7WUFDcERILFNBQVNHLE1BQU1ILE9BQU87WUFDdEJXLE9BQU9SLE1BQU1RLEtBQUssRUFBRWpDLFVBQVUsR0FBRztRQUNuQztRQUVBLCtDQUErQztRQUMvQyxJQUFJeUIsTUFBTUgsT0FBTyxFQUFFWSxTQUFTLG1CQUN4QlQsTUFBTUgsT0FBTyxFQUFFWSxTQUFTLG9CQUN4QlQsaUJBQWlCVSxXQUFXO1lBQzlCeEQsUUFBUTBDLElBQUksQ0FBQztZQUNiWixtQkFBbUI7UUFDckI7SUFDRjtBQUNGO0FBRUEsOENBQThDO0FBQzlDLGVBQWV1QixvQkFBb0JJLFVBQWlCO0lBQ2xELElBQUlBLGNBQWNBLFdBQVd6QyxNQUFNLEdBQUcsR0FBRztRQUN2QywyQ0FBMkM7UUFDM0MsTUFBTTBDLFdBQVdELFVBQVUsQ0FBQyxFQUFFO1FBQzlCekQsUUFBUUMsR0FBRyxDQUFDLDJDQUEyQ1UsT0FBT0MsSUFBSSxDQUFDOEMsVUFBVUMsSUFBSSxDQUFDO0lBQ3BGO0FBQ0Y7QUFFQSxrRUFBa0U7QUFDbEUsZUFBZVI7SUFDYixJQUFJLENBQUN0QixzQkFBc0I7SUFFM0IsSUFBSTtRQUNGN0IsUUFBUUMsR0FBRyxDQUFDO1FBRVosNkNBQTZDO1FBQzdDLElBQUk7WUFDRix1RUFBdUU7WUFDdkUsTUFBTTJELGlCQUFpQixDQUFDOzs7Ozs7Ozs7TUFTeEIsQ0FBQztZQUVELE1BQU0sRUFBRWQsT0FBT2UsV0FBVyxFQUFFLEdBQUcsTUFBTTlCLFNBQVMrQixHQUFHLENBQUMsZUFBZTtnQkFBRUMsS0FBS0g7WUFBZTtZQUV2RixJQUFJQyxhQUFhO2dCQUNmN0QsUUFBUThDLEtBQUssQ0FBQyx3Q0FBd0NlO2dCQUV0RCxxREFBcUQ7Z0JBQ3JEN0QsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE1BQU0sRUFBRTZDLE9BQU9rQixXQUFXLEVBQUUsR0FBRyxNQUFNakMsU0FDbENnQixJQUFJLENBQUMsUUFDTGtCLE1BQU0sQ0FBQztvQkFDTkMsSUFBSTtvQkFDSkMsUUFBUTtvQkFDUkMsUUFBUTtvQkFDUnRCLE9BQU87b0JBQ1B1QixZQUFZLElBQUlDLE9BQU9DLFdBQVc7b0JBQ2xDQyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7Z0JBQ3BDO2dCQUVGLElBQUlQLGFBQWE7b0JBQ2YsNEVBQTRFO29CQUM1RWhFLFFBQVE4QyxLQUFLLENBQUMsMkNBQTJDa0I7b0JBQ3pEaEUsUUFBUThDLEtBQUssQ0FBQztvQkFDZDlDLFFBQVE4QyxLQUFLLENBQUNjO2dCQUNoQixPQUFPO29CQUNMNUQsUUFBUUMsR0FBRyxDQUFDO29CQUVaLHVCQUF1QjtvQkFDdkIsTUFBTThCLFNBQVNnQixJQUFJLENBQUMsUUFBUTBCLE1BQU0sR0FBR0MsRUFBRSxDQUFDLE1BQU07Z0JBQ2hEO1lBQ0YsT0FBTztnQkFDTDFFLFFBQVFDLEdBQUcsQ0FBQztZQUNkO1FBQ0YsRUFBRSxPQUFPMEUsVUFBZTtZQUN0QjNFLFFBQVE4QyxLQUFLLENBQUMsd0JBQXdCNkIsU0FBU2hDLE9BQU87UUFDeEQ7SUFDRixFQUFFLE9BQU9HLE9BQVk7UUFDbkI5QyxRQUFROEMsS0FBSyxDQUFDLHFDQUFxQ0EsTUFBTUgsT0FBTztJQUNoRSxxRUFBcUU7SUFDdkU7QUFDRjtBQUVBLDJFQUEyRTtBQUMzRSxTQUFTaUMsa0JBQWtCVixFQUFVO0lBQ25DLGdEQUFnRDtJQUNoRCxJQUFJLENBQUNXLE1BQU1DLE9BQU9aLE1BQU07UUFDdEIsT0FBT1ksT0FBT1o7SUFDaEI7SUFFQSxrRkFBa0Y7SUFDbEYsNERBQTREO0lBQzVELE1BQU1hLGlCQUFpQmIsR0FBR2MsS0FBSyxDQUFDO0lBQ2hDLElBQUlELGtCQUFrQixDQUFDRixNQUFNQyxPQUFPQyxjQUFjLENBQUMsRUFBRSxJQUFJO1FBQ3ZELDhDQUE4QztRQUM5QyxPQUFPRCxPQUFPQyxjQUFjLENBQUMsRUFBRTtJQUNqQztJQUVBLGtFQUFrRTtJQUNsRSwwQ0FBMEM7SUFDMUMsSUFBSUUsT0FBTztJQUNYLE1BQU1DLFFBQVEsSUFBSSw2Q0FBNkM7SUFFL0QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlqQixHQUFHbEQsTUFBTSxFQUFFbUUsSUFBSztRQUNsQyx5QkFBeUI7UUFDekIsTUFBTUMsT0FBT2xCLEdBQUdtQixVQUFVLENBQUNGO1FBQzNCLG9FQUFvRTtRQUNwRUYsT0FBT0ssS0FBS0MsSUFBSSxDQUFDTixNQUFNQyxTQUFTRSxPQUFPO0lBQ3pDO0lBRUEsOEZBQThGO0lBQzlGLE9BQU9FLEtBQUtFLEdBQUcsQ0FBQ1A7QUFDbEI7QUFFQSxtQ0FBbUM7QUFDbkMsU0FBU1E7SUFDUCxPQUFPNUQsd0JBQXdCLENBQUNDO0FBQ2xDO0FBRUEsc0NBQXNDO0FBQ3RDLFNBQVM0RCxvQkFBb0I1QyxLQUFVO0lBQ3JDOUMsUUFBUThDLEtBQUssQ0FBQyw4QkFBOEI7UUFDMUNILFNBQVNHLE1BQU1ILE9BQU87UUFDdEJnRCxNQUFNN0MsTUFBTTZDLElBQUk7UUFDaEJ6QyxNQUFNSixNQUFNSSxJQUFJO1FBQ2hCMEMsTUFBTTlDLE1BQU04QyxJQUFJO1FBQ2hCeEMsU0FBU04sTUFBTU0sT0FBTztRQUN0QnlDLGFBQWEvQyxpQkFBaUJVO0lBQ2hDO0lBRUEsNkRBQTZEO0lBQzdELElBQUlWLGlCQUFpQlUsYUFDaEJWLENBQUFBLE1BQU1ILE9BQU8sRUFBRVksU0FBUyxtQkFBbUJULE1BQU1ILE9BQU8sRUFBRVksU0FBUyxnQkFBZSxHQUFJO1FBQ3pGdkQsUUFBUTBDLElBQUksQ0FBQztRQUNiWixtQkFBbUI7SUFDckI7QUFDRjtBQUVBLHFDQUFxQztBQUM5QixlQUFlZ0UsZ0JBQ3BCQyxLQUFhLEVBQ2I1QixNQUFjLEVBQ2R0QixJQUF1QztJQUV2QyxrQ0FBa0M7SUFDbEMsTUFBTW1ELFlBQXFCO1FBQ3pCOUIsSUFBSTZCO1FBQ0o1QixRQUFRQTtRQUNSQyxRQUFRdkIsTUFBTXVCLFVBQVU2QjtRQUN4Qm5ELE9BQU9ELE1BQU1DLFNBQVNtRDtRQUN0QjVCLFlBQVl6QixZQUFZLENBQUNtRCxNQUFNLEVBQUUxQixjQUFjLElBQUlDLE9BQU9DLFdBQVc7UUFDckVDLFlBQVksSUFBSUYsT0FBT0MsV0FBVztJQUNwQztJQUVBLDBCQUEwQjtJQUMxQjNCLFlBQVksQ0FBQ21ELE1BQU0sR0FBR0M7SUFFdEIsMERBQTBEO0lBQzFELElBQUksQ0FBQ1AscUJBQXFCO1FBQ3hCLE9BQU87SUFDVDtJQUVBLElBQUk7UUFDRixNQUFNUyxPQUFPdEIsa0JBQWtCbUI7UUFFL0Isa0VBQWtFO1FBQ2xFLElBQUlJLGFBQWE7UUFDakIsSUFBSXRELE1BQU11QixRQUFRO1lBQ2hCLElBQUk7Z0JBQ0YscURBQXFEO2dCQUNyRCxJQUFJdkIsS0FBS3VCLE1BQU0sRUFBRWdDLFdBQVdDLE1BQU07b0JBQ2hDckcsUUFBUUMsR0FBRyxDQUFDO29CQUNaLE1BQU1vRyxPQUFPeEQsS0FBS3VCLE1BQU0sQ0FBQ2dDLFNBQVMsQ0FBQ0MsSUFBSTtvQkFDdkMsSUFBSUMsc0JBQXNCO29CQUUxQixJQUFLLElBQUluQixJQUFJLEdBQUdBLElBQUlrQixLQUFLckYsTUFBTSxFQUFFbUUsSUFBSzt3QkFDcEMsTUFBTW9CLE1BQU1GLElBQUksQ0FBQ2xCLEVBQUU7d0JBQ25CLElBQUlvQixJQUFJQyxVQUFVLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsSUFBSUMsVUFBVSxHQUFHOzRCQUNuRCxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUosSUFBSUMsVUFBVSxDQUFDeEYsTUFBTSxFQUFFMkYsSUFBSztnQ0FDOUMsTUFBTUMsV0FBV0wsSUFBSUMsVUFBVSxDQUFDRyxFQUFFO2dDQUNsQyxJQUFJLENBQUNDLFNBQVNDLFdBQVcsSUFBSSxPQUFPRCxTQUFTQyxXQUFXLEtBQUssVUFBVTtvQ0FDckU3RyxRQUFROEMsS0FBSyxDQUFDLENBQUMsMkJBQTJCLEVBQUVxQyxFQUFFLFdBQVcsRUFBRXdCLEVBQUUsRUFBRSxFQUFFQyxTQUFTRSxLQUFLLENBQUMsQ0FBQztvQ0FDakZSLHNCQUFzQjtnQ0FDeEIsT0FBTztvQ0FDTCxJQUFJTSxTQUFTQyxXQUFXLENBQUNFLEdBQUcsS0FBS2QsYUFBYVcsU0FBU0MsV0FBVyxDQUFDRyxHQUFHLEtBQUtmLFdBQVc7d0NBQ3BGakcsUUFBUThDLEtBQUssQ0FBQyxDQUFDLDhCQUE4QixFQUFFcUMsRUFBRSxXQUFXLEVBQUV3QixFQUFFLEVBQUUsRUFBRU0sS0FBS0MsU0FBUyxDQUFDTixTQUFTQyxXQUFXLEVBQUUsQ0FBQzt3Q0FDMUdQLHNCQUFzQjtvQ0FDeEI7Z0NBQ0Y7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7b0JBRUEsSUFBSSxDQUFDQSxxQkFBcUI7d0JBQ3hCdEcsUUFBUUMsR0FBRyxDQUFDO29CQUNkO2dCQUNGO2dCQUVBLCtDQUErQztnQkFDL0NnSCxLQUFLQyxTQUFTLENBQUNyRSxLQUFLdUIsTUFBTTtnQkFDMUIrQixhQUFhdEQsS0FBS3VCLE1BQU07WUFDMUIsRUFBRSxPQUFPK0MsR0FBRztnQkFDVm5ILFFBQVE4QyxLQUFLLENBQUMsMkNBQTJDcUU7Z0JBQ3pEaEIsYUFBYTtvQkFBRXJELE9BQU87Z0JBQXVDO1lBQy9EO1FBQ0Y7UUFFQTlDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGFBQWEsRUFBRThGLE1BQU0sUUFBUSxFQUFFRyxLQUFLLFlBQVksRUFBRS9CLE9BQU8sQ0FBQztRQUV2RSxvREFBb0Q7UUFDcEQsSUFBSUUsYUFBYTJCLFVBQVUzQixVQUFVO1FBQ3JDLElBQUk7WUFDRixNQUFNLEVBQUV4QixNQUFNdUUsV0FBVyxFQUFFLEdBQUcsTUFBTXJGLFNBQ2pDZ0IsSUFBSSxDQUFDLFFBQ0xDLE1BQU0sQ0FBQyxjQUNQMEIsRUFBRSxDQUFDLE1BQU13QixNQUNUbUIsTUFBTTtZQUVULElBQUlELGFBQWEvQyxZQUFZO2dCQUMzQkEsYUFBYStDLFlBQVkvQyxVQUFVO2dCQUNuQ3JFLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHFDQUFxQyxFQUFFb0UsV0FBVyxDQUFDO1lBQ2xFLE9BQU87Z0JBQ0xyRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyx3REFBd0QsRUFBRW9FLFdBQVcsQ0FBQztZQUNyRjtRQUNGLEVBQUUsT0FBTzVCLEtBQUs7WUFDWnpDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHdEQUF3RCxFQUFFb0UsV0FBVyxDQUFDO1FBQ3JGO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU0sRUFBRXZCLEtBQUssRUFBRSxHQUFHLE1BQU1mLFNBQ3JCZ0IsSUFBSSxDQUFDLFFBQ0x1RSxNQUFNLENBQUM7WUFDTnBELElBQUlnQztZQUNKL0I7WUFDQUMsUUFBUStCO1lBQ1JyRCxPQUFPRCxNQUFNQyxTQUFTO1lBQ3RCdUIsWUFBWUE7WUFDWkcsWUFBWSxJQUFJRixPQUFPQyxXQUFXO1FBQ3BDLEdBQUc7WUFDRGdELFlBQVk7UUFDZDtRQUVGLElBQUl6RSxPQUFPO1lBQ1Q5QyxRQUFROEMsS0FBSyxDQUFDLDBDQUEwQztnQkFDdERJLE1BQU1KLE1BQU1JLElBQUk7Z0JBQ2hCUCxTQUFTRyxNQUFNSCxPQUFPO2dCQUN0QlMsU0FBU04sTUFBTU0sT0FBTztnQkFDdEIyQztnQkFDQUc7Z0JBQ0EvQjtZQUNGO1FBQ0YsT0FBTztZQUNMbkUsUUFBUUMsR0FBRyxDQUFDLENBQUMseUJBQXlCLEVBQUU4RixNQUFNLFlBQVksQ0FBQztRQUM3RDtJQUNGLEVBQUUsT0FBT2pELE9BQU87UUFDZDRDLG9CQUFvQjVDO0lBQ3RCO0lBRUEseURBQXlEO0lBQ3pELE9BQU87QUFDVDtBQUVBLDBCQUEwQjtBQUNuQixlQUFlMEUsYUFBYXpCLEtBQWE7SUFDOUMsdUNBQXVDO0lBQ3ZDL0YsUUFBUUMsR0FBRyxDQUFDLENBQUMsc0NBQXNDLENBQUM7SUFDcERELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixFQUFFOEYsTUFBTSxDQUFDO0lBQ25EL0YsUUFBUUMsR0FBRyxDQUFDLENBQUMsYUFBYSxFQXRZNUIsY0FzWW1ELENBQUM7SUFDbERELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixFQUFFNEIscUJBQXFCLENBQUM7SUFDMUQ3QixRQUFRQyxHQUFHLENBQUMsQ0FBQyx3QkFBd0IsRUFBRTZCLGlCQUFpQixDQUFDO0lBQ3pEOUIsUUFBUUMsR0FBRyxDQUFDLENBQUMscUJBQXFCLEVBQUV3RixvQkFBb0IsQ0FBQztJQUV6RCxnQ0FBZ0M7SUFDaEMsTUFBTU8sWUFBWXBELFlBQVksQ0FBQ21ELE1BQU07SUFFckMsMkJBQTJCO0lBQzNCL0YsUUFBUUMsR0FBRyxDQUFDLENBQUMseUJBQXlCLEVBQUU4RixNQUFNLEVBQUUsRUFBRUMsWUFBWUEsVUFBVTdCLE1BQU0sR0FBRyxZQUFZLENBQUM7SUFDOUZuRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRVUsT0FBT0MsSUFBSSxDQUFDZ0MsY0FBYzVCLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZFaEIsUUFBUUMsR0FBRyxDQUFDLENBQUMsdUJBQXVCLEVBQUVVLE9BQU9DLElBQUksQ0FBQ2dDLGNBQWNlLElBQUksQ0FBQyxNQUFNdEMsU0FBUyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBRTlGLHFCQUFxQjtJQUNyQixJQUFJLENBQUMyRSxXQUFXO1FBQ2RoRyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUU4RixNQUFNLHNEQUFzRCxDQUFDO1FBRWhGLCtFQUErRTtRQUMvRSxJQUFJTixxQkFBcUI7WUFDdkIsSUFBSTtnQkFDRixNQUFNUyxPQUFPdEIsa0JBQWtCbUI7Z0JBQy9CL0YsUUFBUUMsR0FBRyxDQUFDLENBQUMsMEJBQTBCLEVBQUU4RixNQUFNLFNBQVMsRUFBRUcsS0FBSyxDQUFDLENBQUM7Z0JBRWpFLE1BQU0sRUFBRXJELElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWYsU0FDM0JnQixJQUFJLENBQUMsUUFDTEMsTUFBTSxDQUFDLEtBQ1AwQixFQUFFLENBQUMsTUFBTXdCLE1BQ1R1QixXQUFXO2dCQUVkLElBQUkzRSxPQUFPO29CQUNUOUMsUUFBUThDLEtBQUssQ0FBQyxDQUFDLGdDQUFnQyxFQUFFaUQsTUFBTSxDQUFDLENBQUMsRUFBRTt3QkFDekRwRCxTQUFTRyxNQUFNSCxPQUFPO3dCQUN0Qk8sTUFBTUosTUFBTUksSUFBSTt3QkFDaEJFLFNBQVNOLE1BQU1NLE9BQU87b0JBQ3hCO29CQUNBLE9BQU87d0JBQUVlLFFBQVE7b0JBQVk7Z0JBQy9CO2dCQUVBLElBQUksQ0FBQ3RCLE1BQU07b0JBQ1Q3QyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUU4RixNQUFNLDZCQUE2QixDQUFDO29CQUN2RCxPQUFPO3dCQUFFNUIsUUFBUTtvQkFBWTtnQkFDL0I7Z0JBRUFuRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUU4RixNQUFNLDBCQUEwQixFQUFFbEQsS0FBS3NCLE1BQU0sQ0FBQyxDQUFDO2dCQUN4RSwwQ0FBMEM7Z0JBQzFDdkIsWUFBWSxDQUFDbUQsTUFBTSxHQUFHO29CQUNwQjdCLElBQUk2QjtvQkFDSjVCLFFBQVF0QixLQUFLc0IsTUFBTTtvQkFDbkJDLFFBQVF2QixLQUFLdUIsTUFBTTtvQkFDbkJ0QixPQUFPRCxLQUFLQyxLQUFLO29CQUNqQnVCLFlBQVl4QixLQUFLd0IsVUFBVTtvQkFDM0JHLFlBQVkzQixLQUFLMkIsVUFBVTtnQkFDN0I7Z0JBRUEsT0FBTztvQkFDTEwsUUFBUXRCLEtBQUtzQixNQUFNO29CQUNuQkMsUUFBUXZCLEtBQUt1QixNQUFNO29CQUNuQnRCLE9BQU9ELEtBQUtDLEtBQUs7Z0JBQ25CO1lBQ0YsRUFBRSxPQUFPQSxPQUFZO2dCQUNuQjlDLFFBQVE4QyxLQUFLLENBQUMsQ0FBQyxvQ0FBb0MsRUFBRWlELE1BQU0sQ0FBQyxDQUFDLEVBQUU7b0JBQzdEcEQsU0FBU0csTUFBTUgsT0FBTztvQkFDdEJXLE9BQU9SLE1BQU1RLEtBQUssRUFBRWpDLFVBQVUsR0FBRztnQkFDbkM7Z0JBQ0EsT0FBTztvQkFBRThDLFFBQVE7Z0JBQVk7WUFDL0I7UUFDRixPQUFPO1lBQ0xuRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyw0QkFBNEIsRUFBRThGLE1BQU0sYUFBYSxDQUFDO1lBQy9ELE9BQU87Z0JBQUU1QixRQUFRO1lBQVk7UUFDL0I7SUFDRjtJQUVBLCtFQUErRTtJQUMvRSxJQUFJLENBQUNzQixxQkFBcUI7UUFDeEJ6RixRQUFRQyxHQUFHLENBQUMsQ0FBQyw2QkFBNkIsRUFBRThGLE1BQU0seUJBQXlCLENBQUM7UUFDNUUsT0FBTztZQUNMNUIsUUFBUTZCLFVBQVU3QixNQUFNO1lBQ3hCQyxRQUFRNEIsVUFBVTVCLE1BQU07WUFDeEJ0QixPQUFPa0QsVUFBVWxELEtBQUs7UUFDeEI7SUFDRjtJQUVBLG9EQUFvRDtJQUNwRCxNQUFNNEUsYUFBYTtJQUNuQixJQUFJQyxXQUFXO0lBRWYsTUFBT0EsV0FBV0QsV0FBWTtRQUM1QixJQUFJO1lBQ0YsTUFBTXhCLE9BQU90QixrQkFBa0JtQjtZQUMvQi9GLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHdCQUF3QixFQUFFOEYsTUFBTSxRQUFRLEVBQUVHLEtBQUsseUJBQXlCLEVBQUV5QixXQUFXLEVBQUUsQ0FBQyxDQUFDO1lBRXRHLE1BQU0sRUFBRTlFLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWYsU0FDM0JnQixJQUFJLENBQUMsUUFDTEMsTUFBTSxDQUFDLEtBQ1AwQixFQUFFLENBQUMsTUFBTXdCLE1BQ1R1QixXQUFXO1lBRWQsSUFBSTNFLE9BQU87Z0JBQ1Q5QyxRQUFROEMsS0FBSyxDQUFDLDhDQUE4QztvQkFDMURILFNBQVNHLE1BQU1ILE9BQU87b0JBQ3RCTyxNQUFNSixNQUFNSSxJQUFJO29CQUNoQkUsU0FBU04sTUFBTU0sT0FBTztvQkFDdEIyQztvQkFDQUc7b0JBQ0EwQixTQUFTRCxXQUFXO2dCQUN0QjtnQkFFQUE7Z0JBQ0EsSUFBSUEsV0FBV0QsWUFBWTtvQkFDekIsNkNBQTZDO29CQUM3QyxNQUFNLElBQUlHLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVMsTUFBTXhDLEtBQUswQyxHQUFHLENBQUMsR0FBR0w7b0JBQ25FO2dCQUNGO2dCQUVBLDJDQUEyQztnQkFDM0MzSCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUV5SCxXQUFXLGlFQUFpRSxDQUFDO2dCQUNoR2hDLG9CQUFvQjVDO2dCQUNwQixPQUFPO29CQUNMcUIsUUFBUTZCLFVBQVU3QixNQUFNO29CQUN4QkMsUUFBUTRCLFVBQVU1QixNQUFNO29CQUN4QnRCLE9BQU9rRCxVQUFVbEQsS0FBSztnQkFDeEI7WUFDRjtZQUVBLElBQUksQ0FBQ0QsTUFBTTtnQkFDVDdDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRThGLE1BQU0sNENBQTRDLENBQUM7Z0JBQ3RFLHVEQUF1RDtnQkFDdkQsT0FBTztvQkFDTDVCLFFBQVE2QixVQUFVN0IsTUFBTTtvQkFDeEJDLFFBQVE0QixVQUFVNUIsTUFBTTtvQkFDeEJ0QixPQUFPa0QsVUFBVWxELEtBQUs7Z0JBQ3hCO1lBQ0Y7WUFFQTlDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDJCQUEyQixFQUFFOEYsTUFBTSx1QkFBdUIsRUFBRWxELEtBQUtzQixNQUFNLENBQUMsQ0FBQztZQUV0Rix5Q0FBeUM7WUFDekN2QixZQUFZLENBQUNtRCxNQUFNLEdBQUc7Z0JBQ3BCN0IsSUFBSTZCO2dCQUNKNUIsUUFBUXRCLEtBQUtzQixNQUFNO2dCQUNuQkMsUUFBUXZCLEtBQUt1QixNQUFNO2dCQUNuQnRCLE9BQU9ELEtBQUtDLEtBQUs7Z0JBQ2pCdUIsWUFBWXhCLEtBQUt3QixVQUFVO2dCQUMzQkcsWUFBWTNCLEtBQUsyQixVQUFVO1lBQzdCO1lBRUEsT0FBTztnQkFDTEwsUUFBUXRCLEtBQUtzQixNQUFNO2dCQUNuQkMsUUFBUXZCLEtBQUt1QixNQUFNO2dCQUNuQnRCLE9BQU9ELEtBQUtDLEtBQUs7WUFDbkI7UUFDRixFQUFFLE9BQU9BLE9BQVk7WUFDbkI2RTtZQUNBM0gsUUFBUThDLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFNkUsU0FBUyxFQUFFLENBQUMsRUFBRTtnQkFDaEVoRixTQUFTRyxNQUFNSCxPQUFPO2dCQUN0QlcsT0FBT1IsTUFBTVEsS0FBSyxFQUFFakMsVUFBVSxHQUFHO2dCQUNqQzBFO2dCQUNBNkIsU0FBU0Q7WUFDWDtZQUVBLElBQUlBLFdBQVdELFlBQVk7Z0JBQ3pCLDZDQUE2QztnQkFDN0MsTUFBTSxJQUFJRyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTLE1BQU14QyxLQUFLMEMsR0FBRyxDQUFDLEdBQUdMO2dCQUNuRTtZQUNGO1lBRUEsNkNBQTZDO1lBQzdDakMsb0JBQW9CNUM7WUFDcEI5QyxRQUFRQyxHQUFHLENBQUMsQ0FBQyx1Q0FBdUMsRUFBRThGLE1BQU0sT0FBTyxFQUFFMkIsV0FBVyx5QkFBeUIsQ0FBQztZQUMxRyxPQUFPO2dCQUNMdkQsUUFBUTZCLFVBQVU3QixNQUFNO2dCQUN4QkMsUUFBUTRCLFVBQVU1QixNQUFNO2dCQUN4QnRCLE9BQU9rRCxVQUFVbEQsS0FBSztZQUN4QjtRQUNGO0lBQ0Y7SUFFQSx1RkFBdUY7SUFDdkY5QyxRQUFRQyxHQUFHLENBQUMsQ0FBQyx1REFBdUQsRUFBRThGLE1BQU0sQ0FBQztJQUM3RSxPQUFPO1FBQ0w1QixRQUFRNkIsVUFBVTdCLE1BQU07UUFDeEJDLFFBQVE0QixVQUFVNUIsTUFBTTtRQUN4QnRCLE9BQU9rRCxVQUFVbEQsS0FBSztJQUN4QjtBQUNGO0FBRUEsK0JBQStCO0FBQ3hCLGVBQWVtRixVQUFVbEMsS0FBYTtJQUMzQyx5QkFBeUI7SUFDekIsTUFBTUcsT0FBT3RCLGtCQUFrQm1CO0lBRS9CL0YsUUFBUUMsR0FBRyxDQUFDLENBQUMsYUFBYSxFQUFFOEYsTUFBTSxTQUFTLEVBQUVHLEtBQUssQ0FBQyxDQUFDO0lBRXBELHVEQUF1RDtJQUN2RHRELFlBQVksQ0FBQ21ELE1BQU0sR0FBRztRQUNwQjdCLElBQUk2QjtRQUNKNUIsUUFBUTtRQUNSSyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7SUFDcEM7SUFDQXZFLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRThGLE1BQU0sa0JBQWtCLENBQUM7SUFFNUMsc0VBQXNFO0lBQ3RFLElBQUksQ0FBQ04scUJBQXFCO1FBQ3hCekYsUUFBUUMsR0FBRyxDQUFDLENBQUMscUNBQXFDLEVBQUU4RixNQUFNLENBQUM7UUFDM0QsT0FBTztJQUNUO0lBRUEsSUFBSTtRQUNGL0YsUUFBUUMsR0FBRyxDQUFDLENBQUMsY0FBYyxFQUFFOEYsTUFBTSxjQUFjLENBQUM7UUFFbEQsc0NBQXNDO1FBQ3RDLE1BQU0sRUFBRWpELEtBQUssRUFBRSxHQUFHLE1BQU1mLFNBQ3JCZ0IsSUFBSSxDQUFDLFFBQ0xrQixNQUFNLENBQUM7WUFDTkMsSUFBSWdDO1lBQ0ovQixRQUFRO1lBQ1JFLFlBQVksSUFBSUMsT0FBT0MsV0FBVztZQUNsQ0MsWUFBWSxJQUFJRixPQUFPQyxXQUFXO1FBQ3BDO1FBRUYsSUFBSXpCLE9BQU87WUFDVDlDLFFBQVE4QyxLQUFLLENBQUMsQ0FBQyxtQkFBbUIsRUFBRWlELE1BQU0sYUFBYSxDQUFDLEVBQUU7Z0JBQ3hEcEQsU0FBU0csTUFBTUgsT0FBTztnQkFDdEJPLE1BQU1KLE1BQU1JLElBQUk7Z0JBQ2hCRSxTQUFTTixNQUFNTSxPQUFPO1lBQ3hCO1lBRUEsNkNBQTZDO1lBQzdDLElBQUlOLE1BQU1JLElBQUksS0FBSyxTQUFTO2dCQUMxQmxELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRThGLE1BQU0sb0RBQW9ELENBQUM7Z0JBRTlFLGdDQUFnQztnQkFDaEMsTUFBTSxFQUFFakQsT0FBT29GLFdBQVcsRUFBRSxHQUFHLE1BQU1uRyxTQUNsQ2dCLElBQUksQ0FBQyxRQUNMb0YsTUFBTSxDQUFDO29CQUNOaEUsUUFBUTtvQkFDUkssWUFBWSxJQUFJRixPQUFPQyxXQUFXO2dCQUNwQyxHQUNDRyxFQUFFLENBQUMsTUFBTXdCO2dCQUVaLElBQUlnQyxhQUFhO29CQUNmbEksUUFBUThDLEtBQUssQ0FBQyxDQUFDLDRCQUE0QixFQUFFaUQsTUFBTSxhQUFhLENBQUMsRUFBRW1DO29CQUNuRSxrREFBa0Q7b0JBQ2xEeEMsb0JBQW9Cd0M7b0JBQ3BCLE9BQU87Z0JBQ1QsT0FBTztvQkFDTGxJLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHlCQUF5QixFQUFFOEYsTUFBTSxZQUFZLENBQUM7b0JBQzNELE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLHlFQUF5RTtZQUN6RSxJQUFJakQsTUFBTUksSUFBSSxLQUFLLFNBQVM7Z0JBQzFCbEQsUUFBUUMsR0FBRyxDQUFDLENBQUMsbUNBQW1DLEVBQUU4RixNQUFNLENBQUM7Z0JBRXpELE1BQU0sRUFBRWpELE9BQU9zRixXQUFXLEVBQUUsR0FBRyxNQUFNckcsU0FDbENnQixJQUFJLENBQUMsUUFDTGtCLE1BQU0sQ0FBQztvQkFDTkMsSUFBSWdDO29CQUNKL0IsUUFBUTtnQkFDVjtnQkFFRixJQUFJaUUsYUFBYTtvQkFDZnBJLFFBQVE4QyxLQUFLLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRWlELE1BQU0sQ0FBQyxDQUFDLEVBQUVxQztvQkFDbkUxQyxvQkFBb0IwQztvQkFDcEIsT0FBTyxNQUFNLG1EQUFtRDtnQkFDbEUsT0FBTztvQkFDTHBJLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHNDQUFzQyxFQUFFOEYsTUFBTSxDQUFDO29CQUM1RCxPQUFPO2dCQUNUO1lBQ0Y7WUFFQSw0RUFBNEU7WUFDNUVMLG9CQUFvQjVDO1lBQ3BCLE9BQU8sTUFBTSxtREFBbUQ7UUFDbEU7UUFFQTlDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHlCQUF5QixFQUFFOEYsTUFBTSxZQUFZLENBQUM7UUFDM0QsT0FBTztJQUNULEVBQUUsT0FBT2pELE9BQVk7UUFDbkI5QyxRQUFROEMsS0FBSyxDQUFDLENBQUMsNkJBQTZCLEVBQUVpRCxNQUFNLENBQUMsQ0FBQyxFQUFFO1lBQ3REcEQsU0FBU0csTUFBTUgsT0FBTztZQUN0QlcsT0FBT1IsTUFBTVEsS0FBSyxFQUFFakMsVUFBVSxHQUFHO1FBQ25DO1FBRUEsMkVBQTJFO1FBQzNFcUUsb0JBQW9CNUM7UUFDcEIsT0FBTyxNQUFNLG1EQUFtRDtJQUNsRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Ly4vbGliL3N1cGFiYXNlLnRzP2M5OWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcblxuLy8gRXhwbGljaXRseSBsb2cgYWxsIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgZGVidWdnaW5nXG5jb25zb2xlLmxvZygnTk9ERV9FTlY6JywgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpO1xuY29uc29sZS5sb2coJ0Vudmlyb25tZW50IFZhcmlhYmxlcyBPdmVydmlldzonLCB7XG4gIGhhc1Byb2Nlc3NFbnY6IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAhIXByb2Nlc3MuZW52LFxuICBub2RlRW52OiBwcm9jZXNzLmVudi5OT0RFX0VOVixcbiAgaGFzU2JVcmw6ICdORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwnIGluIHByb2Nlc3MuZW52LFxuICBoYXNTYktleTogJ05FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZJyBpbiBwcm9jZXNzLmVudixcbiAgbmV4dENvbmZpZzogdHlwZW9mIHByb2Nlc3MuZW52Lk5FWFRfQ09ORklHX0FWQUlMQUJMRSA9PT0gJ3N0cmluZycsXG4gIGVudlZhckNvdW50OiBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnTkVYVF8nKSkubGVuZ3RoXG59KTtcblxuLy8gU3VwYWJhc2UgY2xpZW50IHNldHVwXG4vLyBEaXJlY3RseSBhY2Nlc3MgdmFyaWFibGVzIGZvciBkZWJ1Z2dpbmcgcmF0aGVyIHRoYW4gdXNpbmcgfHwgJycgcGF0dGVybiBpbml0aWFsbHlcbmxldCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbmxldCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcblxuLy8gRGVidWcgU3VwYWJhc2Ugc2V0dXAgd2l0aG91dCBleHBvc2luZyBrZXlzXG5jb25zb2xlLmxvZygnRGlyZWN0IFN1cGFiYXNlIFVSTDonLCBzdXBhYmFzZVVybD8uc3Vic3RyaW5nKDAsIDEyKSArICcuLi4nIHx8ICd1bmRlZmluZWQnKTtcbmNvbnNvbGUubG9nKCdEaXJlY3QgU3VwYWJhc2UgS2V5OicsIHN1cGFiYXNlQW5vbktleT8uc3Vic3RyaW5nKDAsIDYpICsgJy4uLicgfHwgJ3VuZGVmaW5lZCcpO1xuXG4vLyBGYWxsYmFjayB0byBlbXB0eSBzdHJpbmcgaWYgdW5kZWZpbmVkXG5zdXBhYmFzZVVybCA9IHN1cGFiYXNlVXJsIHx8ICcnO1xuc3VwYWJhc2VBbm9uS2V5ID0gc3VwYWJhc2VBbm9uS2V5IHx8ICcnO1xuXG4vLyBEZWJ1ZyBTdXBhYmFzZSBzZXR1cCB3aXRob3V0IGV4cG9zaW5nIGtleXNcbmNvbnNvbGUubG9nKCdTdXBhYmFzZSBjb25maWd1cmF0aW9uIGNoZWNrOicsIHtcbiAgaGFzVXJsOiBCb29sZWFuKHN1cGFiYXNlVXJsKSxcbiAgdXJsTGVuZ3RoOiBzdXBhYmFzZVVybD8ubGVuZ3RoIHx8IDAsXG4gIHVybFByZWZpeDogc3VwYWJhc2VVcmw/LnN1YnN0cmluZygwLCA4KSB8fCAnJyxcbiAgaGFzS2V5OiBCb29sZWFuKHN1cGFiYXNlQW5vbktleSksXG4gIGtleUxlbmd0aDogc3VwYWJhc2VBbm9uS2V5Py5sZW5ndGggfHwgMCxcbiAga2V5UHJlZml4OiBzdXBhYmFzZUFub25LZXk/LnN1YnN0cmluZygwLCA0KSB8fCAnJ1xufSk7XG5cbi8vIFR5cGUgZGVmaW5pdGlvbiBmb3Igam9iIGRhdGFcbmV4cG9ydCB0eXBlIEpvYkRhdGEgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHN0YXR1czogJ3F1ZXVlZCcgfCAncHJvY2Vzc2luZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xuICByZXN1bHQ/OiBhbnk7XG4gIGVycm9yPzogc3RyaW5nO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59O1xuXG4vLyBDaGVjayBpZiBTdXBhYmFzZSBpcyBjb25maWd1cmVkIHByb3Blcmx5XG5jb25zdCBpc1N1cGFiYXNlQ29uZmlndXJlZCA9IEJvb2xlYW4oc3VwYWJhc2VVcmwgJiYgc3VwYWJhc2VBbm9uS2V5KTtcblxuLy8gSW4tbWVtb3J5IHN0b3JlIHRvIHRyYWNrIGlmIFN1cGFiYXNlIGNvbm5lY3Rpdml0eSBmYWlsZWQgZHVyaW5nIHJ1bnRpbWVcbmxldCBzdXBhYmFzZURpc2FibGVkID0gZmFsc2U7XG5cbi8vIEluaXRpYWxpemUgdGhlIFN1cGFiYXNlIGNsaWVudCB3aXRoIGV4cGxpY2l0IG9wdGlvbnMgZm9yIGJldHRlciByZWxpYWJpbGl0eVxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gaXNTdXBhYmFzZUNvbmZpZ3VyZWRcbiAgPyBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRiOiB7XG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYydcbiAgICAgIH1cbiAgICB9KVxuICA6IGNyZWF0ZUNsaWVudCgnaHR0cHM6Ly9wbGFjZWhvbGRlci11cmwuc3VwYWJhc2UuY28nLCAncGxhY2Vob2xkZXIta2V5Jywge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuLy8gTG9nIGluaXRpYWxpemF0aW9uIHN0YXR1c1xuaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkge1xuICBjb25zb2xlLmxvZygnU3VwYWJhc2Ugbm90IHByb3Blcmx5IGNvbmZpZ3VyZWQuIFVzaW5nIGluLW1lbW9yeSBqb2Igc3RvcmFnZSBhcyBmYWxsYmFjay4nKTtcbn0gZWxzZSB7XG4gIGNvbnNvbGUubG9nKCdTdXBhYmFzZSBjbGllbnQgaW5pdGlhbGl6ZWQsIHZlcmlmeWluZyBjb25uZWN0aW9uLi4uJyk7XG4gIC8vIEF0dGVtcHQgdG8gdmVyaWZ5IGNvbm5lY3Rpb24gYW5kIGVuc3VyZSB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgdmVyaWZ5U3VwYWJhc2VDb25uZWN0aW9uKCkuY2F0Y2goZXJyID0+IHtcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB2ZXJpZnkgU3VwYWJhc2UgY29ubmVjdGlvbjonLCBlcnIubWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBJbi1tZW1vcnkgZmFsbGJhY2sgc3RvcmUgZm9yIGRldmVsb3BtZW50IG9yIHdoZW4gU3VwYWJhc2UgaXNuJ3QgY29uZmlndXJlZFxuY29uc3QgaW5NZW1vcnlKb2JzOiBSZWNvcmQ8c3RyaW5nLCBKb2JEYXRhPiA9IHt9O1xuXG4vLyBGdW5jdGlvbiB0byB2ZXJpZnkgdGhlIFN1cGFiYXNlIGNvbm5lY3Rpb25cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVN1cGFiYXNlQ29ubmVjdGlvbigpIHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB0byBkaXJlY3RseSBxdWVyeSBpZiB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAubGltaXQoMSk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAvLyBUYWJsZSBtaWdodCBub3QgZXhpc3RcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnNDJQMDEnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKb2JzIHRhYmxlIGRvZXMgbm90IGV4aXN0LCB3aWxsIGF0dGVtcHQgdG8gY3JlYXRlIGl0Jyk7XG4gICAgICAgIGF3YWl0IGVuc3VyZUpvYnNUYWJsZUV4aXN0cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgY29ubmVjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOicsIHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgZGV0YWlsczogZXJyb3IuZGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNvbm5lY3Rpb24gdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5LCBqb2JzIHRhYmxlIGV4aXN0cycpO1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgdGhlIHJpZ2h0IGNvbHVtbnNcbiAgICAgIGF3YWl0IGNoZWNrVGFibGVTdHJ1Y3R1cmUoZGF0YSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIFN1cGFiYXNlIGNvbm5lY3Rpb246Jywge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFjaz8uc3Vic3RyaW5nKDAsIDIwMClcbiAgICB9KTtcbiAgICBcbiAgICAvLyBJZiB0aGlzIGlzIGEgbmV0d29yayBlcnJvciwgZGlzYWJsZSBTdXBhYmFzZVxuICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZmV0Y2ggZmFpbGVkJykgfHwgXG4gICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCduZXR3b3JrIGVycm9yJykgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aW9uIGlzc3VlcycpO1xuICAgICAgc3VwYWJhc2VEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIENoZWNrIGFuZCBhZGFwdCB0byBleGlzdGluZyB0YWJsZSBzdHJ1Y3R1cmVcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrVGFibGVTdHJ1Y3R1cmUoc2FtcGxlRGF0YTogYW55W10pIHtcbiAgaWYgKHNhbXBsZURhdGEgJiYgc2FtcGxlRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgLy8gTG9nIHRoZSBzdHJ1Y3R1cmUgd2UgZm91bmQgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IGZpcnN0Um93ID0gc2FtcGxlRGF0YVswXTtcbiAgICBjb25zb2xlLmxvZygnRm91bmQgZXhpc3Rpbmcgam9icyB0YWJsZSB3aXRoIGNvbHVtbnM6JywgT2JqZWN0LmtleXMoZmlyc3RSb3cpLmpvaW4oJywgJykpO1xuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNoZWNrIGFuZCBjcmVhdGUgdGhlIGpvYnMgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdFxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlSm9ic1RhYmxlRXhpc3RzKCkge1xuICBpZiAoIWlzU3VwYWJhc2VDb25maWd1cmVkKSByZXR1cm47XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBqb2JzIHRhYmxlLi4uJyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBwZXJtaXNzaW9uIHRvIGV4ZWN1dGUgU1FMXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0LCB0cnkgdG8gY3JlYXRlIGEgc2ltcGxlIHRhYmxlIHdpdGggdGhlIG1pbmltdW0gcmVxdWlyZWQgZmllbGRzXG4gICAgICBjb25zdCBjcmVhdGVUYWJsZVNRTCA9IGBcbiAgICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgam9icyAoXG4gICAgICAgICAgaWQgQklHSU5UIFBSSU1BUlkgS0VZLFxuICAgICAgICAgIHN0YXR1cyBURVhULFxuICAgICAgICAgIHJlc3VsdCBKU09OQixcbiAgICAgICAgICBlcnJvciBURVhULFxuICAgICAgICAgIGNyZWF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKCksXG4gICAgICAgICAgdXBkYXRlZF9hdCBUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkUgREVGQVVMVCBOT1coKVxuICAgICAgICApO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3QgeyBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnZXhlY3V0ZV9zcWwnLCB7IHNxbDogY3JlYXRlVGFibGVTUUwgfSk7XG4gICAgICBcbiAgICAgIGlmIChjcmVhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGpvYnMgdGFibGUgdmlhIFNRTDonLCBjcmVhdGVFcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgYW4gYWx0ZXJuYXRpdmUgYXBwcm9hY2ggLSB1c2luZyB0aGUgaW5zZXJ0IEFQSVxuICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIHRvIGNyZWF0ZSBqb2JzIHRhYmxlIHZpYSBpbnNlcnQuLi4nKTtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICBzdGF0dXM6ICd0ZXN0JyxcbiAgICAgICAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICAgIC8vIElmIFN1cGFiYXNlIGRvZXNuJ3QgbGV0IHVzIGNyZWF0ZSB0aGUgdGFibGUsIGxvZyB3aGF0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgY3JlYXRlIGpvYnMgdGFibGUgYXV0b21hdGljYWxseTonLCBpbnNlcnRFcnJvcik7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUGxlYXNlIGNyZWF0ZSB0aGUgam9icyB0YWJsZSBtYW51YWxseSB3aXRoIHRoaXMgU1FMOicpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY3JlYXRlVGFibGVTUUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggaW5zZXJ0Jyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgdGVzdCByZWNvcmRcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdqb2JzJykuZGVsZXRlKCkuZXEoJ2lkJywgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggU1FMJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoc3FsRXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXhlY3V0aW5nIFNRTDonLCBzcWxFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnN1cmluZyBqb2JzIHRhYmxlIGV4aXN0czonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgZ3JhY2VmdWxseSwgd2UnbGwganVzdCB1c2UgaW4tbWVtb3J5IHN0b3JhZ2VcbiAgfVxufVxuXG4vLyBDb252ZXJ0IHN0cmluZyBJRCB0byBhIG51bWVyaWMgaGFzaCBpZiBuZWVkZWQgZm9yIFN1cGFiYXNlIGNvbXBhdGliaWxpdHlcbmZ1bmN0aW9uIGdldERiQ29tcGF0aWJsZUlkKGlkOiBzdHJpbmcpOiBudW1iZXIge1xuICAvLyBJZiB0aGUgSUQgaXMgYWxyZWFkeSBudW1lcmljLCByZXR1cm4gaXQgYXMgaXNcbiAgaWYgKCFpc05hTihOdW1iZXIoaWQpKSkge1xuICAgIHJldHVybiBOdW1iZXIoaWQpO1xuICB9XG4gIFxuICAvLyBGb3Igam9iIElEcyB0aGF0IHN0YXJ0IHdpdGggYSB0aW1lc3RhbXAgKGpvYl8gb3IgZGVidWdfKSwgZXh0cmFjdCB0aGUgdGltZXN0YW1wXG4gIC8vIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW50IElEIGdlbmVyYXRpb24gYWNyb3NzIGVudmlyb25tZW50c1xuICBjb25zdCB0aW1lc3RhbXBNYXRjaCA9IGlkLm1hdGNoKC9eKGpvYnxkZWJ1Z3x0ZXN0KV8oXFxkKykvKTtcbiAgaWYgKHRpbWVzdGFtcE1hdGNoICYmICFpc05hTihOdW1iZXIodGltZXN0YW1wTWF0Y2hbMl0pKSkge1xuICAgIC8vIFVzZSB0aGUgdGltZXN0YW1wIHBvcnRpb24gYXMgdGhlIG51bWVyaWMgSURcbiAgICByZXR1cm4gTnVtYmVyKHRpbWVzdGFtcE1hdGNoWzJdKTtcbiAgfVxuXG4gIC8vIEZvciBhbnkgb3RoZXIgSURzLCB1c2UgYSBoYXNoIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbnVtZXJpYyBJRFxuICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3Igbm9uLXN0YW5kYXJkIGpvYiBJRHNcbiAgbGV0IGhhc2ggPSAwO1xuICBjb25zdCBwcmltZSA9IDMxOyAvLyBVc2UgYSBwcmltZSBudW1iZXIgZm9yIGJldHRlciBkaXN0cmlidXRpb25cbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBHZXQgdGhlIGNoYXJhY3RlciBjb2RlXG4gICAgY29uc3QgY2hhciA9IGlkLmNoYXJDb2RlQXQoaSk7XG4gICAgLy8gTXVsdGlwbHkgdGhlIGN1cnJlbnQgaGFzaCBieSB0aGUgcHJpbWUgYW5kIGFkZCB0aGUgY2hhcmFjdGVyIGNvZGVcbiAgICBoYXNoID0gTWF0aC5pbXVsKGhhc2gsIHByaW1lKSArIGNoYXIgfCAwO1xuICB9XG4gIFxuICAvLyBFbnN1cmUgcG9zaXRpdmUgbnVtYmVyIGJ5IHVzaW5nIGFic29sdXRlIHZhbHVlIGFuZCBtYWtlIGl0IGxhcmdlIGVub3VnaCB0byBhdm9pZCBjb2xsaXNpb25zXG4gIHJldHVybiBNYXRoLmFicyhoYXNoKTtcbn1cblxuLy8gQ2hlY2sgaWYgU3VwYWJhc2Ugc2hvdWxkIGJlIHVzZWRcbmZ1bmN0aW9uIHNob3VsZFVzZVN1cGFiYXNlKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNTdXBhYmFzZUNvbmZpZ3VyZWQgJiYgIXN1cGFiYXNlRGlzYWJsZWQ7XG59XG5cbi8vIEhhbmRsZSBTdXBhYmFzZSBlcnJvcnMgY29uc2lzdGVudGx5XG5mdW5jdGlvbiBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgY29uc29sZS5lcnJvcignU3VwYWJhc2Ugb3BlcmF0aW9uIGZhaWxlZDonLCB7XG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgaGludDogZXJyb3IuaGludCxcbiAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgIGlzVHlwZUVycm9yOiBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvclxuICB9KTtcbiAgXG4gIC8vIElmIHdlIGdldCBhIGZldGNoIGVycm9yLCBkaXNhYmxlIFN1cGFiYXNlIGZvciB0aGlzIHNlc3Npb25cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIFxuICAgICAgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdmZXRjaCBmYWlsZWQnKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbmV0d29yayBlcnJvcicpKSkge1xuICAgIGNvbnNvbGUud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aXZpdHkgaXNzdWVzLiBVc2luZyBpbi1tZW1vcnkgc3RvcmFnZSBhcyBmYWxsYmFjay4nKTtcbiAgICBzdXBhYmFzZURpc2FibGVkID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSm9iU3RhdHVzKFxuICBqb2JJZDogc3RyaW5nLCBcbiAgc3RhdHVzOiBzdHJpbmcsIFxuICBkYXRhPzogeyByZXN1bHQ/OiBhbnk7IGVycm9yPzogc3RyaW5nIH1cbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAvLyBDcmVhdGUgaW4tbWVtb3J5IGZhbGxiYWNrIGVudHJ5XG4gIGNvbnN0IG1lbW9yeUpvYjogSm9iRGF0YSA9IHtcbiAgICBpZDogam9iSWQsXG4gICAgc3RhdHVzOiBzdGF0dXMgYXMgYW55LFxuICAgIHJlc3VsdDogZGF0YT8ucmVzdWx0IHx8IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogZGF0YT8uZXJyb3IgfHwgdW5kZWZpbmVkLFxuICAgIGNyZWF0ZWRfYXQ6IGluTWVtb3J5Sm9ic1tqb2JJZF0/LmNyZWF0ZWRfYXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuXG4gIC8vIFNhdmUgdG8gaW4tbWVtb3J5IHN0b3JlXG4gIGluTWVtb3J5Sm9ic1tqb2JJZF0gPSBtZW1vcnlKb2I7XG5cbiAgLy8gSWYgd2Ugc2hvdWxkbid0IHVzZSBTdXBhYmFzZSwgcmV0dXJuIGVhcmx5IHdpdGggc3VjY2Vzc1xuICBpZiAoIXNob3VsZFVzZVN1cGFiYXNlKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZGJJZCA9IGdldERiQ29tcGF0aWJsZUlkKGpvYklkKTtcbiAgICBcbiAgICAvLyBFbnN1cmUgcmVzdWx0IGlzIHByb3Blcmx5IHNlcmlhbGl6ZWQgYmVmb3JlIHNlbmRpbmcgdG8gU3VwYWJhc2VcbiAgICBsZXQgc2FmZVJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGRhdGE/LnJlc3VsdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTG9nIGNvb3JkaW5hdGVzIGJlZm9yZSBzZXJpYWxpemF0aW9uIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgaWYgKGRhdGEucmVzdWx0Py5pdGluZXJhcnk/LmRheXMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgY29vcmRpbmF0ZXMgYmVmb3JlIHNlcmlhbGl6YXRpb24uLi4nKTtcbiAgICAgICAgICBjb25zdCBkYXlzID0gZGF0YS5yZXN1bHQuaXRpbmVyYXJ5LmRheXM7XG4gICAgICAgICAgbGV0IGhhc0Nvb3JkaW5hdGVJc3N1ZXMgPSBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IGRheXNbaV07XG4gICAgICAgICAgICBpZiAoZGF5LmFjdGl2aXRpZXMgJiYgQXJyYXkuaXNBcnJheShkYXkuYWN0aXZpdGllcykpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXkuYWN0aXZpdGllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2aXR5ID0gZGF5LmFjdGl2aXRpZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpdml0eS5jb29yZGluYXRlcyB8fCB0eXBlb2YgYWN0aXZpdHkuY29vcmRpbmF0ZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBNaXNzaW5nIGNvb3JkaW5hdGVzIGluIGRheSAke2l9LCBhY3Rpdml0eSAke2p9OiAke2FjdGl2aXR5LnRpdGxlfWApO1xuICAgICAgICAgICAgICAgICAgaGFzQ29vcmRpbmF0ZUlzc3VlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpdml0eS5jb29yZGluYXRlcy5sYXQgPT09IHVuZGVmaW5lZCB8fCBhY3Rpdml0eS5jb29yZGluYXRlcy5sbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbmNvbXBsZXRlIGNvb3JkaW5hdGVzIGluIGRheSAke2l9LCBhY3Rpdml0eSAke2p9OiAke0pTT04uc3RyaW5naWZ5KGFjdGl2aXR5LmNvb3JkaW5hdGVzKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29vcmRpbmF0ZUlzc3VlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaGFzQ29vcmRpbmF0ZUlzc3Vlcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FsbCBjb29yZGluYXRlcyBsb29rIHZhbGlkIGJlZm9yZSBzZXJpYWxpemF0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUZXN0IHNlcmlhbGl6YXRpb24gZmlyc3QgdG8gY2F0Y2ggYW55IGlzc3Vlc1xuICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhLnJlc3VsdCk7XG4gICAgICAgIHNhZmVSZXN1bHQgPSBkYXRhLnJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlcmlhbGl6ZSBqb2IgcmVzdWx0IHRvIEpTT046JywgZSk7XG4gICAgICAgIHNhZmVSZXN1bHQgPSB7IGVycm9yOiAnUmVzdWx0IGNvbnRhaW5lZCB1bnNlcmlhbGl6YWJsZSBkYXRhJyB9O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgam9iICR7am9iSWR9IChkYklkOiAke2RiSWR9KSBzdGF0dXMgdG8gJHtzdGF0dXN9YCk7XG4gICAgXG4gICAgLy8gRmlyc3QsIGdldCB0aGUgY3VycmVudCBqb2IgdG8gcHJlc2VydmUgY3JlYXRlZF9hdFxuICAgIGxldCBjcmVhdGVkX2F0ID0gbWVtb3J5Sm9iLmNyZWF0ZWRfYXQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdKb2IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdqb2JzJylcbiAgICAgICAgLnNlbGVjdCgnY3JlYXRlZF9hdCcpXG4gICAgICAgIC5lcSgnaWQnLCBkYklkKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ0pvYj8uY3JlYXRlZF9hdCkge1xuICAgICAgICBjcmVhdGVkX2F0ID0gZXhpc3RpbmdKb2IuY3JlYXRlZF9hdDtcbiAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIGV4aXN0aW5nIGNyZWF0ZWRfYXQgdGltZXN0YW1wOiAke2NyZWF0ZWRfYXR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgTm8gZXhpc3RpbmcgY3JlYXRlZF9hdCBmb3VuZCwgdXNpbmcgZGVmYXVsdCBjcmVhdGVkX2F0OiAke2NyZWF0ZWRfYXR9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgQ291bGQgbm90IGZldGNoIGV4aXN0aW5nIGpvYiwgdXNpbmcgZGVmYXVsdCBjcmVhdGVkX2F0OiAke2NyZWF0ZWRfYXR9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIE5vdyB1cGRhdGUgd2l0aCB0aGUgcHJlc2VydmVkIGNyZWF0ZWRfYXRcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgLnVwc2VydCh7XG4gICAgICAgIGlkOiBkYklkLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHJlc3VsdDogc2FmZVJlc3VsdCxcbiAgICAgICAgZXJyb3I6IGRhdGE/LmVycm9yIHx8IG51bGwsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IGNyZWF0ZWRfYXQsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAnaWQnXG4gICAgICB9KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgam9iIHN0YXR1cyBpbiBTdXBhYmFzZTonLCB7XG4gICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IGVycm9yLmRldGFpbHMsXG4gICAgICAgIGpvYklkLFxuICAgICAgICBkYklkLFxuICAgICAgICBzdGF0dXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgam9iICR7am9iSWR9IGluIFN1cGFiYXNlYCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG4gIFxuICAvLyBBbHdheXMgcmV0dXJuIHRydWUgc2luY2Ugd2Ugc2F2ZWQgdG8gaW4tbWVtb3J5IHN0b3JhZ2VcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEdldCB0aGUgc3RhdHVzIG9mIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iU3RhdHVzKGpvYklkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IHJlc3VsdD86IGFueTsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAvLyBFbmhhbmNlZCBsb2dnaW5nIGZvciB0cm91Ymxlc2hvb3RpbmdcbiAgY29uc29sZS5sb2coYD09PT09PT09PT0gSk9CIFNUQVRVUyBDSEVDSyA9PT09PT09PT09YCk7XG4gIGNvbnNvbGUubG9nKGBnZXRKb2JTdGF0dXMgY2FsbGVkIGZvciBqb2I6ICR7am9iSWR9YCk7XG4gIGNvbnNvbGUubG9nKGBFbnZpcm9ubWVudDogJHtwcm9jZXNzLmVudi5OT0RFX0VOVn1gKTtcbiAgY29uc29sZS5sb2coYFN1cGFiYXNlIGNvbmZpZ3VyZWQ6ICR7aXNTdXBhYmFzZUNvbmZpZ3VyZWR9YCk7XG4gIGNvbnNvbGUubG9nKGBTdXBhYmFzZSBkaXNhYmxlZCBmbGFnOiAke3N1cGFiYXNlRGlzYWJsZWR9YCk7XG4gIGNvbnNvbGUubG9nKGBzaG91bGRVc2VTdXBhYmFzZSgpOiAke3Nob3VsZFVzZVN1cGFiYXNlKCl9YCk7XG4gIFxuICAvLyBDaGVjayBpbi1tZW1vcnkgc3RvcmFnZSBmaXJzdFxuICBjb25zdCBtZW1vcnlKb2IgPSBpbk1lbW9yeUpvYnNbam9iSWRdO1xuICBcbiAgLy8gTG9nIGluLW1lbW9yeSBqb2Igc3RhdHVzXG4gIGNvbnNvbGUubG9nKGBJbi1tZW1vcnkgam9iIHN0YXR1cyBmb3IgJHtqb2JJZH06ICR7bWVtb3J5Sm9iID8gbWVtb3J5Sm9iLnN0YXR1cyA6ICdub3QgZm91bmQnfWApO1xuICBjb25zb2xlLmxvZyhgSW4tbWVtb3J5IGpvYnMgY291bnQ6ICR7T2JqZWN0LmtleXMoaW5NZW1vcnlKb2JzKS5sZW5ndGh9YCk7XG4gIGNvbnNvbGUubG9nKGBBbGwgaW4tbWVtb3J5IGpvYiBJRHM6ICR7T2JqZWN0LmtleXMoaW5NZW1vcnlKb2JzKS5qb2luKCcsICcpLnN1YnN0cmluZygwLCAyMDApfWApO1xuICBcbiAgLy8gTm90IGV2ZW4gaW4gbWVtb3J5XG4gIGlmICghbWVtb3J5Sm9iKSB7XG4gICAgY29uc29sZS5sb2coYEpvYiAke2pvYklkfSBub3QgZm91bmQgaW4gbWVtb3J5LCB3aWxsIGNoZWNrIFN1cGFiYXNlIGlmIGF2YWlsYWJsZWApO1xuICAgIFxuICAgIC8vIElmIFN1cGFiYXNlIGlzIHByb3Blcmx5IGNvbmZpZ3VyZWQgYW5kIG5vdCBkaXNhYmxlZCwgdHJ5IHRvIGZldGNoIGZyb20gdGhlcmVcbiAgICBpZiAoc2hvdWxkVXNlU3VwYWJhc2UoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGJJZCA9IGdldERiQ29tcGF0aWJsZUlkKGpvYklkKTtcbiAgICAgICAgY29uc29sZS5sb2coYENoZWNraW5nIFN1cGFiYXNlIGZvciBqb2IgJHtqb2JJZH0gKERCIElEOiAke2RiSWR9KWApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnam9icycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgLmVxKCdpZCcsIGRiSWQpXG4gICAgICAgICAgLm1heWJlU2luZ2xlKCk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN1cGFiYXNlIGVycm9yIGNoZWNraW5nIGZvciBqb2IgJHtqb2JJZH06YCwge1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnbm90X2ZvdW5kJyB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IG5vdCBmb3VuZCBpbiBTdXBhYmFzZSBlaXRoZXJgKTtcbiAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdub3RfZm91bmQnIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBqb2IgJHtqb2JJZH0gaW4gU3VwYWJhc2Ugd2l0aCBzdGF0dXM6ICR7ZGF0YS5zdGF0dXN9YCk7XG4gICAgICAgIC8vIFN0b3JlIGluIG1lbW9yeSBmb3IgZnV0dXJlIHF1aWNrIGFjY2Vzc1xuICAgICAgICBpbk1lbW9yeUpvYnNbam9iSWRdID0ge1xuICAgICAgICAgIGlkOiBqb2JJZCxcbiAgICAgICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICAgIHJlc3VsdDogZGF0YS5yZXN1bHQsXG4gICAgICAgICAgZXJyb3I6IGRhdGEuZXJyb3IsXG4gICAgICAgICAgY3JlYXRlZF9hdDogZGF0YS5jcmVhdGVkX2F0LFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IGRhdGEudXBkYXRlZF9hdFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICAgIHJlc3VsdDogZGF0YS5yZXN1bHQsXG4gICAgICAgICAgZXJyb3I6IGRhdGEuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXhjZXB0aW9uIGNoZWNraW5nIFN1cGFiYXNlIGZvciBqb2IgJHtqb2JJZH06YCwge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrPy5zdWJzdHJpbmcoMCwgMjAwKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnbm90X2ZvdW5kJyB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VwYWJhc2Ugbm90IGF2YWlsYWJsZSwgam9iICR7am9iSWR9IGlzIG5vdCBmb3VuZGApO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnbm90X2ZvdW5kJyB9O1xuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgU3VwYWJhc2UgaXMgZGlzYWJsZWQgb3IgaW1wcm9wZXJseSBjb25maWd1cmVkLCBvbmx5IHVzZSBpbi1tZW1vcnkgc3RvcmFnZVxuICBpZiAoIXNob3VsZFVzZVN1cGFiYXNlKCkpIHtcbiAgICBjb25zb2xlLmxvZyhgVXNpbmcgaW4tbWVtb3J5IGRhdGEgZm9yIGpvYiAke2pvYklkfSAoU3VwYWJhc2Ugbm90IGF2YWlsYWJsZSlgKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBtZW1vcnlKb2Iuc3RhdHVzLFxuICAgICAgcmVzdWx0OiBtZW1vcnlKb2IucmVzdWx0LFxuICAgICAgZXJyb3I6IG1lbW9yeUpvYi5lcnJvclxuICAgIH07XG4gIH1cbiAgXG4gIC8vIEFkZCByZXRyeSBsb2dpYyBmb3IgZmV0Y2hpbmcgc3RhdHVzIGZyb20gU3VwYWJhc2VcbiAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gIGxldCBhdHRlbXB0cyA9IDA7XG4gIFxuICB3aGlsZSAoYXR0ZW1wdHMgPCBtYXhSZXRyaWVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiSWQgPSBnZXREYkNvbXBhdGlibGVJZChqb2JJZCk7XG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgam9iIHN0YXR1cyBmb3IgJHtqb2JJZH0gKGRiSWQ6ICR7ZGJJZH0pIGZyb20gU3VwYWJhc2UgKGF0dGVtcHQgJHthdHRlbXB0cyArIDF9KWApO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnam9icycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgZGJJZClcbiAgICAgICAgLm1heWJlU2luZ2xlKCk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGpvYiBzdGF0dXMgZnJvbSBTdXBhYmFzZTonLCB7XG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgIGRldGFpbHM6IGVycm9yLmRldGFpbHMsXG4gICAgICAgICAgam9iSWQsXG4gICAgICAgICAgZGJJZCxcbiAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0cyArIDFcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICBpZiAoYXR0ZW1wdHMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCAqIE1hdGgucG93KDIsIGF0dGVtcHRzKSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gaW4tbWVtb3J5IGFmdGVyIGFsbCByZXRyaWVzXG4gICAgICAgIGNvbnNvbGUubG9nKGBBbGwgJHttYXhSZXRyaWVzfSBhdHRlbXB0cyB0byBmZXRjaCBqb2IgZnJvbSBTdXBhYmFzZSBmYWlsZWQsIHVzaW5nIGluLW1lbW9yeSBkYXRhYCk7XG4gICAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbWVtb3J5Sm9iLnN0YXR1cyxcbiAgICAgICAgICByZXN1bHQ6IG1lbW9yeUpvYi5yZXN1bHQsXG4gICAgICAgICAgZXJyb3I6IG1lbW9yeUpvYi5lcnJvclxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEpvYiAke2pvYklkfSBub3QgZm91bmQgaW4gU3VwYWJhc2UsIHVzaW5nIGluLW1lbW9yeSBkYXRhYCk7XG4gICAgICAgIC8vIE5vdCBmb3VuZCBpbiBEQiBidXQgaW4gbWVtb3J5LCByZXR1cm4gbWVtb3J5IHZlcnNpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IG1lbW9yeUpvYi5zdGF0dXMsXG4gICAgICAgICAgcmVzdWx0OiBtZW1vcnlKb2IucmVzdWx0LFxuICAgICAgICAgIGVycm9yOiBtZW1vcnlKb2IuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgam9iICR7am9iSWR9IHN0YXR1cyBmcm9tIFN1cGFiYXNlOiAke2RhdGEuc3RhdHVzfWApO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgaW4tbWVtb3J5IHN0b3JlIHRvIGtlZXAgaW4gc3luY1xuICAgICAgaW5NZW1vcnlKb2JzW2pvYklkXSA9IHtcbiAgICAgICAgaWQ6IGpvYklkLFxuICAgICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICByZXN1bHQ6IGRhdGEucmVzdWx0LFxuICAgICAgICBlcnJvcjogZGF0YS5lcnJvcixcbiAgICAgICAgY3JlYXRlZF9hdDogZGF0YS5jcmVhdGVkX2F0LFxuICAgICAgICB1cGRhdGVkX2F0OiBkYXRhLnVwZGF0ZWRfYXRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogZGF0YS5zdGF0dXMsXG4gICAgICAgIHJlc3VsdDogZGF0YS5yZXN1bHQsXG4gICAgICAgIGVycm9yOiBkYXRhLmVycm9yXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGF0dGVtcHRzKys7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBqb2Igc3RhdHVzIChhdHRlbXB0ICR7YXR0ZW1wdHN9KTpgLCB7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFjaz8uc3Vic3RyaW5nKDAsIDIwMCksXG4gICAgICAgIGpvYklkLFxuICAgICAgICBhdHRlbXB0OiBhdHRlbXB0c1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChhdHRlbXB0cyA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0cykpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFsbCByZXRyaWVzIGZhaWxlZCwgZmFsbCBiYWNrIHRvIGluLW1lbW9yeVxuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgICBjb25zb2xlLmxvZyhgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBkYXRhIGZvciBqb2IgJHtqb2JJZH0gYWZ0ZXIgJHttYXhSZXRyaWVzfSBmYWlsZWQgU3VwYWJhc2UgYXR0ZW1wdHNgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbWVtb3J5Sm9iLnN0YXR1cyxcbiAgICAgICAgcmVzdWx0OiBtZW1vcnlKb2IucmVzdWx0LFxuICAgICAgICBlcnJvcjogbWVtb3J5Sm9iLmVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgYmUgcmVhY2hlZCBkdWUgdG8gdGhlIHJldHVybnMgaW4gdGhlIGxvb3AsIGJ1dCBUeXBlU2NyaXB0IG5lZWRzIGl0XG4gIGNvbnNvbGUubG9nKGBDb2RlIHJlYWNoZWQgdW5yZWFjaGFibGUgcG9pbnQgaW4gZ2V0Sm9iU3RhdHVzIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IG1lbW9yeUpvYi5zdGF0dXMsXG4gICAgcmVzdWx0OiBtZW1vcnlKb2IucmVzdWx0LFxuICAgIGVycm9yOiBtZW1vcnlKb2IuZXJyb3JcbiAgfTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IGpvYlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUpvYihqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIC8vIEdldCBhIERCLWNvbXBhdGlibGUgSURcbiAgY29uc3QgZGJJZCA9IGdldERiQ29tcGF0aWJsZUlkKGpvYklkKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBDcmVhdGluZyBqb2IgJHtqb2JJZH0gKERCIElEOiAke2RiSWR9KWApO1xuICBcbiAgLy8gQWx3YXlzIGNyZWF0ZSB0aGUgam9iIGluIG1lbW9yeSBmaXJzdCBmb3IgcmVkdW5kYW5jeVxuICBpbk1lbW9yeUpvYnNbam9iSWRdID0ge1xuICAgIGlkOiBqb2JJZCxcbiAgICBzdGF0dXM6ICdxdWV1ZWQnLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IGNyZWF0ZWQgaW4gbWVtb3J5YCk7XG4gIFxuICAvLyBJZiBTdXBhYmFzZSBpcyBkaXNhYmxlZCwganVzdCByZXR1cm4gc3VjY2VzcyBmcm9tIGluLW1lbW9yeSBzdG9yYWdlXG4gIGlmICghc2hvdWxkVXNlU3VwYWJhc2UoKSkge1xuICAgIGNvbnNvbGUubG9nKGBVc2luZyBpbi1tZW1vcnkgc3RvcmFnZSBvbmx5IGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgSW5zZXJ0aW5nIGpvYiAke2pvYklkfSBpbnRvIFN1cGFiYXNlYCk7XG4gICAgXG4gICAgLy8gVHJ5IHRvIGluc2VydCB0aGUgam9iIGludG8gU3VwYWJhc2VcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIGlkOiBkYklkLFxuICAgICAgICBzdGF0dXM6ICdxdWV1ZWQnLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBqb2IgJHtqb2JJZH0gaW4gU3VwYWJhc2U6YCwge1xuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRm9yIGNvbmZsaWN0cywgdGhlIGpvYiBtaWdodCBhbHJlYWR5IGV4aXN0XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJzIzNTA1Jykge1xuICAgICAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IGFscmVhZHkgZXhpc3RzIGluIFN1cGFiYXNlLCB1cGRhdGluZyBzdGF0dXMgaW5zdGVhZGApO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgam9iIGluc3RlYWRcbiAgICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgc3RhdHVzOiAncXVldWVkJyxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIGRiSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgZXhpc3Rpbmcgam9iICR7am9iSWR9IGluIFN1cGFiYXNlOmAsIHVwZGF0ZUVycm9yKTtcbiAgICAgICAgICAvLyBFdmVuIGlmIHVwZGF0ZSBmYWlscywgd2UgaGF2ZSB0aGUgam9iIGluIG1lbW9yeVxuICAgICAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IodXBkYXRlRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgdXBkYXRlZCBqb2IgJHtqb2JJZH0gaW4gU3VwYWJhc2VgKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGb3IgZm9yZWlnbiBrZXkgY29uc3RyYWludCBmYWlsdXJlcywgdHJ5IHRvIGNyZWF0ZSB3aXRoIG1pbmltYWwgZmllbGRzXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJzIzNTAzJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgVHJ5aW5nIHNpbXBsaWZpZWQgam9iIGNyZWF0aW9uIGZvciAke2pvYklkfWApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBlcnJvcjogc2ltcGxlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgaWQ6IGRiSWQsXG4gICAgICAgICAgICBzdGF0dXM6ICdxdWV1ZWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2ltcGxlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBTaW1wbGlmaWVkIGpvYiBjcmVhdGlvbiBhbHNvIGZhaWxlZCBmb3IgJHtqb2JJZH06YCwgc2ltcGxlRXJyb3IpO1xuICAgICAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3Ioc2ltcGxlRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBTdGlsbCByZXR1cm4gdHJ1ZSBzaW5jZSB3ZSBoYXZlIGluLW1lbW9yeSBiYWNrdXBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2ltcGxpZmllZCBqb2IgY3JlYXRpb24gc3VjY2VlZGVkIGZvciAke2pvYklkfWApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciBvdGhlciBlcnJvcnMsIGhhbmRsZSBncmFjZWZ1bGx5IGFuZCB1c2UgaW4tbWVtb3J5IHN0b3JhZ2UgYXMgZmFsbGJhY2tcbiAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFN0aWxsIHJldHVybiB0cnVlIHNpbmNlIHdlIGhhdmUgaW4tbWVtb3J5IGJhY2t1cFxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgam9iICR7am9iSWR9IGluIFN1cGFiYXNlYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFeGNlcHRpb24gd2hpbGUgY3JlYXRpbmcgam9iICR7am9iSWR9OmAsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBzdGFjazogZXJyb3Iuc3RhY2s/LnN1YnN0cmluZygwLCAyMDApXG4gICAgfSk7XG4gICAgXG4gICAgLy8gSW4gY2FzZSBvZiBuZXR3b3JrIG9yIG90aGVyIGV4Y2VwdGlvbiwgd2UgYWxyZWFkeSBoYXZlIHRoZSBqb2IgaW4gbWVtb3J5XG4gICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHRydWU7IC8vIFN0aWxsIHJldHVybiB0cnVlIHNpbmNlIHdlIGhhdmUgaW4tbWVtb3J5IGJhY2t1cFxuICB9XG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjb25zb2xlIiwibG9nIiwiaGFzUHJvY2Vzc0VudiIsInByb2Nlc3MiLCJlbnYiLCJub2RlRW52IiwiaGFzU2JVcmwiLCJoYXNTYktleSIsIm5leHRDb25maWciLCJORVhUX0NPTkZJR19BVkFJTEFCTEUiLCJlbnZWYXJDb3VudCIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJzdGFydHNXaXRoIiwibGVuZ3RoIiwic3VwYWJhc2VVcmwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1YnN0cmluZyIsImhhc1VybCIsIkJvb2xlYW4iLCJ1cmxMZW5ndGgiLCJ1cmxQcmVmaXgiLCJoYXNLZXkiLCJrZXlMZW5ndGgiLCJrZXlQcmVmaXgiLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsInN1cGFiYXNlRGlzYWJsZWQiLCJzdXBhYmFzZSIsImF1dGgiLCJwZXJzaXN0U2Vzc2lvbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJnbG9iYWwiLCJoZWFkZXJzIiwiZGIiLCJzY2hlbWEiLCJ2ZXJpZnlTdXBhYmFzZUNvbm5lY3Rpb24iLCJjYXRjaCIsImVyciIsIndhcm4iLCJtZXNzYWdlIiwiaW5NZW1vcnlKb2JzIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwiY29kZSIsImVuc3VyZUpvYnNUYWJsZUV4aXN0cyIsImRldGFpbHMiLCJjaGVja1RhYmxlU3RydWN0dXJlIiwic3RhY2siLCJpbmNsdWRlcyIsIlR5cGVFcnJvciIsInNhbXBsZURhdGEiLCJmaXJzdFJvdyIsImpvaW4iLCJjcmVhdGVUYWJsZVNRTCIsImNyZWF0ZUVycm9yIiwicnBjIiwic3FsIiwiaW5zZXJ0RXJyb3IiLCJpbnNlcnQiLCJpZCIsInN0YXR1cyIsInJlc3VsdCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlIiwiZXEiLCJzcWxFcnJvciIsImdldERiQ29tcGF0aWJsZUlkIiwiaXNOYU4iLCJOdW1iZXIiLCJ0aW1lc3RhbXBNYXRjaCIsIm1hdGNoIiwiaGFzaCIsInByaW1lIiwiaSIsImNoYXIiLCJjaGFyQ29kZUF0IiwiTWF0aCIsImltdWwiLCJhYnMiLCJzaG91bGRVc2VTdXBhYmFzZSIsImhhbmRsZVN1cGFiYXNlRXJyb3IiLCJuYW1lIiwiaGludCIsImlzVHlwZUVycm9yIiwidXBkYXRlSm9iU3RhdHVzIiwiam9iSWQiLCJtZW1vcnlKb2IiLCJ1bmRlZmluZWQiLCJkYklkIiwic2FmZVJlc3VsdCIsIml0aW5lcmFyeSIsImRheXMiLCJoYXNDb29yZGluYXRlSXNzdWVzIiwiZGF5IiwiYWN0aXZpdGllcyIsIkFycmF5IiwiaXNBcnJheSIsImoiLCJhY3Rpdml0eSIsImNvb3JkaW5hdGVzIiwidGl0bGUiLCJsYXQiLCJsbmciLCJKU09OIiwic3RyaW5naWZ5IiwiZSIsImV4aXN0aW5nSm9iIiwic2luZ2xlIiwidXBzZXJ0Iiwib25Db25mbGljdCIsImdldEpvYlN0YXR1cyIsIm1heWJlU2luZ2xlIiwibWF4UmV0cmllcyIsImF0dGVtcHRzIiwiYXR0ZW1wdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInBvdyIsImNyZWF0ZUpvYiIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwic2ltcGxlRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();