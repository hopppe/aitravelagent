"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/generate-itinerary/route";
exports.ids = ["app/api/generate-itinerary/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_ethanhoppe_Desktop_AItravelagent_app_api_generate_itinerary_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/generate-itinerary/route.ts */ \"(rsc)/./app/api/generate-itinerary/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/generate-itinerary/route\",\n        pathname: \"/api/generate-itinerary\",\n        filename: \"route\",\n        bundlePath: \"app/api/generate-itinerary/route\"\n    },\n    resolvedPagePath: \"/Users/ethanhoppe/Desktop/AItravelagent/app/api/generate-itinerary/route.ts\",\n    nextConfigOutput,\n    userland: _Users_ethanhoppe_Desktop_AItravelagent_app_api_generate_itinerary_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/generate-itinerary/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZnZW5lcmF0ZS1pdGluZXJhcnklMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmdlbmVyYXRlLWl0aW5lcmFyeSUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmdlbmVyYXRlLWl0aW5lcmFyeSUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmV0aGFuaG9wcGUlMkZEZXNrdG9wJTJGQUl0cmF2ZWxhZ2VudCUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZldGhhbmhvcHBlJTJGRGVza3RvcCUyRkFJdHJhdmVsYWdlbnQmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQzJCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Lz80Y2UyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi9Vc2Vycy9ldGhhbmhvcHBlL0Rlc2t0b3AvQUl0cmF2ZWxhZ2VudC9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZ2VuZXJhdGUtaXRpbmVyYXJ5L3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZ2VuZXJhdGUtaXRpbmVyYXJ5XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9nZW5lcmF0ZS1pdGluZXJhcnkvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvZXRoYW5ob3BwZS9EZXNrdG9wL0FJdHJhdmVsYWdlbnQvYXBwL2FwaS9nZW5lcmF0ZS1pdGluZXJhcnkvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/generate-itinerary/route.ts":
/*!*********************************************!*\
  !*** ./app/api/generate-itinerary/route.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   maxDuration: () => (/* binding */ maxDuration),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _job_processor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../job-processor */ \"(rsc)/./app/api/job-processor.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n\n\n\n// Configure runtime for serverless function\nconst runtime = \"nodejs\";\nconst maxDuration = 60; // Set max duration to 60 seconds\n// Use API key from environment variables\nconst OPENAI_API_KEY = process.env.OPENAI_API_KEY || \"\";\n// Check if running in production environment\nconst isProduction = \"development\" === \"production\";\n// Check if Supabase is properly configured\nconst isSupabaseConfigured = Boolean( true && \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\");\nasync function POST(request) {\n    try {\n        // Log key information for debugging\n        console.log(`API Request started: ${new Date().toISOString()}`);\n        console.log(\"Environment:\", {\n            nodeEnv: \"development\",\n            isProduction\n        });\n        // Log environment variables (without exposing actual values)\n        console.log(\"Supabase connection check:\", {\n            hasSupabaseUrl: !!\"https://toaiekqwflojwicejvne.supabase.co\",\n            hasSupabaseKey: !!\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\",\n            urlLength: \"https://toaiekqwflojwicejvne.supabase.co\"?.length || 0,\n            keyLength: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\"?.length || 0\n        });\n        // Only test Supabase connection if properly configured\n        if (isSupabaseConfigured) {\n            try {\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"jobs\").select(\"count\").limit(1);\n                if (error) {\n                    console.error(\"Supabase connection test failed:\", {\n                        message: error.message,\n                        hint: error.hint || \"\",\n                        code: error.code || \"\"\n                    });\n                // Continue execution despite connection error\n                // The job will be stored in memory\n                } else {\n                    console.log(\"Supabase connection test successful:\", data);\n                }\n            } catch (connError) {\n                console.error(\"Supabase connection test exception:\", {\n                    message: connError.message,\n                    details: connError.toString(),\n                    hint: \"\",\n                    code: \"\"\n                });\n            // Continue execution despite connection error\n            // The job will be stored in memory\n            }\n        } else {\n            console.log(\"Skipping Supabase connection test - not configured\");\n        }\n        // Parse the request body\n        const surveyData = await request.json();\n        console.log(\"Received survey data:\", {\n            destination: surveyData.destination,\n            startDate: surveyData.startDate,\n            endDate: surveyData.endDate,\n            purpose: surveyData.purpose,\n            budget: surveyData.budget,\n            preferences: surveyData.preferences\n        });\n        // Create a unique job ID\n        const jobId = (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.generateJobId)();\n        console.log(`Generated new job ID: ${jobId}`);\n        // If we're in development or testing, return mock data immediately\n        if ( true && !OPENAI_API_KEY.startsWith(\"sk-\")) {\n            console.log(\"Development mode: Returning mock data\");\n            const mockItinerary = createMockItinerary(surveyData);\n            const updateResult = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"completed\", {\n                result: {\n                    itinerary: mockItinerary,\n                    prompt: generatePrompt(surveyData)\n                }\n            });\n            if (!updateResult) {\n                console.error(\"Failed to update job status in development mode\");\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Failed to update job status\"\n                }, {\n                    status: 500\n                });\n            }\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                jobId,\n                status: \"completed\"\n            });\n        }\n        // Create a new job\n        console.log(\"Creating new job with ID:\", jobId);\n        const jobCreated = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createJob)(jobId);\n        if (!jobCreated) {\n            console.error(\"Failed to create job\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to create job in database\"\n            }, {\n                status: 500\n            });\n        }\n        console.log(`Job ${jobId} created successfully, current status: queued`);\n        // Verify the job was created properly by fetching its status\n        try {\n            const statusCheck = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.getJobStatus)(jobId);\n            console.log(`Initial job status check: ${statusCheck.status}`);\n            if (statusCheck.status === \"not_found\") {\n                console.error(`Critical error: Job ${jobId} was not found immediately after creation`);\n            }\n        } catch (statusCheckError) {\n            console.error(\"Error checking initial job status:\", statusCheckError);\n        }\n        // In production or when immediate request handling is needed, process synchronously\n        if (isProduction) {\n            console.log(`Running in production mode for job ${jobId}`);\n            // Update status to processing and immediately return response\n            const statusUpdateSuccess = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"processing\");\n            if (!statusUpdateSuccess) {\n                console.error(`Failed to update job ${jobId} status to processing`);\n            } else {\n                console.log(`Successfully updated job ${jobId} status to processing`);\n            }\n            // Start processing directly without setTimeout (which can cause issues in serverless environments)\n            // We don't await this so the request can return quickly\n            (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.processItineraryJob)(jobId, surveyData, generatePrompt, OPENAI_API_KEY).then(()=>{\n                console.log(`Background processing completed for job ${jobId}`);\n            }).catch((error)=>{\n                console.error(`Background processing error for job ${jobId}:`, error);\n                (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"failed\", {\n                    error: error.message || \"Internal server error\"\n                }).catch((e)=>console.error(`Failed to update job status after error for ${jobId}:`, e));\n            });\n            console.log(`Job ${jobId} started processing directly`);\n        } else {\n            // In development, use setTimeout for background processing (more reliable locally)\n            console.log(`Running in development mode for job ${jobId} with setTimeout...`);\n            setTimeout(async ()=>{\n                try {\n                    console.log(`Background processing started for job ${jobId}`);\n                    // First update to processing status to indicate we've started\n                    await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"processing\");\n                    // Process the job\n                    await (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.processItineraryJob)(jobId, surveyData, generatePrompt, OPENAI_API_KEY);\n                    console.log(`Background processing completed successfully for job ${jobId}`);\n                } catch (error) {\n                    console.error(`Background processing error for job ${jobId}:`, error);\n                    // Make extra sure we update the job status on error\n                    try {\n                        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"failed\", {\n                            error: error.message || \"Internal server error\"\n                        });\n                    } catch (updateError) {\n                        console.error(`Failed to update job status after error for ${jobId}:`, updateError);\n                    }\n                }\n            }, 100); // Small delay to ensure job is created first\n        }\n        // Return immediately with the job ID\n        console.log(`Returning response for job ${jobId} with status: queued`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            jobId,\n            status: \"queued\",\n            message: \"Your itinerary is being generated. Poll the job-status endpoint for updates.\"\n        });\n    } catch (error) {\n        console.error(\"Error initiating itinerary generation:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: `Failed to initiate itinerary generation: ${error.message || \"Unknown error\"}`\n        }, {\n            status: 500\n        });\n    }\n}\n// Function to generate a prompt based on survey data\nfunction generatePrompt(surveyData) {\n    // Calculate trip duration - adding 1 to include both start and end date\n    const startDate = new Date(surveyData.startDate);\n    const endDate = new Date(surveyData.endDate);\n    // Set time to noon to avoid timezone issues\n    startDate.setHours(12, 0, 0, 0);\n    endDate.setHours(12, 0, 0, 0);\n    // Calculate days including both start and end date\n    // Using Math.floor instead of Math.round and adding 1 to include both start and end date\n    const diffTime = endDate.getTime() - startDate.getTime();\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    const durationDays = diffDays + 1; // Add 1 to include both start and end date\n    console.log(\"Date calculation:\", {\n        startDate: surveyData.startDate,\n        endDate: surveyData.endDate,\n        startTimestamp: startDate.getTime(),\n        endTimestamp: endDate.getTime(),\n        diffTime,\n        diffDays,\n        durationDays\n    });\n    // Format preferences\n    const preferencesText = surveyData.preferences.length > 0 ? `They particularly enjoy ${surveyData.preferences.join(\", \")}.` : \"\";\n    // Format budget level\n    let budgetLevel = \"\";\n    switch(surveyData.budget){\n        case \"budget\":\n            budgetLevel = \"budget-friendly options, looking for economical accommodations, affordable dining, and free or low-cost activities\";\n            break;\n        case \"moderate\":\n            budgetLevel = \"mid-range options, with comfortable accommodations, good quality restaurants, and a mix of paid and free activities\";\n            break;\n        case \"luxury\":\n            budgetLevel = \"high-end options, with luxury accommodations, fine dining, and premium experiences\";\n            break;\n        default:\n            budgetLevel = \"a mix of affordable and premium options\";\n    }\n    // Format trip purpose\n    let purposeText = \"\";\n    switch(surveyData.purpose){\n        case \"vacation\":\n            purposeText = \"a relaxing vacation\";\n            break;\n        case \"honeymoon\":\n            purposeText = \"their honeymoon, so include romantic activities and settings\";\n            break;\n        case \"family\":\n            purposeText = \"a family trip, so include family-friendly activities\";\n            break;\n        case \"solo\":\n            purposeText = \"a solo adventure, with opportunities for both exploration and meeting people\";\n            break;\n        case \"business\":\n            purposeText = \"a business trip with some leisure time\";\n            break;\n        case \"weekend\":\n            purposeText = \"a quick weekend getaway\";\n            break;\n        case \"roadtrip\":\n            purposeText = \"a road trip, including notable stops and routes\";\n            break;\n        default:\n            purposeText = \"a vacation\";\n    }\n    // Construct the prompt\n    const prompt = `\nCreate a detailed ${durationDays}-day travel itinerary for a trip to ${surveyData.destination} from ${formatDate(startDate)} to ${formatDate(endDate)}.\n\nThis trip is for ${purposeText}. ${preferencesText} The traveler is looking for ${budgetLevel}.\n\nIMPORTANT: You MUST create exactly ${durationDays} days in the itinerary, with dates from ${surveyData.startDate} to ${surveyData.endDate} inclusive.\n\nFor each day, provide:\n1. Morning activity or attraction with: name, description, location, approximate cost\n2. Lunch recommendation with: restaurant name, cuisine type, price range\n3. Afternoon activity or attraction with: name, description, location, approximate cost\n4. Dinner recommendation with: restaurant name, cuisine type, price range\n5. Evening activity (if applicable) with: name, description, location, approximate cost\n\nAlso include:\n- Recommended accommodation options with estimated nightly rates\n- Transportation suggestions within the destination\n- Total estimated budget breakdown for accommodation, food, activities, and transport\n\nReturn this as a JSON object exactly as shown below. Do not include any markdown formatting, code blocks, or additional text. Use ONLY double quotes for all property names and string values - never use single quotes.\n\n{\n  \"title\": \"Trip title\",\n  \"destination\": \"Destination name\",\n  \"dates\": {\n    \"start\": \"YYYY-MM-DD\",\n    \"end\": \"YYYY-MM-DD\"\n  },\n  \"days\": [\n    {\n      \"date\": \"YYYY-MM-DD\",\n      \"activities\": [\n        {\n          \"id\": \"unique-id\",\n          \"time\": \"Morning/Afternoon/Evening\",\n          \"title\": \"Activity name\",\n          \"description\": \"Detailed description\",\n          \"location\": \"Address or area\",\n          \"coordinates\": { \"lat\": 41.3851, \"lng\": 2.1734 },\n          \"cost\": 0\n        }\n      ]\n    }\n  ],\n  \"accommodation\": [\n    {\n      \"name\": \"Accommodation name\",\n      \"description\": \"Description\",\n      \"location\": \"Address\",\n      \"pricePerNight\": 0\n    }\n  ],\n  \"transportation\": [\n    {\n      \"type\": \"Type of transport\",\n      \"description\": \"Description\",\n      \"estimatedCost\": 0\n    }\n  ],\n  \"budget\": {\n    \"accommodation\": 0,\n    \"food\": 0,\n    \"activities\": 0,\n    \"transport\": 0,\n    \"total\": 0\n  }\n}\n\nEnsure all costs are in USD and are realistic estimates. For coordinates, use approximate latitude and longitude for each location. Remember to provide a properly formatted JSON response with all property names in double quotes.\n`;\n    return prompt;\n}\n// Helper function to format dates\nfunction formatDate(date) {\n    return date.toLocaleDateString(\"en-US\", {\n        weekday: \"long\",\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    });\n}\n// Create mock itinerary data for development\nfunction createMockItinerary(surveyData) {\n    const startDate = new Date(surveyData.startDate);\n    const endDate = new Date(surveyData.endDate);\n    // Set time to noon to avoid timezone issues\n    startDate.setHours(12, 0, 0, 0);\n    endDate.setHours(12, 0, 0, 0);\n    // Calculate days including both start and end date\n    // Using Math.floor instead of Math.round and adding 1 to include both start and end date\n    const diffTime = endDate.getTime() - startDate.getTime();\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n    const durationDays = diffDays + 1; // Add 1 to include both start and end date\n    console.log(\"Mock Date calculation:\", {\n        startDate: surveyData.startDate,\n        endDate: surveyData.endDate,\n        diffTime,\n        diffDays,\n        durationDays\n    });\n    const days = [];\n    // Generate mock days\n    for(let i = 0; i < durationDays; i++){\n        const currentDate = new Date(startDate);\n        currentDate.setDate(startDate.getDate() + i);\n        days.push({\n            date: currentDate.toISOString().split(\"T\")[0],\n            activities: [\n                {\n                    id: `act-${i}-1`,\n                    time: \"Morning\",\n                    title: `Explore ${surveyData.destination} - Day ${i + 1} Morning`,\n                    description: \"Start your day with a visit to a popular local attraction.\",\n                    location: `${surveyData.destination} City Center`,\n                    coordinates: {\n                        lat: 40.7128,\n                        lng: -74.0060\n                    },\n                    cost: 25\n                },\n                {\n                    id: `act-${i}-2`,\n                    time: \"Afternoon\",\n                    title: `${surveyData.destination} Afternoon Activity`,\n                    description: \"Enjoy a relaxing afternoon activity based on your preferences.\",\n                    location: `${surveyData.destination} Park`,\n                    coordinates: {\n                        lat: 40.7828,\n                        lng: -73.9654\n                    },\n                    cost: 15\n                },\n                {\n                    id: `act-${i}-3`,\n                    time: \"Evening\",\n                    title: `${surveyData.destination} Night Experience`,\n                    description: \"Experience the local nightlife and culture.\",\n                    location: `${surveyData.destination} Entertainment District`,\n                    coordinates: {\n                        lat: 40.7590,\n                        lng: -73.9845\n                    },\n                    cost: 50\n                }\n            ]\n        });\n    }\n    // Create mock budget based on preferences\n    let accommodationCost = 0;\n    switch(surveyData.budget){\n        case \"budget\":\n            accommodationCost = 75;\n            break;\n        case \"moderate\":\n            accommodationCost = 150;\n            break;\n        case \"luxury\":\n            accommodationCost = 300;\n            break;\n        default:\n            accommodationCost = 150;\n    }\n    const totalAccommodation = accommodationCost * durationDays;\n    const totalFood = 60 * durationDays;\n    const totalActivities = 90 * durationDays;\n    const totalTransport = 30 * durationDays;\n    return {\n        title: `${surveyData.destination} ${surveyData.purpose.charAt(0).toUpperCase() + surveyData.purpose.slice(1)} Trip`,\n        destination: surveyData.destination,\n        dates: {\n            start: surveyData.startDate,\n            end: surveyData.endDate\n        },\n        days,\n        accommodation: [\n            {\n                name: `${surveyData.destination} Hotel`,\n                description: \"A comfortable hotel in a convenient location.\",\n                location: `Central ${surveyData.destination}`,\n                pricePerNight: accommodationCost\n            },\n            {\n                name: `${surveyData.destination} Boutique Stay`,\n                description: \"A charming boutique accommodation with local character.\",\n                location: `Historic District, ${surveyData.destination}`,\n                pricePerNight: accommodationCost * 1.2\n            }\n        ],\n        transportation: [\n            {\n                type: \"Public Transit\",\n                description: \"Convenient and affordable public transportation network.\",\n                estimatedCost: totalTransport * 0.5\n            },\n            {\n                type: \"Taxi/Rideshare\",\n                description: \"On-demand rides for convenience.\",\n                estimatedCost: totalTransport * 0.5\n            }\n        ],\n        budget: {\n            accommodation: totalAccommodation,\n            food: totalFood,\n            activities: totalActivities,\n            transport: totalTransport,\n            total: totalAccommodation + totalFood + totalActivities + totalTransport\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkM7QUFDMkI7QUFDcUI7QUFFM0YsNENBQTRDO0FBQ3JDLE1BQU1PLFVBQVUsU0FBUztBQUN6QixNQUFNQyxjQUFjLEdBQUcsQ0FBQyxpQ0FBaUM7QUFFaEUseUNBQXlDO0FBQ3pDLE1BQU1DLGlCQUFpQkMsUUFBUUMsR0FBRyxDQUFDRixjQUFjLElBQUk7QUFFckQsNkNBQTZDO0FBQzdDLE1BQU1HLGVBQWVGLGtCQUF5QjtBQUU5QywyQ0FBMkM7QUFDM0MsTUFBTUcsdUJBQXVCQyxRQUMzQkosS0FBb0MsSUFDcENBLGtOQUF5QztBQWFwQyxlQUFlTyxLQUFLQyxPQUFnQjtJQUN6QyxJQUFJO1FBQ0Ysb0NBQW9DO1FBQ3BDQyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxxQkFBcUIsRUFBRSxJQUFJQyxPQUFPQyxXQUFXLEdBQUcsQ0FBQztRQUM5REgsUUFBUUMsR0FBRyxDQUFDLGdCQUFnQjtZQUMxQkcsU0FuQ047WUFvQ01YO1FBQ0Y7UUFFQSw2REFBNkQ7UUFDN0RPLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEI7WUFDeENJLGdCQUFnQixDQUFDLENBQUNkLDBDQUFvQztZQUN0RGUsZ0JBQWdCLENBQUMsQ0FBQ2Ysa05BQXlDO1lBQzNEZ0IsV0FBV2hCLDBDQUFvQyxFQUFFaUIsVUFBVTtZQUMzREMsV0FBV2xCLGtOQUF5QyxFQUFFaUIsVUFBVTtRQUNsRTtRQUVBLHVEQUF1RDtRQUN2RCxJQUFJZCxzQkFBc0I7WUFDeEIsSUFBSTtnQkFDRixNQUFNLEVBQUVnQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU14QixtREFBUUEsQ0FBQ3lCLElBQUksQ0FBQyxRQUFRQyxNQUFNLENBQUMsU0FBU0MsS0FBSyxDQUFDO2dCQUMxRSxJQUFJSCxPQUFPO29CQUNUWCxRQUFRVyxLQUFLLENBQUMsb0NBQW9DO3dCQUNoREksU0FBU0osTUFBTUksT0FB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RSxXQUFXLENBQUMsY0FBYyxDQUFDO2dCQUMvQ3dELGFBQWE7Z0JBQ2JDLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRTNELFdBQVdFLFdBQVcsQ0FBQyxDQUFDO2dCQUN4RDJFLGVBQWViLG9CQUFvQjtZQUNyQztTQUNEO1FBQ0RjLGdCQUFnQjtZQUNkO2dCQUNFQyxNQUFNO2dCQUNOckIsYUFBYTtnQkFDYnNCLGVBQWVaLGlCQUFpQjtZQUNsQztZQUNBO2dCQUNFVyxNQUFNO2dCQUNOckIsYUFBYTtnQkFDYnNCLGVBQWVaLGlCQUFpQjtZQUNsQztTQUNEO1FBQ0Q5RCxRQUFRO1lBQ05xRSxlQUFlVjtZQUNmZ0IsTUFBTWY7WUFDTlosWUFBWWE7WUFDWmUsV0FBV2Q7WUFDWGUsT0FBT2xCLHFCQUFxQkMsWUFBWUMsa0JBQWtCQztRQUM1RDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10cmF2ZWwtYWdlbnQvLi9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50cz9kODMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IGdlbmVyYXRlSm9iSWQsIHByb2Nlc3NJdGluZXJhcnlKb2IgfSBmcm9tICcuLi9qb2ItcHJvY2Vzc29yJztcbmltcG9ydCB7IGNyZWF0ZUpvYiwgdXBkYXRlSm9iU3RhdHVzLCBnZXRKb2JTdGF0dXMsIHN1cGFiYXNlIH0gZnJvbSAnLi4vLi4vLi4vbGliL3N1cGFiYXNlJztcblxuLy8gQ29uZmlndXJlIHJ1bnRpbWUgZm9yIHNlcnZlcmxlc3MgZnVuY3Rpb25cbmV4cG9ydCBjb25zdCBydW50aW1lID0gJ25vZGVqcyc7XG5leHBvcnQgY29uc3QgbWF4RHVyYXRpb24gPSA2MDsgLy8gU2V0IG1heCBkdXJhdGlvbiB0byA2MCBzZWNvbmRzXG5cbi8vIFVzZSBBUEkga2V5IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG5jb25zdCBPUEVOQUlfQVBJX0tFWSA9IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZIHx8ICcnO1xuXG4vLyBDaGVjayBpZiBydW5uaW5nIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5cbi8vIENoZWNrIGlmIFN1cGFiYXNlIGlzIHByb3Blcmx5IGNvbmZpZ3VyZWRcbmNvbnN0IGlzU3VwYWJhc2VDb25maWd1cmVkID0gQm9vbGVhbihcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMICYmIFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxuKTtcblxuLy8gU3VydmV5IGRhdGEgdHlwZVxudHlwZSBTdXJ2ZXlEYXRhID0ge1xuICBkZXN0aW5hdGlvbjogc3RyaW5nO1xuICBzdGFydERhdGU6IHN0cmluZztcbiAgZW5kRGF0ZTogc3RyaW5nO1xuICBwdXJwb3NlOiBzdHJpbmc7XG4gIGJ1ZGdldDogc3RyaW5nO1xuICBwcmVmZXJlbmNlczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgLy8gTG9nIGtleSBpbmZvcm1hdGlvbiBmb3IgZGVidWdnaW5nXG4gICAgY29uc29sZS5sb2coYEFQSSBSZXF1ZXN0IHN0YXJ0ZWQ6ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWApO1xuICAgIGNvbnNvbGUubG9nKCdFbnZpcm9ubWVudDonLCB7XG4gICAgICBub2RlRW52OiBwcm9jZXNzLmVudi5OT0RFX0VOVixcbiAgICAgIGlzUHJvZHVjdGlvblxuICAgIH0pO1xuICAgIFxuICAgIC8vIExvZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgKHdpdGhvdXQgZXhwb3NpbmcgYWN0dWFsIHZhbHVlcylcbiAgICBjb25zb2xlLmxvZygnU3VwYWJhc2UgY29ubmVjdGlvbiBjaGVjazonLCB7XG4gICAgICBoYXNTdXBhYmFzZVVybDogISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gICAgICBoYXNTdXBhYmFzZUtleTogISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgICAgIHVybExlbmd0aDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMPy5sZW5ndGggfHwgMCxcbiAgICAgIGtleUxlbmd0aDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVk/Lmxlbmd0aCB8fCAwXG4gICAgfSk7XG5cbiAgICAvLyBPbmx5IHRlc3QgU3VwYWJhc2UgY29ubmVjdGlvbiBpZiBwcm9wZXJseSBjb25maWd1cmVkXG4gICAgaWYgKGlzU3VwYWJhc2VDb25maWd1cmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdqb2JzJykuc2VsZWN0KCdjb3VudCcpLmxpbWl0KDEpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBoaW50OiBlcnJvci5oaW50IHx8ICcnLFxuICAgICAgICAgICAgY29kZTogZXJyb3IuY29kZSB8fCAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIENvbnRpbnVlIGV4ZWN1dGlvbiBkZXNwaXRlIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAgICAvLyBUaGUgam9iIHdpbGwgYmUgc3RvcmVkIGluIG1lbW9yeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3Qgc3VjY2Vzc2Z1bDonLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY29ubkVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgY29ubmVjdGlvbiB0ZXN0IGV4Y2VwdGlvbjonLCB7XG4gICAgICAgICAgbWVzc2FnZTogY29ubkVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgZGV0YWlsczogY29ubkVycm9yLnRvU3RyaW5nKCksXG4gICAgICAgICAgaGludDogJycsXG4gICAgICAgICAgY29kZTogJydcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvbnRpbnVlIGV4ZWN1dGlvbiBkZXNwaXRlIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAgLy8gVGhlIGpvYiB3aWxsIGJlIHN0b3JlZCBpbiBtZW1vcnlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ1NraXBwaW5nIFN1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCAtIG5vdCBjb25maWd1cmVkJyk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIHJlcXVlc3QgYm9keVxuICAgIGNvbnN0IHN1cnZleURhdGE6IFN1cnZleURhdGEgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgc3VydmV5IGRhdGE6Jywge1xuICAgICAgZGVzdGluYXRpb246IHN1cnZleURhdGEuZGVzdGluYXRpb24sXG4gICAgICBzdGFydERhdGU6IHN1cnZleURhdGEuc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZTogc3VydmV5RGF0YS5lbmREYXRlLFxuICAgICAgcHVycG9zZTogc3VydmV5RGF0YS5wdXJwb3NlLFxuICAgICAgYnVkZ2V0OiBzdXJ2ZXlEYXRhLmJ1ZGdldCxcbiAgICAgIHByZWZlcmVuY2VzOiBzdXJ2ZXlEYXRhLnByZWZlcmVuY2VzIFxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGpvYiBJRFxuICAgIGNvbnN0IGpvYklkID0gZ2VuZXJhdGVKb2JJZCgpO1xuICAgIGNvbnNvbGUubG9nKGBHZW5lcmF0ZWQgbmV3IGpvYiBJRDogJHtqb2JJZH1gKTtcblxuICAgIC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50IG9yIHRlc3RpbmcsIHJldHVybiBtb2NrIGRhdGEgaW1tZWRpYXRlbHlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIU9QRU5BSV9BUElfS0VZLnN0YXJ0c1dpdGgoJ3NrLScpKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGV2ZWxvcG1lbnQgbW9kZTogUmV0dXJuaW5nIG1vY2sgZGF0YScpO1xuICAgICAgY29uc3QgbW9ja0l0aW5lcmFyeSA9IGNyZWF0ZU1vY2tJdGluZXJhcnkoc3VydmV5RGF0YSk7XG4gICAgICBjb25zdCB1cGRhdGVSZXN1bHQgPSBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdjb21wbGV0ZWQnLCB7IFxuICAgICAgICByZXN1bHQ6IHsgXG4gICAgICAgICAgaXRpbmVyYXJ5OiBtb2NrSXRpbmVyYXJ5LCBcbiAgICAgICAgICBwcm9tcHQ6IGdlbmVyYXRlUHJvbXB0KHN1cnZleURhdGEpIFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCF1cGRhdGVSZXN1bHQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBqb2Igc3RhdHVzIGluIGRldmVsb3BtZW50IG1vZGUnKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gdXBkYXRlIGpvYiBzdGF0dXMnIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGpvYklkLCBzdGF0dXM6ICdjb21wbGV0ZWQnIH0pO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBqb2JcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbmV3IGpvYiB3aXRoIElEOicsIGpvYklkKTtcbiAgICBjb25zdCBqb2JDcmVhdGVkID0gYXdhaXQgY3JlYXRlSm9iKGpvYklkKTtcbiAgICBcbiAgICBpZiAoIWpvYkNyZWF0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgam9iJyk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIGpvYiBpbiBkYXRhYmFzZScgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LCBjdXJyZW50IHN0YXR1czogcXVldWVkYCk7XG5cbiAgICAvLyBWZXJpZnkgdGhlIGpvYiB3YXMgY3JlYXRlZCBwcm9wZXJseSBieSBmZXRjaGluZyBpdHMgc3RhdHVzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXR1c0NoZWNrID0gYXdhaXQgZ2V0Sm9iU3RhdHVzKGpvYklkKTtcbiAgICAgIGNvbnNvbGUubG9nKGBJbml0aWFsIGpvYiBzdGF0dXMgY2hlY2s6ICR7c3RhdHVzQ2hlY2suc3RhdHVzfWApO1xuICAgICAgXG4gICAgICBpZiAoc3RhdHVzQ2hlY2suc3RhdHVzID09PSAnbm90X2ZvdW5kJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBDcml0aWNhbCBlcnJvcjogSm9iICR7am9iSWR9IHdhcyBub3QgZm91bmQgaW1tZWRpYXRlbHkgYWZ0ZXIgY3JlYXRpb25gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChzdGF0dXNDaGVja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBpbml0aWFsIGpvYiBzdGF0dXM6Jywgc3RhdHVzQ2hlY2tFcnJvcik7XG4gICAgfVxuXG4gICAgLy8gSW4gcHJvZHVjdGlvbiBvciB3aGVuIGltbWVkaWF0ZSByZXF1ZXN0IGhhbmRsaW5nIGlzIG5lZWRlZCwgcHJvY2VzcyBzeW5jaHJvbm91c2x5XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgY29uc29sZS5sb2coYFJ1bm5pbmcgaW4gcHJvZHVjdGlvbiBtb2RlIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1cyB0byBwcm9jZXNzaW5nIGFuZCBpbW1lZGlhdGVseSByZXR1cm4gcmVzcG9uc2VcbiAgICAgIGNvbnN0IHN0YXR1c1VwZGF0ZVN1Y2Nlc3MgPSBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdwcm9jZXNzaW5nJyk7XG4gICAgICBpZiAoIXN0YXR1c1VwZGF0ZVN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBqb2IgJHtqb2JJZH0gc3RhdHVzIHRvIHByb2Nlc3NpbmdgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgdXBkYXRlZCBqb2IgJHtqb2JJZH0gc3RhdHVzIHRvIHByb2Nlc3NpbmdgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RhcnQgcHJvY2Vzc2luZyBkaXJlY3RseSB3aXRob3V0IHNldFRpbWVvdXQgKHdoaWNoIGNhbiBjYXVzZSBpc3N1ZXMgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMpXG4gICAgICAvLyBXZSBkb24ndCBhd2FpdCB0aGlzIHNvIHRoZSByZXF1ZXN0IGNhbiByZXR1cm4gcXVpY2tseVxuICAgICAgcHJvY2Vzc0l0aW5lcmFyeUpvYihqb2JJZCwgc3VydmV5RGF0YSwgZ2VuZXJhdGVQcm9tcHQsIE9QRU5BSV9BUElfS0VZKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEJhY2tncm91bmQgcHJvY2Vzc2luZyBjb21wbGV0ZWQgZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEJhY2tncm91bmQgcHJvY2Vzc2luZyBlcnJvciBmb3Igam9iICR7am9iSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ludGVybmFsIHNlcnZlciBlcnJvcidcbiAgICAgICAgICB9KS5jYXRjaChlID0+IGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgam9iIHN0YXR1cyBhZnRlciBlcnJvciBmb3IgJHtqb2JJZH06YCwgZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IHN0YXJ0ZWQgcHJvY2Vzc2luZyBkaXJlY3RseWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBkZXZlbG9wbWVudCwgdXNlIHNldFRpbWVvdXQgZm9yIGJhY2tncm91bmQgcHJvY2Vzc2luZyAobW9yZSByZWxpYWJsZSBsb2NhbGx5KVxuICAgICAgY29uc29sZS5sb2coYFJ1bm5pbmcgaW4gZGV2ZWxvcG1lbnQgbW9kZSBmb3Igam9iICR7am9iSWR9IHdpdGggc2V0VGltZW91dC4uLmApO1xuICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEJhY2tncm91bmQgcHJvY2Vzc2luZyBzdGFydGVkIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICAgICAgICAvLyBGaXJzdCB1cGRhdGUgdG8gcHJvY2Vzc2luZyBzdGF0dXMgdG8gaW5kaWNhdGUgd2UndmUgc3RhcnRlZFxuICAgICAgICAgIGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ3Byb2Nlc3NpbmcnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBqb2JcbiAgICAgICAgICBhd2FpdCBwcm9jZXNzSXRpbmVyYXJ5Sm9iKGpvYklkLCBzdXJ2ZXlEYXRhLCBnZW5lcmF0ZVByb21wdCwgT1BFTkFJX0FQSV9LRVkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBCYWNrZ3JvdW5kIHByb2Nlc3NpbmcgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBCYWNrZ3JvdW5kIHByb2Nlc3NpbmcgZXJyb3IgZm9yIGpvYiAke2pvYklkfTpgLCBlcnJvcik7XG4gICAgICAgICAgLy8gTWFrZSBleHRyYSBzdXJlIHdlIHVwZGF0ZSB0aGUgam9iIHN0YXR1cyBvbiBlcnJvclxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnSW50ZXJuYWwgc2VydmVyIGVycm9yJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgam9iIHN0YXR1cyBhZnRlciBlcnJvciBmb3IgJHtqb2JJZH06YCwgdXBkYXRlRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGpvYiBpcyBjcmVhdGVkIGZpcnN0XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IHdpdGggdGhlIGpvYiBJRFxuICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgcmVzcG9uc2UgZm9yIGpvYiAke2pvYklkfSB3aXRoIHN0YXR1czogcXVldWVkYCk7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICBqb2JJZCwgXG4gICAgICBzdGF0dXM6ICdxdWV1ZWQnLFxuICAgICAgbWVzc2FnZTogJ1lvdXIgaXRpbmVyYXJ5IGlzIGJlaW5nIGdlbmVyYXRlZC4gUG9sbCB0aGUgam9iLXN0YXR1cyBlbmRwb2ludCBmb3IgdXBkYXRlcy4nXG4gICAgfSk7XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWF0aW5nIGl0aW5lcmFyeSBnZW5lcmF0aW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiBgRmFpbGVkIHRvIGluaXRpYXRlIGl0aW5lcmFyeSBnZW5lcmF0aW9uOiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWAgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBwcm9tcHQgYmFzZWQgb24gc3VydmV5IGRhdGFcbmZ1bmN0aW9uIGdlbmVyYXRlUHJvbXB0KHN1cnZleURhdGE6IFN1cnZleURhdGEpOiBzdHJpbmcge1xuICAvLyBDYWxjdWxhdGUgdHJpcCBkdXJhdGlvbiAtIGFkZGluZyAxIHRvIGluY2x1ZGUgYm90aCBzdGFydCBhbmQgZW5kIGRhdGVcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5zdGFydERhdGUpO1xuICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5lbmREYXRlKTtcbiAgXG4gIC8vIFNldCB0aW1lIHRvIG5vb24gdG8gYXZvaWQgdGltZXpvbmUgaXNzdWVzXG4gIHN0YXJ0RGF0ZS5zZXRIb3VycygxMiwgMCwgMCwgMCk7XG4gIGVuZERhdGUuc2V0SG91cnMoMTIsIDAsIDAsIDApO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGRheXMgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIC8vIFVzaW5nIE1hdGguZmxvb3IgaW5zdGVhZCBvZiBNYXRoLnJvdW5kIGFuZCBhZGRpbmcgMSB0byBpbmNsdWRlIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIGNvbnN0IGRpZmZUaW1lID0gZW5kRGF0ZS5nZXRUaW1lKCkgLSBzdGFydERhdGUuZ2V0VGltZSgpO1xuICBjb25zdCBkaWZmRGF5cyA9IE1hdGguZmxvb3IoZGlmZlRpbWUgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICBjb25zdCBkdXJhdGlvbkRheXMgPSBkaWZmRGF5cyArIDE7IC8vIEFkZCAxIHRvIGluY2x1ZGUgYm90aCBzdGFydCBhbmQgZW5kIGRhdGVcbiAgXG4gIGNvbnNvbGUubG9nKCdEYXRlIGNhbGN1bGF0aW9uOicsIHtcbiAgICBzdGFydERhdGU6IHN1cnZleURhdGEuc3RhcnREYXRlLFxuICAgIGVuZERhdGU6IHN1cnZleURhdGEuZW5kRGF0ZSxcbiAgICBzdGFydFRpbWVzdGFtcDogc3RhcnREYXRlLmdldFRpbWUoKSxcbiAgICBlbmRUaW1lc3RhbXA6IGVuZERhdGUuZ2V0VGltZSgpLFxuICAgIGRpZmZUaW1lLFxuICAgIGRpZmZEYXlzLFxuICAgIGR1cmF0aW9uRGF5c1xuICB9KTtcblxuICAvLyBGb3JtYXQgcHJlZmVyZW5jZXNcbiAgY29uc3QgcHJlZmVyZW5jZXNUZXh0ID0gc3VydmV5RGF0YS5wcmVmZXJlbmNlcy5sZW5ndGggPiAwXG4gICAgPyBgVGhleSBwYXJ0aWN1bGFybHkgZW5qb3kgJHtzdXJ2ZXlEYXRhLnByZWZlcmVuY2VzLmpvaW4oJywgJyl9LmBcbiAgICA6ICcnO1xuXG4gIC8vIEZvcm1hdCBidWRnZXQgbGV2ZWxcbiAgbGV0IGJ1ZGdldExldmVsID0gJyc7XG4gIHN3aXRjaCAoc3VydmV5RGF0YS5idWRnZXQpIHtcbiAgICBjYXNlICdidWRnZXQnOlxuICAgICAgYnVkZ2V0TGV2ZWwgPSAnYnVkZ2V0LWZyaWVuZGx5IG9wdGlvbnMsIGxvb2tpbmcgZm9yIGVjb25vbWljYWwgYWNjb21tb2RhdGlvbnMsIGFmZm9yZGFibGUgZGluaW5nLCBhbmQgZnJlZSBvciBsb3ctY29zdCBhY3Rpdml0aWVzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vZGVyYXRlJzpcbiAgICAgIGJ1ZGdldExldmVsID0gJ21pZC1yYW5nZSBvcHRpb25zLCB3aXRoIGNvbWZvcnRhYmxlIGFjY29tbW9kYXRpb25zLCBnb29kIHF1YWxpdHkgcmVzdGF1cmFudHMsIGFuZCBhIG1peCBvZiBwYWlkIGFuZCBmcmVlIGFjdGl2aXRpZXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbHV4dXJ5JzpcbiAgICAgIGJ1ZGdldExldmVsID0gJ2hpZ2gtZW5kIG9wdGlvbnMsIHdpdGggbHV4dXJ5IGFjY29tbW9kYXRpb25zLCBmaW5lIGRpbmluZywgYW5kIHByZW1pdW0gZXhwZXJpZW5jZXMnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJ1ZGdldExldmVsID0gJ2EgbWl4IG9mIGFmZm9yZGFibGUgYW5kIHByZW1pdW0gb3B0aW9ucyc7XG4gIH1cblxuICAvLyBGb3JtYXQgdHJpcCBwdXJwb3NlXG4gIGxldCBwdXJwb3NlVGV4dCA9ICcnO1xuICBzd2l0Y2ggKHN1cnZleURhdGEucHVycG9zZSkge1xuICAgIGNhc2UgJ3ZhY2F0aW9uJzpcbiAgICAgIHB1cnBvc2VUZXh0ID0gJ2EgcmVsYXhpbmcgdmFjYXRpb24nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaG9uZXltb29uJzpcbiAgICAgIHB1cnBvc2VUZXh0ID0gJ3RoZWlyIGhvbmV5bW9vbiwgc28gaW5jbHVkZSByb21hbnRpYyBhY3Rpdml0aWVzIGFuZCBzZXR0aW5ncyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmYW1pbHknOlxuICAgICAgcHVycG9zZVRleHQgPSAnYSBmYW1pbHkgdHJpcCwgc28gaW5jbHVkZSBmYW1pbHktZnJpZW5kbHkgYWN0aXZpdGllcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb2xvJzpcbiAgICAgIHB1cnBvc2VUZXh0ID0gJ2Egc29sbyBhZHZlbnR1cmUsIHdpdGggb3Bwb3J0dW5pdGllcyBmb3IgYm90aCBleHBsb3JhdGlvbiBhbmQgbWVldGluZyBwZW9wbGUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYnVzaW5lc3MnOlxuICAgICAgcHVycG9zZVRleHQgPSAnYSBidXNpbmVzcyB0cmlwIHdpdGggc29tZSBsZWlzdXJlIHRpbWUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2Vla2VuZCc6XG4gICAgICBwdXJwb3NlVGV4dCA9ICdhIHF1aWNrIHdlZWtlbmQgZ2V0YXdheSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyb2FkdHJpcCc6XG4gICAgICBwdXJwb3NlVGV4dCA9ICdhIHJvYWQgdHJpcCwgaW5jbHVkaW5nIG5vdGFibGUgc3RvcHMgYW5kIHJvdXRlcyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHVycG9zZVRleHQgPSAnYSB2YWNhdGlvbic7XG4gIH1cblxuICAvLyBDb25zdHJ1Y3QgdGhlIHByb21wdFxuICBjb25zdCBwcm9tcHQgPSBgXG5DcmVhdGUgYSBkZXRhaWxlZCAke2R1cmF0aW9uRGF5c30tZGF5IHRyYXZlbCBpdGluZXJhcnkgZm9yIGEgdHJpcCB0byAke3N1cnZleURhdGEuZGVzdGluYXRpb259IGZyb20gJHtmb3JtYXREYXRlKHN0YXJ0RGF0ZSl9IHRvICR7Zm9ybWF0RGF0ZShlbmREYXRlKX0uXG5cblRoaXMgdHJpcCBpcyBmb3IgJHtwdXJwb3NlVGV4dH0uICR7cHJlZmVyZW5jZXNUZXh0fSBUaGUgdHJhdmVsZXIgaXMgbG9va2luZyBmb3IgJHtidWRnZXRMZXZlbH0uXG5cbklNUE9SVEFOVDogWW91IE1VU1QgY3JlYXRlIGV4YWN0bHkgJHtkdXJhdGlvbkRheXN9IGRheXMgaW4gdGhlIGl0aW5lcmFyeSwgd2l0aCBkYXRlcyBmcm9tICR7c3VydmV5RGF0YS5zdGFydERhdGV9IHRvICR7c3VydmV5RGF0YS5lbmREYXRlfSBpbmNsdXNpdmUuXG5cbkZvciBlYWNoIGRheSwgcHJvdmlkZTpcbjEuIE1vcm5pbmcgYWN0aXZpdHkgb3IgYXR0cmFjdGlvbiB3aXRoOiBuYW1lLCBkZXNjcmlwdGlvbiwgbG9jYXRpb24sIGFwcHJveGltYXRlIGNvc3RcbjIuIEx1bmNoIHJlY29tbWVuZGF0aW9uIHdpdGg6IHJlc3RhdXJhbnQgbmFtZSwgY3Vpc2luZSB0eXBlLCBwcmljZSByYW5nZVxuMy4gQWZ0ZXJub29uIGFjdGl2aXR5IG9yIGF0dHJhY3Rpb24gd2l0aDogbmFtZSwgZGVzY3JpcHRpb24sIGxvY2F0aW9uLCBhcHByb3hpbWF0ZSBjb3N0XG40LiBEaW5uZXIgcmVjb21tZW5kYXRpb24gd2l0aDogcmVzdGF1cmFudCBuYW1lLCBjdWlzaW5lIHR5cGUsIHByaWNlIHJhbmdlXG41LiBFdmVuaW5nIGFjdGl2aXR5IChpZiBhcHBsaWNhYmxlKSB3aXRoOiBuYW1lLCBkZXNjcmlwdGlvbiwgbG9jYXRpb24sIGFwcHJveGltYXRlIGNvc3RcblxuQWxzbyBpbmNsdWRlOlxuLSBSZWNvbW1lbmRlZCBhY2NvbW1vZGF0aW9uIG9wdGlvbnMgd2l0aCBlc3RpbWF0ZWQgbmlnaHRseSByYXRlc1xuLSBUcmFuc3BvcnRhdGlvbiBzdWdnZXN0aW9ucyB3aXRoaW4gdGhlIGRlc3RpbmF0aW9uXG4tIFRvdGFsIGVzdGltYXRlZCBidWRnZXQgYnJlYWtkb3duIGZvciBhY2NvbW1vZGF0aW9uLCBmb29kLCBhY3Rpdml0aWVzLCBhbmQgdHJhbnNwb3J0XG5cblJldHVybiB0aGlzIGFzIGEgSlNPTiBvYmplY3QgZXhhY3RseSBhcyBzaG93biBiZWxvdy4gRG8gbm90IGluY2x1ZGUgYW55IG1hcmtkb3duIGZvcm1hdHRpbmcsIGNvZGUgYmxvY2tzLCBvciBhZGRpdGlvbmFsIHRleHQuIFVzZSBPTkxZIGRvdWJsZSBxdW90ZXMgZm9yIGFsbCBwcm9wZXJ0eSBuYW1lcyBhbmQgc3RyaW5nIHZhbHVlcyAtIG5ldmVyIHVzZSBzaW5nbGUgcXVvdGVzLlxuXG57XG4gIFwidGl0bGVcIjogXCJUcmlwIHRpdGxlXCIsXG4gIFwiZGVzdGluYXRpb25cIjogXCJEZXN0aW5hdGlvbiBuYW1lXCIsXG4gIFwiZGF0ZXNcIjoge1xuICAgIFwic3RhcnRcIjogXCJZWVlZLU1NLUREXCIsXG4gICAgXCJlbmRcIjogXCJZWVlZLU1NLUREXCJcbiAgfSxcbiAgXCJkYXlzXCI6IFtcbiAgICB7XG4gICAgICBcImRhdGVcIjogXCJZWVlZLU1NLUREXCIsXG4gICAgICBcImFjdGl2aXRpZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJpZFwiOiBcInVuaXF1ZS1pZFwiLFxuICAgICAgICAgIFwidGltZVwiOiBcIk1vcm5pbmcvQWZ0ZXJub29uL0V2ZW5pbmdcIixcbiAgICAgICAgICBcInRpdGxlXCI6IFwiQWN0aXZpdHkgbmFtZVwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZXRhaWxlZCBkZXNjcmlwdGlvblwiLFxuICAgICAgICAgIFwibG9jYXRpb25cIjogXCJBZGRyZXNzIG9yIGFyZWFcIixcbiAgICAgICAgICBcImNvb3JkaW5hdGVzXCI6IHsgXCJsYXRcIjogNDEuMzg1MSwgXCJsbmdcIjogMi4xNzM0IH0sXG4gICAgICAgICAgXCJjb3N0XCI6IDBcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXSxcbiAgXCJhY2NvbW1vZGF0aW9uXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJBY2NvbW1vZGF0aW9uIG5hbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZXNjcmlwdGlvblwiLFxuICAgICAgXCJsb2NhdGlvblwiOiBcIkFkZHJlc3NcIixcbiAgICAgIFwicHJpY2VQZXJOaWdodFwiOiAwXG4gICAgfVxuICBdLFxuICBcInRyYW5zcG9ydGF0aW9uXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJUeXBlIG9mIHRyYW5zcG9ydFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlc2NyaXB0aW9uXCIsXG4gICAgICBcImVzdGltYXRlZENvc3RcIjogMFxuICAgIH1cbiAgXSxcbiAgXCJidWRnZXRcIjoge1xuICAgIFwiYWNjb21tb2RhdGlvblwiOiAwLFxuICAgIFwiZm9vZFwiOiAwLFxuICAgIFwiYWN0aXZpdGllc1wiOiAwLFxuICAgIFwidHJhbnNwb3J0XCI6IDAsXG4gICAgXCJ0b3RhbFwiOiAwXG4gIH1cbn1cblxuRW5zdXJlIGFsbCBjb3N0cyBhcmUgaW4gVVNEIGFuZCBhcmUgcmVhbGlzdGljIGVzdGltYXRlcy4gRm9yIGNvb3JkaW5hdGVzLCB1c2UgYXBwcm94aW1hdGUgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBmb3IgZWFjaCBsb2NhdGlvbi4gUmVtZW1iZXIgdG8gcHJvdmlkZSBhIHByb3Blcmx5IGZvcm1hdHRlZCBKU09OIHJlc3BvbnNlIHdpdGggYWxsIHByb3BlcnR5IG5hbWVzIGluIGRvdWJsZSBxdW90ZXMuXG5gO1xuXG4gIHJldHVybiBwcm9tcHQ7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgZGF0ZXNcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IFxuICAgIHdlZWtkYXk6ICdsb25nJywgXG4gICAgeWVhcjogJ251bWVyaWMnLCBcbiAgICBtb250aDogJ2xvbmcnLCBcbiAgICBkYXk6ICdudW1lcmljJyBcbiAgfSk7XG59XG5cbi8vIENyZWF0ZSBtb2NrIGl0aW5lcmFyeSBkYXRhIGZvciBkZXZlbG9wbWVudFxuZnVuY3Rpb24gY3JlYXRlTW9ja0l0aW5lcmFyeShzdXJ2ZXlEYXRhOiBTdXJ2ZXlEYXRhKTogYW55IHtcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5zdGFydERhdGUpO1xuICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoc3VydmV5RGF0YS5lbmREYXRlKTtcbiAgXG4gIC8vIFNldCB0aW1lIHRvIG5vb24gdG8gYXZvaWQgdGltZXpvbmUgaXNzdWVzXG4gIHN0YXJ0RGF0ZS5zZXRIb3VycygxMiwgMCwgMCwgMCk7XG4gIGVuZERhdGUuc2V0SG91cnMoMTIsIDAsIDAsIDApO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGRheXMgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIC8vIFVzaW5nIE1hdGguZmxvb3IgaW5zdGVhZCBvZiBNYXRoLnJvdW5kIGFuZCBhZGRpbmcgMSB0byBpbmNsdWRlIGJvdGggc3RhcnQgYW5kIGVuZCBkYXRlXG4gIGNvbnN0IGRpZmZUaW1lID0gZW5kRGF0ZS5nZXRUaW1lKCkgLSBzdGFydERhdGUuZ2V0VGltZSgpO1xuICBjb25zdCBkaWZmRGF5cyA9IE1hdGguZmxvb3IoZGlmZlRpbWUgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICBjb25zdCBkdXJhdGlvbkRheXMgPSBkaWZmRGF5cyArIDE7IC8vIEFkZCAxIHRvIGluY2x1ZGUgYm90aCBzdGFydCBhbmQgZW5kIGRhdGVcbiAgXG4gIGNvbnNvbGUubG9nKCdNb2NrIERhdGUgY2FsY3VsYXRpb246Jywge1xuICAgIHN0YXJ0RGF0ZTogc3VydmV5RGF0YS5zdGFydERhdGUsXG4gICAgZW5kRGF0ZTogc3VydmV5RGF0YS5lbmREYXRlLFxuICAgIGRpZmZUaW1lLFxuICAgIGRpZmZEYXlzLFxuICAgIGR1cmF0aW9uRGF5c1xuICB9KTtcbiAgXG4gIGNvbnN0IGRheXMgPSBbXTtcbiAgXG4gIC8vIEdlbmVyYXRlIG1vY2sgZGF5c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR1cmF0aW9uRGF5czsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgIGN1cnJlbnREYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSArIGkpO1xuICAgIFxuICAgIGRheXMucHVzaCh7XG4gICAgICBkYXRlOiBjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICBhY3Rpdml0aWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogYGFjdC0ke2l9LTFgLFxuICAgICAgICAgIHRpbWU6ICdNb3JuaW5nJyxcbiAgICAgICAgICB0aXRsZTogYEV4cGxvcmUgJHtzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9ufSAtIERheSAke2kgKyAxfSBNb3JuaW5nYCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1N0YXJ0IHlvdXIgZGF5IHdpdGggYSB2aXNpdCB0byBhIHBvcHVsYXIgbG9jYWwgYXR0cmFjdGlvbi4nLFxuICAgICAgICAgIGxvY2F0aW9uOiBgJHtzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9ufSBDaXR5IENlbnRlcmAsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHsgbGF0OiA0MC43MTI4LCBsbmc6IC03NC4wMDYwIH0sIC8vIE5ZQyBjb29yZGluYXRlcyBhcyBwbGFjZWhvbGRlclxuICAgICAgICAgIGNvc3Q6IDI1LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGBhY3QtJHtpfS0yYCxcbiAgICAgICAgICB0aW1lOiAnQWZ0ZXJub29uJyxcbiAgICAgICAgICB0aXRsZTogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gQWZ0ZXJub29uIEFjdGl2aXR5YCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Vuam95IGEgcmVsYXhpbmcgYWZ0ZXJub29uIGFjdGl2aXR5IGJhc2VkIG9uIHlvdXIgcHJlZmVyZW5jZXMuJyxcbiAgICAgICAgICBsb2NhdGlvbjogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gUGFya2AsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHsgbGF0OiA0MC43ODI4LCBsbmc6IC03My45NjU0IH0sIC8vIENlbnRyYWwgUGFyayBjb29yZGluYXRlcyBhcyBwbGFjZWhvbGRlclxuICAgICAgICAgIGNvc3Q6IDE1LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IGBhY3QtJHtpfS0zYCxcbiAgICAgICAgICB0aW1lOiAnRXZlbmluZycsXG4gICAgICAgICAgdGl0bGU6IGAke3N1cnZleURhdGEuZGVzdGluYXRpb259IE5pZ2h0IEV4cGVyaWVuY2VgLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRXhwZXJpZW5jZSB0aGUgbG9jYWwgbmlnaHRsaWZlIGFuZCBjdWx0dXJlLicsXG4gICAgICAgICAgbG9jYXRpb246IGAke3N1cnZleURhdGEuZGVzdGluYXRpb259IEVudGVydGFpbm1lbnQgRGlzdHJpY3RgLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB7IGxhdDogNDAuNzU5MCwgbG5nOiAtNzMuOTg0NSB9LCAvLyBUaW1lcyBTcXVhcmUgY29vcmRpbmF0ZXMgYXMgcGxhY2Vob2xkZXJcbiAgICAgICAgICBjb3N0OiA1MCxcbiAgICAgICAgfSxcbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gQ3JlYXRlIG1vY2sgYnVkZ2V0IGJhc2VkIG9uIHByZWZlcmVuY2VzXG4gIGxldCBhY2NvbW1vZGF0aW9uQ29zdCA9IDA7XG4gIHN3aXRjaCAoc3VydmV5RGF0YS5idWRnZXQpIHtcbiAgICBjYXNlICdidWRnZXQnOlxuICAgICAgYWNjb21tb2RhdGlvbkNvc3QgPSA3NTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vZGVyYXRlJzpcbiAgICAgIGFjY29tbW9kYXRpb25Db3N0ID0gMTUwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbHV4dXJ5JzpcbiAgICAgIGFjY29tbW9kYXRpb25Db3N0ID0gMzAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGFjY29tbW9kYXRpb25Db3N0ID0gMTUwO1xuICB9XG4gIFxuICBjb25zdCB0b3RhbEFjY29tbW9kYXRpb24gPSBhY2NvbW1vZGF0aW9uQ29zdCAqIGR1cmF0aW9uRGF5cztcbiAgY29uc3QgdG90YWxGb29kID0gNjAgKiBkdXJhdGlvbkRheXM7XG4gIGNvbnN0IHRvdGFsQWN0aXZpdGllcyA9IDkwICogZHVyYXRpb25EYXlzO1xuICBjb25zdCB0b3RhbFRyYW5zcG9ydCA9IDMwICogZHVyYXRpb25EYXlzO1xuICBcbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gJHtzdXJ2ZXlEYXRhLnB1cnBvc2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdXJ2ZXlEYXRhLnB1cnBvc2Uuc2xpY2UoMSl9IFRyaXBgLFxuICAgIGRlc3RpbmF0aW9uOiBzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9uLFxuICAgIGRhdGVzOiB7XG4gICAgICBzdGFydDogc3VydmV5RGF0YS5zdGFydERhdGUsXG4gICAgICBlbmQ6IHN1cnZleURhdGEuZW5kRGF0ZSxcbiAgICB9LFxuICAgIGRheXMsXG4gICAgYWNjb21tb2RhdGlvbjogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBgJHtzdXJ2ZXlEYXRhLmRlc3RpbmF0aW9ufSBIb3RlbGAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQSBjb21mb3J0YWJsZSBob3RlbCBpbiBhIGNvbnZlbmllbnQgbG9jYXRpb24uJyxcbiAgICAgICAgbG9jYXRpb246IGBDZW50cmFsICR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn1gLFxuICAgICAgICBwcmljZVBlck5pZ2h0OiBhY2NvbW1vZGF0aW9uQ29zdFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogYCR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gQm91dGlxdWUgU3RheWAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQSBjaGFybWluZyBib3V0aXF1ZSBhY2NvbW1vZGF0aW9uIHdpdGggbG9jYWwgY2hhcmFjdGVyLicsXG4gICAgICAgIGxvY2F0aW9uOiBgSGlzdG9yaWMgRGlzdHJpY3QsICR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn1gLFxuICAgICAgICBwcmljZVBlck5pZ2h0OiBhY2NvbW1vZGF0aW9uQ29zdCAqIDEuMlxuICAgICAgfVxuICAgIF0sXG4gICAgdHJhbnNwb3J0YXRpb246IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ1B1YmxpYyBUcmFuc2l0JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDb252ZW5pZW50IGFuZCBhZmZvcmRhYmxlIHB1YmxpYyB0cmFuc3BvcnRhdGlvbiBuZXR3b3JrLicsXG4gICAgICAgIGVzdGltYXRlZENvc3Q6IHRvdGFsVHJhbnNwb3J0ICogMC41XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnVGF4aS9SaWRlc2hhcmUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ09uLWRlbWFuZCByaWRlcyBmb3IgY29udmVuaWVuY2UuJyxcbiAgICAgICAgZXN0aW1hdGVkQ29zdDogdG90YWxUcmFuc3BvcnQgKiAwLjVcbiAgICAgIH1cbiAgICBdLFxuICAgIGJ1ZGdldDoge1xuICAgICAgYWNjb21tb2RhdGlvbjogdG90YWxBY2NvbW1vZGF0aW9uLFxuICAgICAgZm9vZDogdG90YWxGb29kLFxuICAgICAgYWN0aXZpdGllczogdG90YWxBY3Rpdml0aWVzLFxuICAgICAgdHJhbnNwb3J0OiB0b3RhbFRyYW5zcG9ydCxcbiAgICAgIHRvdGFsOiB0b3RhbEFjY29tbW9kYXRpb24gKyB0b3RhbEZvb2QgKyB0b3RhbEFjdGl2aXRpZXMgKyB0b3RhbFRyYW5zcG9ydFxuICAgIH1cbiAgfTtcbn0gIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImdlbmVyYXRlSm9iSWQiLCJwcm9jZXNzSXRpbmVyYXJ5Sm9iIiwiY3JlYXRlSm9iIiwidXBkYXRlSm9iU3RhdHVzIiwiZ2V0Sm9iU3RhdHVzIiwic3VwYWJhc2UiLCJydW50aW1lIiwibWF4RHVyYXRpb24iLCJPUEVOQUlfQVBJX0tFWSIsInByb2Nlc3MiLCJlbnYiLCJpc1Byb2R1Y3Rpb24iLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsIkJvb2xlYW4iLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIlBPU1QiLCJyZXF1ZXN0IiwiY29uc29sZSIsImxvZyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm5vZGVFbnYiLCJoYXNTdXBhYmFzZVVybCIsImhhc1N1cGFiYXNlS2V5IiwidXJsTGVuZ3RoIiwibGVuZ3RoIiwia2V5TGVuZ3RoIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwibWVzc2FnZSIsImhpbnQiLCJjb2RlIiwiY29ubkVycm9yIiwiZGV0YWlscyIsInRvU3RyaW5nIiwic3VydmV5RGF0YSIsImpzb24iLCJkZXN0aW5hdGlvbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJwdXJwb3NlIiwiYnVkZ2V0IiwicHJlZmVyZW5jZXMiLCJqb2JJZCIsInN0YXJ0c1dpdGgiLCJtb2NrSXRpbmVyYXJ5IiwiY3JlYXRlTW9ja0l0aW5lcmFyeSIsInVwZGF0ZVJlc3VsdCIsInJlc3VsdCIsIml0aW5lcmFyeSIsInByb21wdCIsImdlbmVyYXRlUHJvbXB0Iiwic3RhdHVzIiwiam9iQ3JlYXRlZCIsInN0YXR1c0NoZWNrIiwic3RhdHVzQ2hlY2tFcnJvciIsInN0YXR1c1VwZGF0ZVN1Y2Nlc3MiLCJ0aGVuIiwiY2F0Y2giLCJlIiwic2V0VGltZW91dCIsInVwZGF0ZUVycm9yIiwic2V0SG91cnMiLCJkaWZmVGltZSIsImdldFRpbWUiLCJkaWZmRGF5cyIsIk1hdGgiLCJmbG9vciIsImR1cmF0aW9uRGF5cyIsInN0YXJ0VGltZXN0YW1wIiwiZW5kVGltZXN0YW1wIiwicHJlZmVyZW5jZXNUZXh0Iiwiam9pbiIsImJ1ZGdldExldmVsIiwicHVycG9zZVRleHQiLCJmb3JtYXREYXRlIiwiZGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIndlZWtkYXkiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJkYXlzIiwiaSIsImN1cnJlbnREYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJwdXNoIiwic3BsaXQiLCJhY3Rpdml0aWVzIiwiaWQiLCJ0aW1lIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImxvY2F0aW9uIiwiY29vcmRpbmF0ZXMiLCJsYXQiLCJsbmciLCJjb3N0IiwiYWNjb21tb2RhdGlvbkNvc3QiLCJ0b3RhbEFjY29tbW9kYXRpb24iLCJ0b3RhbEZvb2QiLCJ0b3RhbEFjdGl2aXRpZXMiLCJ0b3RhbFRyYW5zcG9ydCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJkYXRlcyIsInN0YXJ0IiwiZW5kIiwiYWNjb21tb2RhdGlvbiIsIm5hbWUiLCJwcmljZVBlck5pZ2h0IiwidHJhbnNwb3J0YXRpb24iLCJ0eXBlIiwiZXN0aW1hdGVkQ29zdCIsImZvb2QiLCJ0cmFuc3BvcnQiLCJ0b3RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/generate-itinerary/route.ts\n");

/***/ }),

/***/ "(rsc)/./app/api/job-processor.ts":
/*!**********************************!*\
  !*** ./app/api/job-processor.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateJobId: () => (/* binding */ generateJobId),\n/* harmony export */   processItineraryJob: () => (/* binding */ processItineraryJob)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n\n// Helper function to generate a unique job ID\nfunction generateJobId() {\n    const timestamp = Date.now();\n    // Use a simple format with just the timestamp to ensure consistency across environments\n    return `job_${timestamp}`;\n}\n// Process the itinerary generation in the background\nasync function processItineraryJob(jobId, surveyData, generatePrompt, OPENAI_API_KEY) {\n    try {\n        console.log(`[${jobId}] Starting itinerary generation process...`);\n        // Update status to processing (already done in the caller, but make sure)\n        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"processing\");\n        // Create the prompt for GPT\n        const prompt = generatePrompt(surveyData);\n        console.log(`[${jobId}] Generated prompt (${prompt.length} chars)`);\n        // Make the OpenAI API call\n        console.log(`[${jobId}] Calling OpenAI API...`);\n        const startTime = Date.now();\n        // Check if we have a valid API key first\n        if (!OPENAI_API_KEY || !OPENAI_API_KEY.startsWith(\"sk-\")) {\n            console.error(`[${jobId}] Invalid OpenAI API key`);\n            await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                error: \"Invalid OpenAI API key configuration. Please check your environment variables.\"\n            });\n            return;\n        }\n        // Create AbortController for timeout handling\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), 45000); // 45 second timeout\n        try {\n            const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${OPENAI_API_KEY}`\n                },\n                body: JSON.stringify({\n                    model: \"gpt-3.5-turbo\",\n                    messages: [\n                        {\n                            role: \"system\",\n                            content: 'You are an expert travel planner. Generate a detailed travel itinerary based on the user\\'s preferences. Return your response in a structured JSON format only, with no additional text, explanation, or markdown formatting. Do not wrap the JSON in code blocks. Ensure all property names use double quotes. IMPORTANT: Every activity MUST include a valid \"coordinates\" object with \"lat\" and \"lng\" numerical values - never omit coordinates or use empty objects. Return a valid JSON object that can be parsed with JSON.parse().'\n                        },\n                        {\n                            role: \"user\",\n                            content: prompt\n                        }\n                    ],\n                    temperature: 0.7,\n                    max_tokens: 3000\n                }),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId); // Clear the timeout if request completes\n            const responseTime = Date.now() - startTime;\n            console.log(`[${jobId}] OpenAI API response received in ${responseTime}ms`);\n            if (!response.ok) {\n                const error = await response.json();\n                console.error(`[${jobId}] OpenAI API error:`, error);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                    error: `Failed to generate itinerary: ${error.error?.message || \"API error\"}`\n                });\n                return;\n            }\n            const data = await response.json();\n            console.log(`[${jobId}] OpenAI response received with ${data.usage?.total_tokens || \"unknown\"} tokens`);\n            const itineraryContent = data.choices[0].message.content;\n            console.log(`[${jobId}] Content length: ${itineraryContent.length} characters`);\n            // Parse the JSON response with better error handling\n            try {\n                console.log(`[${jobId}] Parsing JSON response...`);\n                // Try direct parse first\n                let itinerary;\n                try {\n                    itinerary = JSON.parse(itineraryContent);\n                    console.log(`[${jobId}] JSON parsed successfully on first attempt`);\n                } catch (err) {\n                    const parseError = err;\n                    console.error(`[${jobId}] Initial JSON parse failed:`, parseError.message);\n                    // Sometimes the API might return markdown-formatted JSON with backticks or extra text\n                    // Try to extract JSON content from the response\n                    const jsonMatch = itineraryContent.match(/\\{[\\s\\S]*\\}/);\n                    if (jsonMatch) {\n                        try {\n                            console.log(`[${jobId}] Attempting to extract JSON from response...`);\n                            itinerary = JSON.parse(jsonMatch[0]);\n                            console.log(`[${jobId}] JSON extracted and parsed successfully`);\n                        } catch (err2) {\n                            const extractError = err2;\n                            console.error(`[${jobId}] Failed to extract valid JSON:`, extractError.message);\n                            // If we can't parse it, throw the original error\n                            throw parseError;\n                        }\n                    } else {\n                        console.error(`[${jobId}] No JSON object found in response`);\n                        throw parseError;\n                    }\n                }\n                // Quick validation of the itinerary\n                if (!itinerary || typeof itinerary !== \"object\") {\n                    throw new Error(\"Parsed result is not a valid object\");\n                }\n                console.log(`[${jobId}] Validating coordinates...`);\n                // Ensure coordinates exist for all activities\n                ensureValidCoordinates(itinerary);\n                console.log(`[${jobId}] Coordinates validated successfully`);\n                // Update job status with the successful result\n                console.log(`[${jobId}] Updating job status to completed...`);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"completed\", {\n                    result: {\n                        itinerary,\n                        prompt\n                    }\n                });\n                console.log(`[${jobId}] Job completed successfully!`);\n            } catch (err) {\n                const parseError = err;\n                console.error(`[${jobId}] Failed to parse itinerary JSON:`, parseError);\n                console.error(`[${jobId}] Raw content sample:`, itineraryContent.substring(0, 200));\n                // Log the position where the error occurred if available\n                if (parseError instanceof SyntaxError && parseError.message.includes(\"position\")) {\n                    const positionMatch = parseError.message.match(/position (\\d+)/);\n                    if (positionMatch) {\n                        const position = parseInt(positionMatch[1]);\n                        const errorContext = itineraryContent.substring(Math.max(0, position - 30), Math.min(itineraryContent.length, position + 30));\n                        console.error(`[${jobId}] Error context around position ${position}:`, errorContext);\n                    }\n                }\n                console.log(`[${jobId}] Updating job status to failed due to parsing error...`);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                    error: \"Unable to parse the generated itinerary data\",\n                    result: {\n                        rawContent: itineraryContent.substring(0, 500),\n                        errorMessage: parseError.message\n                    }\n                });\n            }\n        } catch (fetchError) {\n            clearTimeout(timeoutId);\n            if (fetchError.name === \"AbortError\") {\n                console.error(`[${jobId}] OpenAI API request timed out after 45 seconds`);\n                await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                    error: \"The request to generate an itinerary timed out. Please try again.\"\n                });\n                return;\n            }\n            // Re-throw for the outer catch block to handle\n            throw fetchError;\n        }\n    } catch (error) {\n        console.error(`[${jobId}] Error processing itinerary job:`, error);\n        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n            error: error.message || \"Unknown error\"\n        });\n    }\n}\n// Helper function to ensure all activities have valid coordinates\nfunction ensureValidCoordinates(itinerary) {\n    if (!itinerary.days || !Array.isArray(itinerary.days)) {\n        itinerary.days = [];\n        return;\n    }\n    console.log(\"Validating coordinates for all activities...\");\n    let issuesFixed = 0;\n    for (const day of itinerary.days){\n        if (!day.activities || !Array.isArray(day.activities)) {\n            day.activities = [];\n            continue;\n        }\n        for (const activity of day.activities){\n            // Skip if not an object\n            if (!activity || typeof activity !== \"object\") continue;\n            // Ensure coordinates exist and are properly formatted\n            if (!activity.coordinates || typeof activity.coordinates !== \"object\") {\n                console.log(`Missing coordinates for activity \"${activity.title}\", adding default coordinates`);\n                activity.coordinates = {\n                    lat: 40.7128,\n                    lng: -74.0060\n                }; // Default to NYC coordinates\n                issuesFixed++;\n            } else {\n                // Make sure lat and lng are numbers\n                let coordinateFixed = false;\n                if (typeof activity.coordinates.lat !== \"number\") {\n                    console.log(`Invalid lat coordinate for activity \"${activity.title}\": ${activity.coordinates.lat} (${typeof activity.coordinates.lat})`);\n                    activity.coordinates.lat = parseFloat(activity.coordinates.lat) || 40.7128;\n                    coordinateFixed = true;\n                    issuesFixed++;\n                }\n                if (typeof activity.coordinates.lng !== \"number\") {\n                    console.log(`Invalid lng coordinate for activity \"${activity.title}\": ${activity.coordinates.lng} (${typeof activity.coordinates.lng})`);\n                    activity.coordinates.lng = parseFloat(activity.coordinates.lng) || -74.0060;\n                    coordinateFixed = true;\n                    issuesFixed++;\n                }\n                if (coordinateFixed) {\n                    console.log(`Fixed coordinates for activity \"${activity.title}\": ${JSON.stringify(activity.coordinates)}`);\n                }\n            }\n        }\n    }\n    console.log(`Coordinates validation complete. Fixed ${issuesFixed} issues.`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxLQUFLLENBQUMsR0FBRyxFQUFFRixTQUFTQyxXQUFXLENBQUNHLEdBQUcsQ0FBQyxFQUFFLEVBQUUsT0FBT0osU0FBU0MsV0FBVyxDQUFDRyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUN2SUosU0FBU0MsV0FBVyxDQUFDRyxHQUFHLEdBQUdFLFdBQVdOLFNBQVNDLFdBQVcsQ0FBQ0csR0FBRyxLQUFLLENBQUM7b0JBQ3BFQyxrQkFBa0I7b0JBQ2xCUjtnQkFDRjtnQkFFQSxJQUFJUSxpQkFBaUI7b0JBQ25CekUsUUFBUUMsR0FBRyxDQUFDLENBQUMsZ0NBQWdDLEVBQUVtRSxTQUFTRSxLQUFLLENBQUMsR0FBRyxFQUFFcEQsS0FBS0MsU0FBUyxDQUFDaUQsU0FBU0MsV0FBVyxFQUFFLENBQUM7Z0JBQzNHO1lBQ0Y7UUFDRjtJQUNGO0lBRUFyRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyx1Q0FBdUMsRUFBRWdFLFlBQVksUUFBUSxDQUFDO0FBQzdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Ly4vYXBwL2FwaS9qb2ItcHJvY2Vzc29yLnRzPzlmZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXBkYXRlSm9iU3RhdHVzIH0gZnJvbSAnLi4vLi4vbGliL3N1cGFiYXNlJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgdW5pcXVlIGpvYiBJRFxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSm9iSWQoKSB7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIC8vIFVzZSBhIHNpbXBsZSBmb3JtYXQgd2l0aCBqdXN0IHRoZSB0aW1lc3RhbXAgdG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFjcm9zcyBlbnZpcm9ubWVudHNcbiAgcmV0dXJuIGBqb2JfJHt0aW1lc3RhbXB9YDtcbn1cblxuLy8gUHJvY2VzcyB0aGUgaXRpbmVyYXJ5IGdlbmVyYXRpb24gaW4gdGhlIGJhY2tncm91bmRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSXRpbmVyYXJ5Sm9iKGpvYklkOiBzdHJpbmcsIHN1cnZleURhdGE6IGFueSwgZ2VuZXJhdGVQcm9tcHQ6IEZ1bmN0aW9uLCBPUEVOQUlfQVBJX0tFWTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYFske2pvYklkfV0gU3RhcnRpbmcgaXRpbmVyYXJ5IGdlbmVyYXRpb24gcHJvY2Vzcy4uLmApO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0dXMgdG8gcHJvY2Vzc2luZyAoYWxyZWFkeSBkb25lIGluIHRoZSBjYWxsZXIsIGJ1dCBtYWtlIHN1cmUpXG4gICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAncHJvY2Vzc2luZycpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgcHJvbXB0IGZvciBHUFRcbiAgICBjb25zdCBwcm9tcHQgPSBnZW5lcmF0ZVByb21wdChzdXJ2ZXlEYXRhKTtcbiAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBHZW5lcmF0ZWQgcHJvbXB0ICgke3Byb21wdC5sZW5ndGh9IGNoYXJzKWApO1xuICAgIFxuICAgIC8vIE1ha2UgdGhlIE9wZW5BSSBBUEkgY2FsbFxuICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIENhbGxpbmcgT3BlbkFJIEFQSS4uLmApO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIHZhbGlkIEFQSSBrZXkgZmlyc3RcbiAgICBpZiAoIU9QRU5BSV9BUElfS0VZIHx8ICFPUEVOQUlfQVBJX0tFWS5zdGFydHNXaXRoKCdzay0nKSkge1xuICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBJbnZhbGlkIE9wZW5BSSBBUEkga2V5YCk7XG4gICAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICBlcnJvcjogJ0ludmFsaWQgT3BlbkFJIEFQSSBrZXkgY29uZmlndXJhdGlvbi4gUGxlYXNlIGNoZWNrIHlvdXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLicgXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIEFib3J0Q29udHJvbGxlciBmb3IgdGltZW91dCBoYW5kbGluZ1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDQ1MDAwKTsgLy8gNDUgc2Vjb25kIHRpbWVvdXRcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9jaGF0L2NvbXBsZXRpb25zJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke09QRU5BSV9BUElfS0VZfWAsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8nLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICAgICAgICBjb250ZW50OiAnWW91IGFyZSBhbiBleHBlcnQgdHJhdmVsIHBsYW5uZXIuIEdlbmVyYXRlIGEgZGV0YWlsZWQgdHJhdmVsIGl0aW5lcmFyeSBiYXNlZCBvbiB0aGUgdXNlclxcJ3MgcHJlZmVyZW5jZXMuIFJldHVybiB5b3VyIHJlc3BvbnNlIGluIGEgc3RydWN0dXJlZCBKU09OIGZvcm1hdCBvbmx5LCB3aXRoIG5vIGFkZGl0aW9uYWwgdGV4dCwgZXhwbGFuYXRpb24sIG9yIG1hcmtkb3duIGZvcm1hdHRpbmcuIERvIG5vdCB3cmFwIHRoZSBKU09OIGluIGNvZGUgYmxvY2tzLiBFbnN1cmUgYWxsIHByb3BlcnR5IG5hbWVzIHVzZSBkb3VibGUgcXVvdGVzLiBJTVBPUlRBTlQ6IEV2ZXJ5IGFjdGl2aXR5IE1VU1QgaW5jbHVkZSBhIHZhbGlkIFwiY29vcmRpbmF0ZXNcIiBvYmplY3Qgd2l0aCBcImxhdFwiIGFuZCBcImxuZ1wiIG51bWVyaWNhbCB2YWx1ZXMgLSBuZXZlciBvbWl0IGNvb3JkaW5hdGVzIG9yIHVzZSBlbXB0eSBvYmplY3RzLiBSZXR1cm4gYSB2YWxpZCBKU09OIG9iamVjdCB0aGF0IGNhbiBiZSBwYXJzZWQgd2l0aCBKU09OLnBhcnNlKCkuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICBjb250ZW50OiBwcm9tcHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXG4gICAgICAgICAgbWF4X3Rva2VuczogMzAwMCwgLy8gSW5jcmVhc2VkIHRva2VuIGxpbWl0IHRvIGF2b2lkIHRydW5jYXRlZCByZXNwb25zZXNcbiAgICAgICAgfSksXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7IC8vIENsZWFyIHRoZSB0aW1lb3V0IGlmIHJlcXVlc3QgY29tcGxldGVzXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBPcGVuQUkgQVBJIHJlc3BvbnNlIHJlY2VpdmVkIGluICR7cmVzcG9uc2VUaW1lfW1zYCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gT3BlbkFJIEFQSSBlcnJvcjpgLCBlcnJvcik7XG4gICAgICAgIGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ2ZhaWxlZCcsIHsgXG4gICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gZ2VuZXJhdGUgaXRpbmVyYXJ5OiAke2Vycm9yLmVycm9yPy5tZXNzYWdlIHx8ICdBUEkgZXJyb3InfWBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIE9wZW5BSSByZXNwb25zZSByZWNlaXZlZCB3aXRoICR7ZGF0YS51c2FnZT8udG90YWxfdG9rZW5zIHx8ICd1bmtub3duJ30gdG9rZW5zYCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGl0aW5lcmFyeUNvbnRlbnQgPSBkYXRhLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gQ29udGVudCBsZW5ndGg6ICR7aXRpbmVyYXJ5Q29udGVudC5sZW5ndGh9IGNoYXJhY3RlcnNgKTtcbiAgICAgIFxuICAgICAgLy8gUGFyc2UgdGhlIEpTT04gcmVzcG9uc2Ugd2l0aCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIFBhcnNpbmcgSlNPTiByZXNwb25zZS4uLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IGRpcmVjdCBwYXJzZSBmaXJzdFxuICAgICAgICBsZXQgaXRpbmVyYXJ5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGl0aW5lcmFyeSA9IEpTT04ucGFyc2UoaXRpbmVyYXJ5Q29udGVudCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gSlNPTiBwYXJzZWQgc3VjY2Vzc2Z1bGx5IG9uIGZpcnN0IGF0dGVtcHRgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VFcnJvciA9IGVyciBhcyBFcnJvcjtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtqb2JJZH1dIEluaXRpYWwgSlNPTiBwYXJzZSBmYWlsZWQ6YCwgcGFyc2VFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIEFQSSBtaWdodCByZXR1cm4gbWFya2Rvd24tZm9ybWF0dGVkIEpTT04gd2l0aCBiYWNrdGlja3Mgb3IgZXh0cmEgdGV4dFxuICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IEpTT04gY29udGVudCBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICAgIGNvbnN0IGpzb25NYXRjaCA9IGl0aW5lcmFyeUNvbnRlbnQubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xuICAgICAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIEF0dGVtcHRpbmcgdG8gZXh0cmFjdCBKU09OIGZyb20gcmVzcG9uc2UuLi5gKTtcbiAgICAgICAgICAgICAgaXRpbmVyYXJ5ID0gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBKU09OIGV4dHJhY3RlZCBhbmQgcGFyc2VkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICAgICAgICBjb25zdCBleHRyYWN0RXJyb3IgPSBlcnIyIGFzIEVycm9yO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtqb2JJZH1dIEZhaWxlZCB0byBleHRyYWN0IHZhbGlkIEpTT046YCwgZXh0cmFjdEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSBpdCwgdGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gTm8gSlNPTiBvYmplY3QgZm91bmQgaW4gcmVzcG9uc2VgKTtcbiAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBRdWljayB2YWxpZGF0aW9uIG9mIHRoZSBpdGluZXJhcnlcbiAgICAgICAgaWYgKCFpdGluZXJhcnkgfHwgdHlwZW9mIGl0aW5lcmFyeSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlZCByZXN1bHQgaXMgbm90IGEgdmFsaWQgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtqb2JJZH1dIFZhbGlkYXRpbmcgY29vcmRpbmF0ZXMuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVuc3VyZSBjb29yZGluYXRlcyBleGlzdCBmb3IgYWxsIGFjdGl2aXRpZXNcbiAgICAgICAgZW5zdXJlVmFsaWRDb29yZGluYXRlcyhpdGluZXJhcnkpO1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBDb29yZGluYXRlcyB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgam9iIHN0YXR1cyB3aXRoIHRoZSBzdWNjZXNzZnVsIHJlc3VsdFxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBVcGRhdGluZyBqb2Igc3RhdHVzIHRvIGNvbXBsZXRlZC4uLmApO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnY29tcGxldGVkJywgeyBcbiAgICAgICAgICByZXN1bHQ6IHsgXG4gICAgICAgICAgICBpdGluZXJhcnksIFxuICAgICAgICAgICAgcHJvbXB0IFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgWyR7am9iSWR9XSBKb2IgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSFgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBwYXJzZUVycm9yID0gZXJyIGFzIEVycm9yO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtqb2JJZH1dIEZhaWxlZCB0byBwYXJzZSBpdGluZXJhcnkgSlNPTjpgLCBwYXJzZUVycm9yKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBSYXcgY29udGVudCBzYW1wbGU6YCwgaXRpbmVyYXJ5Q29udGVudC5zdWJzdHJpbmcoMCwgMjAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBlcnJvciBvY2N1cnJlZCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHBhcnNlRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciAmJiBwYXJzZUVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3Bvc2l0aW9uJykpIHtcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbk1hdGNoID0gcGFyc2VFcnJvci5tZXNzYWdlLm1hdGNoKC9wb3NpdGlvbiAoXFxkKykvKTtcbiAgICAgICAgICBpZiAocG9zaXRpb25NYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwYXJzZUludChwb3NpdGlvbk1hdGNoWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29udGV4dCA9IGl0aW5lcmFyeUNvbnRlbnQuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICBNYXRoLm1heCgwLCBwb3NpdGlvbiAtIDMwKSxcbiAgICAgICAgICAgICAgTWF0aC5taW4oaXRpbmVyYXJ5Q29udGVudC5sZW5ndGgsIHBvc2l0aW9uICsgMzApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBFcnJvciBjb250ZXh0IGFyb3VuZCBwb3NpdGlvbiAke3Bvc2l0aW9ufTpgLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFske2pvYklkfV0gVXBkYXRpbmcgam9iIHN0YXR1cyB0byBmYWlsZWQgZHVlIHRvIHBhcnNpbmcgZXJyb3IuLi5gKTtcbiAgICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnZmFpbGVkJywgeyBcbiAgICAgICAgICBlcnJvcjogJ1VuYWJsZSB0byBwYXJzZSB0aGUgZ2VuZXJhdGVkIGl0aW5lcmFyeSBkYXRhJyxcbiAgICAgICAgICByZXN1bHQ6IHsgXG4gICAgICAgICAgICByYXdDb250ZW50OiBpdGluZXJhcnlDb250ZW50LnN1YnN0cmluZygwLCA1MDApLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBwYXJzZUVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChmZXRjaEVycm9yOiBhbnkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgXG4gICAgICBpZiAoZmV0Y2hFcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWyR7am9iSWR9XSBPcGVuQUkgQVBJIHJlcXVlc3QgdGltZWQgb3V0IGFmdGVyIDQ1IHNlY29uZHNgKTtcbiAgICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnZmFpbGVkJywge1xuICAgICAgICAgIGVycm9yOiAnVGhlIHJlcXVlc3QgdG8gZ2VuZXJhdGUgYW4gaXRpbmVyYXJ5IHRpbWVkIG91dC4gUGxlYXNlIHRyeSBhZ2Fpbi4nXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlLXRocm93IGZvciB0aGUgb3V0ZXIgY2F0Y2ggYmxvY2sgdG8gaGFuZGxlXG4gICAgICB0aHJvdyBmZXRjaEVycm9yO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFske2pvYklkfV0gRXJyb3IgcHJvY2Vzc2luZyBpdGluZXJhcnkgam9iOmAsIGVycm9yKTtcbiAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyB9KTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZW5zdXJlIGFsbCBhY3Rpdml0aWVzIGhhdmUgdmFsaWQgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIGVuc3VyZVZhbGlkQ29vcmRpbmF0ZXMoaXRpbmVyYXJ5OiBhbnkpIHtcbiAgaWYgKCFpdGluZXJhcnkuZGF5cyB8fCAhQXJyYXkuaXNBcnJheShpdGluZXJhcnkuZGF5cykpIHtcbiAgICBpdGluZXJhcnkuZGF5cyA9IFtdO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc29sZS5sb2coJ1ZhbGlkYXRpbmcgY29vcmRpbmF0ZXMgZm9yIGFsbCBhY3Rpdml0aWVzLi4uJyk7XG4gIGxldCBpc3N1ZXNGaXhlZCA9IDA7XG4gIFxuICBmb3IgKGNvbnN0IGRheSBvZiBpdGluZXJhcnkuZGF5cykge1xuICAgIGlmICghZGF5LmFjdGl2aXRpZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF5LmFjdGl2aXRpZXMpKSB7XG4gICAgICBkYXkuYWN0aXZpdGllcyA9IFtdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIFxuICAgIGZvciAoY29uc3QgYWN0aXZpdHkgb2YgZGF5LmFjdGl2aXRpZXMpIHtcbiAgICAgIC8vIFNraXAgaWYgbm90IGFuIG9iamVjdFxuICAgICAgaWYgKCFhY3Rpdml0eSB8fCB0eXBlb2YgYWN0aXZpdHkgIT09ICdvYmplY3QnKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIGNvb3JkaW5hdGVzIGV4aXN0IGFuZCBhcmUgcHJvcGVybHkgZm9ybWF0dGVkXG4gICAgICBpZiAoIWFjdGl2aXR5LmNvb3JkaW5hdGVzIHx8IHR5cGVvZiBhY3Rpdml0eS5jb29yZGluYXRlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYE1pc3NpbmcgY29vcmRpbmF0ZXMgZm9yIGFjdGl2aXR5IFwiJHthY3Rpdml0eS50aXRsZX1cIiwgYWRkaW5nIGRlZmF1bHQgY29vcmRpbmF0ZXNgKTtcbiAgICAgICAgYWN0aXZpdHkuY29vcmRpbmF0ZXMgPSB7IGxhdDogNDAuNzEyOCwgbG5nOiAtNzQuMDA2MCB9OyAvLyBEZWZhdWx0IHRvIE5ZQyBjb29yZGluYXRlc1xuICAgICAgICBpc3N1ZXNGaXhlZCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGxhdCBhbmQgbG5nIGFyZSBudW1iZXJzXG4gICAgICAgIGxldCBjb29yZGluYXRlRml4ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnZhbGlkIGxhdCBjb29yZGluYXRlIGZvciBhY3Rpdml0eSBcIiR7YWN0aXZpdHkudGl0bGV9XCI6ICR7YWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0fSAoJHt0eXBlb2YgYWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0fSlgKTtcbiAgICAgICAgICBhY3Rpdml0eS5jb29yZGluYXRlcy5sYXQgPSBwYXJzZUZsb2F0KGFjdGl2aXR5LmNvb3JkaW5hdGVzLmxhdCkgfHwgNDAuNzEyODtcbiAgICAgICAgICBjb29yZGluYXRlRml4ZWQgPSB0cnVlO1xuICAgICAgICAgIGlzc3Vlc0ZpeGVkKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpdml0eS5jb29yZGluYXRlcy5sbmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEludmFsaWQgbG5nIGNvb3JkaW5hdGUgZm9yIGFjdGl2aXR5IFwiJHthY3Rpdml0eS50aXRsZX1cIjogJHthY3Rpdml0eS5jb29yZGluYXRlcy5sbmd9ICgke3R5cGVvZiBhY3Rpdml0eS5jb29yZGluYXRlcy5sbmd9KWApO1xuICAgICAgICAgIGFjdGl2aXR5LmNvb3JkaW5hdGVzLmxuZyA9IHBhcnNlRmxvYXQoYWN0aXZpdHkuY29vcmRpbmF0ZXMubG5nKSB8fCAtNzQuMDA2MDtcbiAgICAgICAgICBjb29yZGluYXRlRml4ZWQgPSB0cnVlO1xuICAgICAgICAgIGlzc3Vlc0ZpeGVkKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjb29yZGluYXRlRml4ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRml4ZWQgY29vcmRpbmF0ZXMgZm9yIGFjdGl2aXR5IFwiJHthY3Rpdml0eS50aXRsZX1cIjogJHtKU09OLnN0cmluZ2lmeShhY3Rpdml0eS5jb29yZGluYXRlcyl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGNvbnNvbGUubG9nKGBDb29yZGluYXRlcyB2YWxpZGF0aW9uIGNvbXBsZXRlLiBGaXhlZCAke2lzc3Vlc0ZpeGVkfSBpc3N1ZXMuYCk7XG59ICJdLCJuYW1lcyI6WyJ1cGRhdGVKb2JTdGF0dXMiLCJnZW5lcmF0ZUpvYklkIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInByb2Nlc3NJdGluZXJhcnlKb2IiLCJqb2JJZCIsInN1cnZleURhdGEiLCJnZW5lcmF0ZVByb21wdCIsIk9QRU5BSV9BUElfS0VZIiwiY29uc29sZSIsImxvZyIsInByb21wdCIsImxlbmd0aCIsInN0YXJ0VGltZSIsInN0YXJ0c1dpdGgiLCJlcnJvciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZGVsIiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsInRlbXBlcmF0dXJlIiwibWF4X3Rva2VucyIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsInJlc3BvbnNlVGltZSIsIm9rIiwianNvbiIsIm1lc3NhZ2UiLCJkYXRhIiwidXNhZ2UiLCJ0b3RhbF90b2tlbnMiLCJpdGluZXJhcnlDb250ZW50IiwiY2hvaWNlcyIsIml0aW5lcmFyeSIsInBhcnNlIiwiZXJyIiwicGFyc2VFcnJvciIsImpzb25NYXRjaCIsIm1hdGNoIiwiZXJyMiIsImV4dHJhY3RFcnJvciIsIkVycm9yIiwiZW5zdXJlVmFsaWRDb29yZGluYXRlcyIsInJlc3VsdCIsInN1YnN0cmluZyIsIlN5bnRheEVycm9yIiwiaW5jbHVkZXMiLCJwb3NpdGlvbk1hdGNoIiwicG9zaXRpb24iLCJwYXJzZUludCIsImVycm9yQ29udGV4dCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJyYXdDb250ZW50IiwiZXJyb3JNZXNzYWdlIiwiZmV0Y2hFcnJvciIsIm5hbWUiLCJkYXlzIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNzdWVzRml4ZWQiLCJkYXkiLCJhY3Rpdml0aWVzIiwiYWN0aXZpdHkiLCJjb29yZGluYXRlcyIsInRpdGxlIiwibGF0IiwibG5nIiwiY29vcmRpbmF0ZUZpeGVkIiwicGFyc2VGbG9hdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/job-processor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createJob: () => (/* binding */ createJob),\n/* harmony export */   getJobStatus: () => (/* binding */ getJobStatus),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   updateJobStatus: () => (/* binding */ updateJobStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n// Explicitly log all environment variables for debugging\nconsole.log(\"NODE_ENV:\", \"development\");\nconsole.log(\"Environment Variables Overview:\", {\n    hasProcessEnv: typeof process !== \"undefined\" && !!process.env,\n    nodeEnv: \"development\",\n    hasSbUrl: \"NEXT_PUBLIC_SUPABASE_URL\" in process.env,\n    hasSbKey: \"NEXT_PUBLIC_SUPABASE_ANON_KEY\" in process.env,\n    nextConfig: \"string\" === \"string\",\n    envVarCount: Object.keys(process.env).filter((key)=>key.startsWith(\"NEXT_\")).length\n});\n// Supabase client setup\n// Directly access variables for debugging rather than using || '' pattern initially\nlet supabaseUrl = \"https://toaiekqwflojwicejvne.supabase.co\";\nlet supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\";\n// Debug Supabase setup without exposing keys\nconsole.log(\"Direct Supabase URL:\", supabaseUrl?.substring(0, 12) + \"...\" || 0);\nconsole.log(\"Direct Supabase Key:\", supabaseAnonKey?.substring(0, 6) + \"...\" || 0);\n// Fallback to empty string if undefined\nsupabaseUrl = supabaseUrl || \"\";\nsupabaseAnonKey = supabaseAnonKey || \"\";\n// Debug Supabase setup without exposing keys\nconsole.log(\"Supabase configuration check:\", {\n    hasUrl: Boolean(supabaseUrl),\n    urlLength: supabaseUrl?.length || 0,\n    urlPrefix: supabaseUrl?.substring(0, 8) || \"\",\n    hasKey: Boolean(supabaseAnonKey),\n    keyLength: supabaseAnonKey?.length || 0,\n    keyPrefix: supabaseAnonKey?.substring(0, 4) || \"\"\n});\n// Check if Supabase is configured properly\nconst isSupabaseConfigured = Boolean(supabaseUrl && supabaseAnonKey);\n// In-memory store to track if Supabase connectivity failed during runtime\nlet supabaseDisabled = false;\n// Initialize the Supabase client with explicit options for better reliability\nconst supabase = isSupabaseConfigured ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    },\n    global: {\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    },\n    db: {\n        schema: \"public\"\n    }\n}) : (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(\"https://placeholder-url.supabase.co\", \"placeholder-key\", {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    }\n});\n// Log initialization status\nif (!isSupabaseConfigured) {\n    console.log(\"Supabase not properly configured. Using in-memory job storage as fallback.\");\n} else {\n    console.log(\"Supabase client initialized, verifying connection...\");\n    // Attempt to verify connection and ensure the jobs table exists\n    verifySupabaseConnection().catch((err)=>{\n        console.warn(\"Failed to verify Supabase connection:\", err.message);\n    });\n}\n// In-memory fallback store for development or when Supabase isn't configured\nconst inMemoryJobs = {};\n// Function to verify the Supabase connection\nasync function verifySupabaseConnection() {\n    if (!isSupabaseConfigured) return;\n    try {\n        console.log(\"Checking Supabase connection...\");\n        // First try to directly query if the jobs table exists\n        const { data, error } = await supabase.from(\"jobs\").select(\"*\").limit(1);\n        if (error) {\n            // Table might not exist\n            if (error.code === \"42P01\") {\n                console.log(\"Jobs table does not exist, will attempt to create it\");\n                await ensureJobsTableExists();\n            } else {\n                console.error(\"Supabase connection verification failed:\", {\n                    message: error.message,\n                    code: error.code,\n                    details: error.details\n                });\n            }\n        } else {\n            console.log(\"Supabase connection verified successfully, jobs table exists\");\n            // Check to see if we have the right columns\n            await checkTableStructure(data);\n        }\n    } catch (error) {\n        console.error(\"Error verifying Supabase connection:\", {\n            message: error.message,\n            stack: error.stack?.substring(0, 200)\n        });\n        // If this is a network error, disable Supabase\n        if (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\") || error instanceof TypeError) {\n            console.warn(\"Disabling Supabase due to connection issues\");\n            supabaseDisabled = true;\n        }\n    }\n}\n// Check and adapt to existing table structure\nasync function checkTableStructure(sampleData) {\n    if (sampleData && sampleData.length > 0) {\n        // Log the structure we found for debugging\n        const firstRow = sampleData[0];\n        console.log(\"Found existing jobs table with columns:\", Object.keys(firstRow).join(\", \"));\n    }\n}\n// Function to check and create the jobs table if it doesn't exist\nasync function ensureJobsTableExists() {\n    if (!isSupabaseConfigured) return;\n    try {\n        console.log(\"Attempting to create jobs table...\");\n        // Check if we have permission to execute SQL\n        try {\n            // First, try to create a simple table with the minimum required fields\n            const createTableSQL = `\n        CREATE TABLE IF NOT EXISTS jobs (\n          id BIGINT PRIMARY KEY,\n          status TEXT,\n          result JSONB,\n          error TEXT,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n        );\n      `;\n            const { error: createError } = await supabase.rpc(\"execute_sql\", {\n                sql: createTableSQL\n            });\n            if (createError) {\n                console.error(\"Failed to create jobs table via SQL:\", createError);\n                // Try an alternative approach - using the insert API\n                console.log(\"Trying to create jobs table via insert...\");\n                const { error: insertError } = await supabase.from(\"jobs\").insert({\n                    id: 0,\n                    status: \"test\",\n                    result: null,\n                    error: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                });\n                if (insertError) {\n                    // If Supabase doesn't let us create the table, log what needs to be created\n                    console.error(\"Cannot create jobs table automatically:\", insertError);\n                    console.error(\"Please create the jobs table manually with this SQL:\");\n                    console.error(createTableSQL);\n                } else {\n                    console.log(\"Jobs table created successfully through insert\");\n                    // Clean up test record\n                    await supabase.from(\"jobs\").delete().eq(\"id\", 0);\n                }\n            } else {\n                console.log(\"Jobs table created successfully through SQL\");\n            }\n        } catch (sqlError) {\n            console.error(\"Error executing SQL:\", sqlError.message);\n        }\n    } catch (error) {\n        console.error(\"Error ensuring jobs table exists:\", error.message);\n    // This error is handled gracefully, we'll just use in-memory storage\n    }\n}\n// Convert string ID to a numeric hash if needed for Supabase compatibility\nfunction getDbCompatibleId(id) {\n    // If the ID is already numeric, return it as is\n    if (!isNaN(Number(id))) {\n        return Number(id);\n    }\n    // For job IDs that start with a timestamp (job_ or debug_), extract the timestamp\n    // This ensures consistent ID generation across environments\n    const timestampMatch = id.match(/^(job|debug|test)_(\\d+)/);\n    if (timestampMatch && !isNaN(Number(timestampMatch[2]))) {\n        // Use the timestamp portion as the numeric ID\n        return Number(timestampMatch[2]);\n    }\n    // For any other IDs, use a hash function to generate a numeric ID\n    // This is useful for non-standard job IDs\n    let hash = 0;\n    const prime = 31; // Use a prime number for better distribution\n    for(let i = 0; i < id.length; i++){\n        // Get the character code\n        const char = id.charCodeAt(i);\n        // Multiply the current hash by the prime and add the character code\n        hash = Math.imul(hash, prime) + char | 0;\n    }\n    // Ensure positive number by using absolute value and make it large enough to avoid collisions\n    return Math.abs(hash);\n}\n// Check if Supabase should be used\nfunction shouldUseSupabase() {\n    return isSupabaseConfigured && !supabaseDisabled;\n}\n// Handle Supabase errors consistently\nfunction handleSupabaseError(error) {\n    console.error(\"Supabase operation failed:\", {\n        message: error.message,\n        name: error.name,\n        code: error.code,\n        hint: error.hint,\n        details: error.details,\n        isTypeError: error instanceof TypeError\n    });\n    // If we get a fetch error, disable Supabase for this session\n    if (error instanceof TypeError && (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\"))) {\n        console.warn(\"Disabling Supabase due to connectivity issues. Using in-memory storage as fallback.\");\n        supabaseDisabled = true;\n    }\n}\n// Function to create or update a job\nasync function updateJobStatus(jobId, status, data) {\n    // Create in-memory fallback entry\n    const memoryJob = {\n        id: jobId,\n        status: status,\n        result: data?.result || undefined,\n        error: data?.error || undefined,\n        created_at: inMemoryJobs[jobId]?.created_at || new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    // Save to in-memory store\n    inMemoryJobs[jobId] = memoryJob;\n    // If we shouldn't use Supabase, return early with success\n    if (!shouldUseSupabase()) {\n        return true;\n    }\n    try {\n        const dbId = getDbCompatibleId(jobId);\n        // Ensure result is properly serialized before sending to Supabase\n        let safeResult = null;\n        if (data?.result) {\n            try {\n                // Log coordinates before serialization if they exist\n                if (data.result?.itinerary?.days) {\n                    console.log(\"Checking coordinates before serialization...\");\n                    const days = data.result.itinerary.days;\n                    let hasCoordinateIssues = false;\n                    for(let i = 0; i < days.length; i++){\n                        const day = days[i];\n                        if (day.activities && Array.isArray(day.activities)) {\n                            for(let j = 0; j < day.activities.length; j++){\n                                const activity = day.activities[j];\n                                if (!activity.coordinates || typeof activity.coordinates !== \"object\") {\n                                    console.error(`Missing coordinates in day ${i}, activity ${j}: ${activity.title}`);\n                                    hasCoordinateIssues = true;\n                                } else {\n                                    if (activity.coordinates.lat === undefined || activity.coordinates.lng === undefined) {\n                                        console.error(`Incomplete coordinates in day ${i}, activity ${j}: ${JSON.stringify(activity.coordinates)}`);\n                                        hasCoordinateIssues = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (!hasCoordinateIssues) {\n                        console.log(\"All coordinates look valid before serialization\");\n                    }\n                }\n                // Test serialization first to catch any issues\n                JSON.stringify(data.result);\n                safeResult = data.result;\n            } catch (e) {\n                console.error(\"Failed to serialize job result to JSON:\", e);\n                safeResult = {\n                    error: \"Result contained unserializable data\"\n                };\n            }\n        }\n        console.log(`Updating job ${jobId} (dbId: ${dbId}) status to ${status}`);\n        // First, get the current job to preserve created_at\n        let created_at = memoryJob.created_at;\n        try {\n            const { data: existingJob } = await supabase.from(\"jobs\").select(\"created_at\").eq(\"id\", dbId).single();\n            if (existingJob?.created_at) {\n                created_at = existingJob.created_at;\n                console.log(`Using existing created_at timestamp: ${created_at}`);\n            } else {\n                console.log(`No existing created_at found, using default created_at: ${created_at}`);\n            }\n        } catch (err) {\n            console.log(`Could not fetch existing job, using default created_at: ${created_at}`);\n        }\n        // Now update with the preserved created_at\n        const { error } = await supabase.from(\"jobs\").upsert({\n            id: dbId,\n            status,\n            result: safeResult,\n            error: data?.error || null,\n            created_at: created_at,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"id\"\n        });\n        if (error) {\n            console.error(\"Error updating job status in Supabase:\", {\n                code: error.code,\n                message: error.message,\n                details: error.details,\n                jobId,\n                dbId,\n                status\n            });\n        } else {\n            console.log(`Successfully updated job ${jobId} in Supabase`);\n        }\n    } catch (error) {\n        handleSupabaseError(error);\n    }\n    // Always return true since we saved to in-memory storage\n    return true;\n}\n// Get the status of a job\nasync function getJobStatus(jobId) {\n    // First check in-memory cache for faster response and fallback\n    const memoryJob = inMemoryJobs[jobId];\n    // Not even in memory\n    if (!memoryJob) {\n        return {\n            status: \"not_found\"\n        };\n    }\n    // If Supabase is disabled or improperly configured, only use in-memory storage\n    if (!shouldUseSupabase()) {\n        return {\n            status: memoryJob.status,\n            result: memoryJob.result,\n            error: memoryJob.error\n        };\n    }\n    // Add retry logic for fetching status from Supabase\n    const maxRetries = 3;\n    let attempts = 0;\n    while(attempts < maxRetries){\n        try {\n            const dbId = getDbCompatibleId(jobId);\n            console.log(`Fetching job status for ${jobId} (dbId: ${dbId}) from Supabase (attempt ${attempts + 1})`);\n            const { data, error } = await supabase.from(\"jobs\").select(\"*\").eq(\"id\", dbId).maybeSingle();\n            if (error) {\n                console.error(\"Error retrieving job status from Supabase:\", {\n                    message: error.message,\n                    code: error.code,\n                    details: error.details,\n                    jobId,\n                    dbId,\n                    attempt: attempts + 1\n                });\n                attempts++;\n                if (attempts < maxRetries) {\n                    // Wait before retrying (exponential backoff)\n                    await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, attempts)));\n                    continue;\n                }\n                // Fall back to in-memory after all retries\n                console.log(`All ${maxRetries} attempts to fetch job from Supabase failed, using in-memory data`);\n                handleSupabaseError(error);\n                return {\n                    status: memoryJob.status,\n                    result: memoryJob.result,\n                    error: memoryJob.error\n                };\n            }\n            if (!data) {\n                console.log(`Job ${jobId} not found in Supabase, using in-memory data`);\n                // Not found in DB but in memory, return memory version\n                return {\n                    status: memoryJob.status,\n                    result: memoryJob.result,\n                    error: memoryJob.error\n                };\n            }\n            console.log(`Successfully retrieved job ${jobId} status from Supabase: ${data.status}`);\n            // Update in-memory store to keep in sync\n            inMemoryJobs[jobId] = {\n                id: jobId,\n                status: data.status,\n                result: data.result,\n                error: data.error,\n                created_at: data.created_at,\n                updated_at: data.updated_at\n            };\n            return {\n                status: data.status,\n                result: data.result,\n                error: data.error\n            };\n        } catch (error) {\n            attempts++;\n            console.error(`Error fetching job status (attempt ${attempts}):`, error);\n            if (attempts < maxRetries) {\n                // Wait before retrying (exponential backoff)\n                await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, attempts)));\n                continue;\n            }\n            // All retries failed, fall back to in-memory\n            handleSupabaseError(error);\n            return {\n                status: memoryJob.status,\n                result: memoryJob.result,\n                error: memoryJob.error\n            };\n        }\n    }\n    // This should never be reached due to the returns in the loop, but TypeScript needs it\n    return {\n        status: memoryJob.status,\n        result: memoryJob.result,\n        error: memoryJob.error\n    };\n}\n// Function to create a new job\nasync function createJob(jobId) {\n    // Create in-memory entry\n    const memoryJob = {\n        id: jobId,\n        status: \"queued\",\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    // Save to in-memory store\n    inMemoryJobs[jobId] = memoryJob;\n    console.log(`Created job ${jobId} in memory with status: ${memoryJob.status}`);\n    // If we shouldn't use Supabase, return early with success\n    if (!shouldUseSupabase()) {\n        console.log(`Created job ${jobId} in memory only (Supabase disabled)`);\n        return true;\n    }\n    try {\n        const dbId = getDbCompatibleId(jobId);\n        console.log(`Creating job ${jobId} (dbId: ${dbId}) in Supabase`);\n        // First try to check if the job already exists to avoid conflicts\n        const { data: existingJob, error: checkError } = await supabase.from(\"jobs\").select(\"id, status\").eq(\"id\", dbId).maybeSingle();\n        if (checkError) {\n            console.error(\"Error checking for existing job in Supabase:\", {\n                code: checkError.code,\n                message: checkError.message,\n                details: checkError.details,\n                jobId,\n                dbId\n            });\n        }\n        if (existingJob) {\n            console.log(`Job ${jobId} already exists in Supabase with status: ${existingJob.status}`);\n            return true;\n        }\n        // Insert the new job\n        const { data, error } = await supabase.from(\"jobs\").insert({\n            id: dbId,\n            status: \"queued\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        }).select();\n        if (error) {\n            console.error(\"Error creating job in Supabase:\", {\n                code: error.code,\n                message: error.message,\n                details: error.details,\n                jobId,\n                dbId\n            });\n            // If this was a unique constraint error (job already exists), that's okay\n            if (error.code === \"23505\") {\n                console.log(`Job ${jobId} already exists (constraint error), proceeding anyway`);\n                return true;\n            }\n        } else {\n            console.log(`Successfully created job ${jobId} in Supabase:`, data);\n        }\n    } catch (error) {\n        handleSupabaseError(error);\n    }\n    // Always return true since we saved to in-memory storage\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RixPQUFPO2dCQUMzQlMsU0FBUzhFLFdBQVc5RSxPQUFPO2dCQUMzQjJDO2dCQUNBRztZQUNGO1FBQ0Y7UUFFQSxJQUFJa0IsYUFBYTtZQUNmcEgsUUFBUUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFOEYsTUFBTSx5Q0FBeUMsRUFBRXFCLFlBQVlqRCxNQUFNLENBQUMsQ0FBQztZQUN4RixPQUFPO1FBQ1Q7UUFFQSxxQkFBcUI7UUFDckIsTUFBTSxFQUFFdEIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNZixTQUMzQmdCLElBQUksQ0FBQyxRQUNMa0IsTUFBTSxDQUFDO1lBQ05DLElBQUlnQztZQUNKL0IsUUFBUTtZQUNSRSxZQUFZLElBQUlDLE9BQU9DLFdBQVc7WUFDbENDLFlBQVksSUFBSUYsT0FBT0MsV0FBVztRQUNwQyxHQUNDdkIsTUFBTTtRQUVULElBQUlGLE9BQU87WUFDVDlDLFFBQVE4QyxLQUFLLENBQUMsbUNBQW1DO2dCQUMvQ0ksTUFBTUosTUFBTUksSUFBSTtnQkFDaEJQLFNBQVNHLE1BQU1ILE9BQU87Z0JBQ3RCUyxTQUFTTixNQUFNTSxPQUFPO2dCQUN0QjJDO2dCQUNBRztZQUNGO1lBRUEsMEVBQTBFO1lBQzFFLElBQUlwRCxNQUFNSSxJQUFJLEtBQUssU0FBUztnQkFDMUJsRCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUU4RixNQUFNLHFEQUFxRCxDQUFDO2dCQUMvRSxPQUFPO1lBQ1Q7UUFDRixPQUFPO1lBQ0wvRixRQUFRQyxHQUFHLENBQUMsQ0FBQyx5QkFBeUIsRUFBRThGLE1BQU0sYUFBYSxDQUFDLEVBQUVsRDtRQUNoRTtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkNEMsb0JBQW9CNUM7SUFDdEI7SUFFQSx5REFBeUQ7SUFDekQsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Ly4vbGliL3N1cGFiYXNlLnRzP2M5OWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcblxuLy8gRXhwbGljaXRseSBsb2cgYWxsIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgZGVidWdnaW5nXG5jb25zb2xlLmxvZygnTk9ERV9FTlY6JywgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpO1xuY29uc29sZS5sb2coJ0Vudmlyb25tZW50IFZhcmlhYmxlcyBPdmVydmlldzonLCB7XG4gIGhhc1Byb2Nlc3NFbnY6IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAhIXByb2Nlc3MuZW52LFxuICBub2RlRW52OiBwcm9jZXNzLmVudi5OT0RFX0VOVixcbiAgaGFzU2JVcmw6ICdORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwnIGluIHByb2Nlc3MuZW52LFxuICBoYXNTYktleTogJ05FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZJyBpbiBwcm9jZXNzLmVudixcbiAgbmV4dENvbmZpZzogdHlwZW9mIHByb2Nlc3MuZW52Lk5FWFRfQ09ORklHX0FWQUlMQUJMRSA9PT0gJ3N0cmluZycsXG4gIGVudlZhckNvdW50OiBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnTkVYVF8nKSkubGVuZ3RoXG59KTtcblxuLy8gU3VwYWJhc2UgY2xpZW50IHNldHVwXG4vLyBEaXJlY3RseSBhY2Nlc3MgdmFyaWFibGVzIGZvciBkZWJ1Z2dpbmcgcmF0aGVyIHRoYW4gdXNpbmcgfHwgJycgcGF0dGVybiBpbml0aWFsbHlcbmxldCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbmxldCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcblxuLy8gRGVidWcgU3VwYWJhc2Ugc2V0dXAgd2l0aG91dCBleHBvc2luZyBrZXlzXG5jb25zb2xlLmxvZygnRGlyZWN0IFN1cGFiYXNlIFVSTDonLCBzdXBhYmFzZVVybD8uc3Vic3RyaW5nKDAsIDEyKSArICcuLi4nIHx8ICd1bmRlZmluZWQnKTtcbmNvbnNvbGUubG9nKCdEaXJlY3QgU3VwYWJhc2UgS2V5OicsIHN1cGFiYXNlQW5vbktleT8uc3Vic3RyaW5nKDAsIDYpICsgJy4uLicgfHwgJ3VuZGVmaW5lZCcpO1xuXG4vLyBGYWxsYmFjayB0byBlbXB0eSBzdHJpbmcgaWYgdW5kZWZpbmVkXG5zdXBhYmFzZVVybCA9IHN1cGFiYXNlVXJsIHx8ICcnO1xuc3VwYWJhc2VBbm9uS2V5ID0gc3VwYWJhc2VBbm9uS2V5IHx8ICcnO1xuXG4vLyBEZWJ1ZyBTdXBhYmFzZSBzZXR1cCB3aXRob3V0IGV4cG9zaW5nIGtleXNcbmNvbnNvbGUubG9nKCdTdXBhYmFzZSBjb25maWd1cmF0aW9uIGNoZWNrOicsIHtcbiAgaGFzVXJsOiBCb29sZWFuKHN1cGFiYXNlVXJsKSxcbiAgdXJsTGVuZ3RoOiBzdXBhYmFzZVVybD8ubGVuZ3RoIHx8IDAsXG4gIHVybFByZWZpeDogc3VwYWJhc2VVcmw/LnN1YnN0cmluZygwLCA4KSB8fCAnJyxcbiAgaGFzS2V5OiBCb29sZWFuKHN1cGFiYXNlQW5vbktleSksXG4gIGtleUxlbmd0aDogc3VwYWJhc2VBbm9uS2V5Py5sZW5ndGggfHwgMCxcbiAga2V5UHJlZml4OiBzdXBhYmFzZUFub25LZXk/LnN1YnN0cmluZygwLCA0KSB8fCAnJ1xufSk7XG5cbi8vIFR5cGUgZGVmaW5pdGlvbiBmb3Igam9iIGRhdGFcbmV4cG9ydCB0eXBlIEpvYkRhdGEgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHN0YXR1czogJ3F1ZXVlZCcgfCAncHJvY2Vzc2luZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xuICByZXN1bHQ/OiBhbnk7XG4gIGVycm9yPzogc3RyaW5nO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59O1xuXG4vLyBDaGVjayBpZiBTdXBhYmFzZSBpcyBjb25maWd1cmVkIHByb3Blcmx5XG5jb25zdCBpc1N1cGFiYXNlQ29uZmlndXJlZCA9IEJvb2xlYW4oc3VwYWJhc2VVcmwgJiYgc3VwYWJhc2VBbm9uS2V5KTtcblxuLy8gSW4tbWVtb3J5IHN0b3JlIHRvIHRyYWNrIGlmIFN1cGFiYXNlIGNvbm5lY3Rpdml0eSBmYWlsZWQgZHVyaW5nIHJ1bnRpbWVcbmxldCBzdXBhYmFzZURpc2FibGVkID0gZmFsc2U7XG5cbi8vIEluaXRpYWxpemUgdGhlIFN1cGFiYXNlIGNsaWVudCB3aXRoIGV4cGxpY2l0IG9wdGlvbnMgZm9yIGJldHRlciByZWxpYWJpbGl0eVxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gaXNTdXBhYmFzZUNvbmZpZ3VyZWRcbiAgPyBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRiOiB7XG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYydcbiAgICAgIH1cbiAgICB9KVxuICA6IGNyZWF0ZUNsaWVudCgnaHR0cHM6Ly9wbGFjZWhvbGRlci11cmwuc3VwYWJhc2UuY28nLCAncGxhY2Vob2xkZXIta2V5Jywge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuLy8gTG9nIGluaXRpYWxpemF0aW9uIHN0YXR1c1xuaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkge1xuICBjb25zb2xlLmxvZygnU3VwYWJhc2Ugbm90IHByb3Blcmx5IGNvbmZpZ3VyZWQuIFVzaW5nIGluLW1lbW9yeSBqb2Igc3RvcmFnZSBhcyBmYWxsYmFjay4nKTtcbn0gZWxzZSB7XG4gIGNvbnNvbGUubG9nKCdTdXBhYmFzZSBjbGllbnQgaW5pdGlhbGl6ZWQsIHZlcmlmeWluZyBjb25uZWN0aW9uLi4uJyk7XG4gIC8vIEF0dGVtcHQgdG8gdmVyaWZ5IGNvbm5lY3Rpb24gYW5kIGVuc3VyZSB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgdmVyaWZ5U3VwYWJhc2VDb25uZWN0aW9uKCkuY2F0Y2goZXJyID0+IHtcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB2ZXJpZnkgU3VwYWJhc2UgY29ubmVjdGlvbjonLCBlcnIubWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBJbi1tZW1vcnkgZmFsbGJhY2sgc3RvcmUgZm9yIGRldmVsb3BtZW50IG9yIHdoZW4gU3VwYWJhc2UgaXNuJ3QgY29uZmlndXJlZFxuY29uc3QgaW5NZW1vcnlKb2JzOiBSZWNvcmQ8c3RyaW5nLCBKb2JEYXRhPiA9IHt9O1xuXG4vLyBGdW5jdGlvbiB0byB2ZXJpZnkgdGhlIFN1cGFiYXNlIGNvbm5lY3Rpb25cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVN1cGFiYXNlQ29ubmVjdGlvbigpIHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB0byBkaXJlY3RseSBxdWVyeSBpZiB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAubGltaXQoMSk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAvLyBUYWJsZSBtaWdodCBub3QgZXhpc3RcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnNDJQMDEnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKb2JzIHRhYmxlIGRvZXMgbm90IGV4aXN0LCB3aWxsIGF0dGVtcHQgdG8gY3JlYXRlIGl0Jyk7XG4gICAgICAgIGF3YWl0IGVuc3VyZUpvYnNUYWJsZUV4aXN0cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgY29ubmVjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOicsIHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgZGV0YWlsczogZXJyb3IuZGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNvbm5lY3Rpb24gdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5LCBqb2JzIHRhYmxlIGV4aXN0cycpO1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgdGhlIHJpZ2h0IGNvbHVtbnNcbiAgICAgIGF3YWl0IGNoZWNrVGFibGVTdHJ1Y3R1cmUoZGF0YSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIFN1cGFiYXNlIGNvbm5lY3Rpb246Jywge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFjaz8uc3Vic3RyaW5nKDAsIDIwMClcbiAgICB9KTtcbiAgICBcbiAgICAvLyBJZiB0aGlzIGlzIGEgbmV0d29yayBlcnJvciwgZGlzYWJsZSBTdXBhYmFzZVxuICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZmV0Y2ggZmFpbGVkJykgfHwgXG4gICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCduZXR3b3JrIGVycm9yJykgfHxcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aW9uIGlzc3VlcycpO1xuICAgICAgc3VwYWJhc2VEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIENoZWNrIGFuZCBhZGFwdCB0byBleGlzdGluZyB0YWJsZSBzdHJ1Y3R1cmVcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrVGFibGVTdHJ1Y3R1cmUoc2FtcGxlRGF0YTogYW55W10pIHtcbiAgaWYgKHNhbXBsZURhdGEgJiYgc2FtcGxlRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgLy8gTG9nIHRoZSBzdHJ1Y3R1cmUgd2UgZm91bmQgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IGZpcnN0Um93ID0gc2FtcGxlRGF0YVswXTtcbiAgICBjb25zb2xlLmxvZygnRm91bmQgZXhpc3Rpbmcgam9icyB0YWJsZSB3aXRoIGNvbHVtbnM6JywgT2JqZWN0LmtleXMoZmlyc3RSb3cpLmpvaW4oJywgJykpO1xuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNoZWNrIGFuZCBjcmVhdGUgdGhlIGpvYnMgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdFxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlSm9ic1RhYmxlRXhpc3RzKCkge1xuICBpZiAoIWlzU3VwYWJhc2VDb25maWd1cmVkKSByZXR1cm47XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBqb2JzIHRhYmxlLi4uJyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBwZXJtaXNzaW9uIHRvIGV4ZWN1dGUgU1FMXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0LCB0cnkgdG8gY3JlYXRlIGEgc2ltcGxlIHRhYmxlIHdpdGggdGhlIG1pbmltdW0gcmVxdWlyZWQgZmllbGRzXG4gICAgICBjb25zdCBjcmVhdGVUYWJsZVNRTCA9IGBcbiAgICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgam9icyAoXG4gICAgICAgICAgaWQgQklHSU5UIFBSSU1BUlkgS0VZLFxuICAgICAgICAgIHN0YXR1cyBURVhULFxuICAgICAgICAgIHJlc3VsdCBKU09OQixcbiAgICAgICAgICBlcnJvciBURVhULFxuICAgICAgICAgIGNyZWF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKCksXG4gICAgICAgICAgdXBkYXRlZF9hdCBUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkUgREVGQVVMVCBOT1coKVxuICAgICAgICApO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3QgeyBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnZXhlY3V0ZV9zcWwnLCB7IHNxbDogY3JlYXRlVGFibGVTUUwgfSk7XG4gICAgICBcbiAgICAgIGlmIChjcmVhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGpvYnMgdGFibGUgdmlhIFNRTDonLCBjcmVhdGVFcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgYW4gYWx0ZXJuYXRpdmUgYXBwcm9hY2ggLSB1c2luZyB0aGUgaW5zZXJ0IEFQSVxuICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIHRvIGNyZWF0ZSBqb2JzIHRhYmxlIHZpYSBpbnNlcnQuLi4nKTtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICBzdGF0dXM6ICd0ZXN0JyxcbiAgICAgICAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICAgIC8vIElmIFN1cGFiYXNlIGRvZXNuJ3QgbGV0IHVzIGNyZWF0ZSB0aGUgdGFibGUsIGxvZyB3aGF0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgY3JlYXRlIGpvYnMgdGFibGUgYXV0b21hdGljYWxseTonLCBpbnNlcnRFcnJvcik7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUGxlYXNlIGNyZWF0ZSB0aGUgam9icyB0YWJsZSBtYW51YWxseSB3aXRoIHRoaXMgU1FMOicpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY3JlYXRlVGFibGVTUUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggaW5zZXJ0Jyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgdGVzdCByZWNvcmRcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdqb2JzJykuZGVsZXRlKCkuZXEoJ2lkJywgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggU1FMJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoc3FsRXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXhlY3V0aW5nIFNRTDonLCBzcWxFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnN1cmluZyBqb2JzIHRhYmxlIGV4aXN0czonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgZ3JhY2VmdWxseSwgd2UnbGwganVzdCB1c2UgaW4tbWVtb3J5IHN0b3JhZ2VcbiAgfVxufVxuXG4vLyBDb252ZXJ0IHN0cmluZyBJRCB0byBhIG51bWVyaWMgaGFzaCBpZiBuZWVkZWQgZm9yIFN1cGFiYXNlIGNvbXBhdGliaWxpdHlcbmZ1bmN0aW9uIGdldERiQ29tcGF0aWJsZUlkKGlkOiBzdHJpbmcpOiBudW1iZXIge1xuICAvLyBJZiB0aGUgSUQgaXMgYWxyZWFkeSBudW1lcmljLCByZXR1cm4gaXQgYXMgaXNcbiAgaWYgKCFpc05hTihOdW1iZXIoaWQpKSkge1xuICAgIHJldHVybiBOdW1iZXIoaWQpO1xuICB9XG4gIFxuICAvLyBGb3Igam9iIElEcyB0aGF0IHN0YXJ0IHdpdGggYSB0aW1lc3RhbXAgKGpvYl8gb3IgZGVidWdfKSwgZXh0cmFjdCB0aGUgdGltZXN0YW1wXG4gIC8vIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW50IElEIGdlbmVyYXRpb24gYWNyb3NzIGVudmlyb25tZW50c1xuICBjb25zdCB0aW1lc3RhbXBNYXRjaCA9IGlkLm1hdGNoKC9eKGpvYnxkZWJ1Z3x0ZXN0KV8oXFxkKykvKTtcbiAgaWYgKHRpbWVzdGFtcE1hdGNoICYmICFpc05hTihOdW1iZXIodGltZXN0YW1wTWF0Y2hbMl0pKSkge1xuICAgIC8vIFVzZSB0aGUgdGltZXN0YW1wIHBvcnRpb24gYXMgdGhlIG51bWVyaWMgSURcbiAgICByZXR1cm4gTnVtYmVyKHRpbWVzdGFtcE1hdGNoWzJdKTtcbiAgfVxuXG4gIC8vIEZvciBhbnkgb3RoZXIgSURzLCB1c2UgYSBoYXNoIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbnVtZXJpYyBJRFxuICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3Igbm9uLXN0YW5kYXJkIGpvYiBJRHNcbiAgbGV0IGhhc2ggPSAwO1xuICBjb25zdCBwcmltZSA9IDMxOyAvLyBVc2UgYSBwcmltZSBudW1iZXIgZm9yIGJldHRlciBkaXN0cmlidXRpb25cbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBHZXQgdGhlIGNoYXJhY3RlciBjb2RlXG4gICAgY29uc3QgY2hhciA9IGlkLmNoYXJDb2RlQXQoaSk7XG4gICAgLy8gTXVsdGlwbHkgdGhlIGN1cnJlbnQgaGFzaCBieSB0aGUgcHJpbWUgYW5kIGFkZCB0aGUgY2hhcmFjdGVyIGNvZGVcbiAgICBoYXNoID0gTWF0aC5pbXVsKGhhc2gsIHByaW1lKSArIGNoYXIgfCAwO1xuICB9XG4gIFxuICAvLyBFbnN1cmUgcG9zaXRpdmUgbnVtYmVyIGJ5IHVzaW5nIGFic29sdXRlIHZhbHVlIGFuZCBtYWtlIGl0IGxhcmdlIGVub3VnaCB0byBhdm9pZCBjb2xsaXNpb25zXG4gIHJldHVybiBNYXRoLmFicyhoYXNoKTtcbn1cblxuLy8gQ2hlY2sgaWYgU3VwYWJhc2Ugc2hvdWxkIGJlIHVzZWRcbmZ1bmN0aW9uIHNob3VsZFVzZVN1cGFiYXNlKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNTdXBhYmFzZUNvbmZpZ3VyZWQgJiYgIXN1cGFiYXNlRGlzYWJsZWQ7XG59XG5cbi8vIEhhbmRsZSBTdXBhYmFzZSBlcnJvcnMgY29uc2lzdGVudGx5XG5mdW5jdGlvbiBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgY29uc29sZS5lcnJvcignU3VwYWJhc2Ugb3BlcmF0aW9uIGZhaWxlZDonLCB7XG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgaGludDogZXJyb3IuaGludCxcbiAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgIGlzVHlwZUVycm9yOiBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvclxuICB9KTtcbiAgXG4gIC8vIElmIHdlIGdldCBhIGZldGNoIGVycm9yLCBkaXNhYmxlIFN1cGFiYXNlIGZvciB0aGlzIHNlc3Npb25cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIFxuICAgICAgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdmZXRjaCBmYWlsZWQnKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbmV0d29yayBlcnJvcicpKSkge1xuICAgIGNvbnNvbGUud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aXZpdHkgaXNzdWVzLiBVc2luZyBpbi1tZW1vcnkgc3RvcmFnZSBhcyBmYWxsYmFjay4nKTtcbiAgICBzdXBhYmFzZURpc2FibGVkID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSm9iU3RhdHVzKFxuICBqb2JJZDogc3RyaW5nLCBcbiAgc3RhdHVzOiBzdHJpbmcsIFxuICBkYXRhPzogeyByZXN1bHQ/OiBhbnk7IGVycm9yPzogc3RyaW5nIH1cbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAvLyBDcmVhdGUgaW4tbWVtb3J5IGZhbGxiYWNrIGVudHJ5XG4gIGNvbnN0IG1lbW9yeUpvYjogSm9iRGF0YSA9IHtcbiAgICBpZDogam9iSWQsXG4gICAgc3RhdHVzOiBzdGF0dXMgYXMgYW55LFxuICAgIHJlc3VsdDogZGF0YT8ucmVzdWx0IHx8IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogZGF0YT8uZXJyb3IgfHwgdW5kZWZpbmVkLFxuICAgIGNyZWF0ZWRfYXQ6IGluTWVtb3J5Sm9ic1tqb2JJZF0/LmNyZWF0ZWRfYXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuXG4gIC8vIFNhdmUgdG8gaW4tbWVtb3J5IHN0b3JlXG4gIGluTWVtb3J5Sm9ic1tqb2JJZF0gPSBtZW1vcnlKb2I7XG5cbiAgLy8gSWYgd2Ugc2hvdWxkbid0IHVzZSBTdXBhYmFzZSwgcmV0dXJuIGVhcmx5IHdpdGggc3VjY2Vzc1xuICBpZiAoIXNob3VsZFVzZVN1cGFiYXNlKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZGJJZCA9IGdldERiQ29tcGF0aWJsZUlkKGpvYklkKTtcbiAgICBcbiAgICAvLyBFbnN1cmUgcmVzdWx0IGlzIHByb3Blcmx5IHNlcmlhbGl6ZWQgYmVmb3JlIHNlbmRpbmcgdG8gU3VwYWJhc2VcbiAgICBsZXQgc2FmZVJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGRhdGE/LnJlc3VsdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTG9nIGNvb3JkaW5hdGVzIGJlZm9yZSBzZXJpYWxpemF0aW9uIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgaWYgKGRhdGEucmVzdWx0Py5pdGluZXJhcnk/LmRheXMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgY29vcmRpbmF0ZXMgYmVmb3JlIHNlcmlhbGl6YXRpb24uLi4nKTtcbiAgICAgICAgICBjb25zdCBkYXlzID0gZGF0YS5yZXN1bHQuaXRpbmVyYXJ5LmRheXM7XG4gICAgICAgICAgbGV0IGhhc0Nvb3JkaW5hdGVJc3N1ZXMgPSBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IGRheXNbaV07XG4gICAgICAgICAgICBpZiAoZGF5LmFjdGl2aXRpZXMgJiYgQXJyYXkuaXNBcnJheShkYXkuYWN0aXZpdGllcykpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXkuYWN0aXZpdGllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2aXR5ID0gZGF5LmFjdGl2aXRpZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpdml0eS5jb29yZGluYXRlcyB8fCB0eXBlb2YgYWN0aXZpdHkuY29vcmRpbmF0ZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBNaXNzaW5nIGNvb3JkaW5hdGVzIGluIGRheSAke2l9LCBhY3Rpdml0eSAke2p9OiAke2FjdGl2aXR5LnRpdGxlfWApO1xuICAgICAgICAgICAgICAgICAgaGFzQ29vcmRpbmF0ZUlzc3VlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpdml0eS5jb29yZGluYXRlcy5sYXQgPT09IHVuZGVmaW5lZCB8fCBhY3Rpdml0eS5jb29yZGluYXRlcy5sbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbmNvbXBsZXRlIGNvb3JkaW5hdGVzIGluIGRheSAke2l9LCBhY3Rpdml0eSAke2p9OiAke0pTT04uc3RyaW5naWZ5KGFjdGl2aXR5LmNvb3JkaW5hdGVzKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29vcmRpbmF0ZUlzc3VlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaGFzQ29vcmRpbmF0ZUlzc3Vlcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FsbCBjb29yZGluYXRlcyBsb29rIHZhbGlkIGJlZm9yZSBzZXJpYWxpemF0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUZXN0IHNlcmlhbGl6YXRpb24gZmlyc3QgdG8gY2F0Y2ggYW55IGlzc3Vlc1xuICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhLnJlc3VsdCk7XG4gICAgICAgIHNhZmVSZXN1bHQgPSBkYXRhLnJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlcmlhbGl6ZSBqb2IgcmVzdWx0IHRvIEpTT046JywgZSk7XG4gICAgICAgIHNhZmVSZXN1bHQgPSB7IGVycm9yOiAnUmVzdWx0IGNvbnRhaW5lZCB1bnNlcmlhbGl6YWJsZSBkYXRhJyB9O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgam9iICR7am9iSWR9IChkYklkOiAke2RiSWR9KSBzdGF0dXMgdG8gJHtzdGF0dXN9YCk7XG4gICAgXG4gICAgLy8gRmlyc3QsIGdldCB0aGUgY3VycmVudCBqb2IgdG8gcHJlc2VydmUgY3JlYXRlZF9hdFxuICAgIGxldCBjcmVhdGVkX2F0ID0gbWVtb3J5Sm9iLmNyZWF0ZWRfYXQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdKb2IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdqb2JzJylcbiAgICAgICAgLnNlbGVjdCgnY3JlYXRlZF9hdCcpXG4gICAgICAgIC5lcSgnaWQnLCBkYklkKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ0pvYj8uY3JlYXRlZF9hdCkge1xuICAgICAgICBjcmVhdGVkX2F0ID0gZXhpc3RpbmdKb2IuY3JlYXRlZF9hdDtcbiAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIGV4aXN0aW5nIGNyZWF0ZWRfYXQgdGltZXN0YW1wOiAke2NyZWF0ZWRfYXR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgTm8gZXhpc3RpbmcgY3JlYXRlZF9hdCBmb3VuZCwgdXNpbmcgZGVmYXVsdCBjcmVhdGVkX2F0OiAke2NyZWF0ZWRfYXR9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgQ291bGQgbm90IGZldGNoIGV4aXN0aW5nIGpvYiwgdXNpbmcgZGVmYXVsdCBjcmVhdGVkX2F0OiAke2NyZWF0ZWRfYXR9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIE5vdyB1cGRhdGUgd2l0aCB0aGUgcHJlc2VydmVkIGNyZWF0ZWRfYXRcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgLnVwc2VydCh7XG4gICAgICAgIGlkOiBkYklkLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHJlc3VsdDogc2FmZVJlc3VsdCxcbiAgICAgICAgZXJyb3I6IGRhdGE/LmVycm9yIHx8IG51bGwsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IGNyZWF0ZWRfYXQsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAnaWQnXG4gICAgICB9KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgam9iIHN0YXR1cyBpbiBTdXBhYmFzZTonLCB7XG4gICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IGVycm9yLmRldGFpbHMsXG4gICAgICAgIGpvYklkLFxuICAgICAgICBkYklkLFxuICAgICAgICBzdGF0dXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgam9iICR7am9iSWR9IGluIFN1cGFiYXNlYCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG4gIFxuICAvLyBBbHdheXMgcmV0dXJuIHRydWUgc2luY2Ugd2Ugc2F2ZWQgdG8gaW4tbWVtb3J5IHN0b3JhZ2VcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEdldCB0aGUgc3RhdHVzIG9mIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iU3RhdHVzKGpvYklkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IHJlc3VsdD86IGFueTsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAvLyBGaXJzdCBjaGVjayBpbi1tZW1vcnkgY2FjaGUgZm9yIGZhc3RlciByZXNwb25zZSBhbmQgZmFsbGJhY2tcbiAgY29uc3QgbWVtb3J5Sm9iID0gaW5NZW1vcnlKb2JzW2pvYklkXTtcbiAgXG4gIC8vIE5vdCBldmVuIGluIG1lbW9yeVxuICBpZiAoIW1lbW9yeUpvYikge1xuICAgIHJldHVybiB7IHN0YXR1czogJ25vdF9mb3VuZCcgfTtcbiAgfVxuICBcbiAgLy8gSWYgU3VwYWJhc2UgaXMgZGlzYWJsZWQgb3IgaW1wcm9wZXJseSBjb25maWd1cmVkLCBvbmx5IHVzZSBpbi1tZW1vcnkgc3RvcmFnZVxuICBpZiAoIXNob3VsZFVzZVN1cGFiYXNlKCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBtZW1vcnlKb2Iuc3RhdHVzLFxuICAgICAgcmVzdWx0OiBtZW1vcnlKb2IucmVzdWx0LFxuICAgICAgZXJyb3I6IG1lbW9yeUpvYi5lcnJvclxuICAgIH07XG4gIH1cbiAgXG4gIC8vIEFkZCByZXRyeSBsb2dpYyBmb3IgZmV0Y2hpbmcgc3RhdHVzIGZyb20gU3VwYWJhc2VcbiAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gIGxldCBhdHRlbXB0cyA9IDA7XG4gIFxuICB3aGlsZSAoYXR0ZW1wdHMgPCBtYXhSZXRyaWVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRiSWQgPSBnZXREYkNvbXBhdGlibGVJZChqb2JJZCk7XG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgam9iIHN0YXR1cyBmb3IgJHtqb2JJZH0gKGRiSWQ6ICR7ZGJJZH0pIGZyb20gU3VwYWJhc2UgKGF0dGVtcHQgJHthdHRlbXB0cyArIDF9KWApO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnam9icycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgZGJJZClcbiAgICAgICAgLm1heWJlU2luZ2xlKCk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIGpvYiBzdGF0dXMgZnJvbSBTdXBhYmFzZTonLCB7XG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgIGRldGFpbHM6IGVycm9yLmRldGFpbHMsXG4gICAgICAgICAgam9iSWQsXG4gICAgICAgICAgZGJJZCxcbiAgICAgICAgICBhdHRlbXB0OiBhdHRlbXB0cyArIDFcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICBpZiAoYXR0ZW1wdHMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCAqIE1hdGgucG93KDIsIGF0dGVtcHRzKSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gaW4tbWVtb3J5IGFmdGVyIGFsbCByZXRyaWVzXG4gICAgICAgIGNvbnNvbGUubG9nKGBBbGwgJHttYXhSZXRyaWVzfSBhdHRlbXB0cyB0byBmZXRjaCBqb2IgZnJvbSBTdXBhYmFzZSBmYWlsZWQsIHVzaW5nIGluLW1lbW9yeSBkYXRhYCk7XG4gICAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbWVtb3J5Sm9iLnN0YXR1cyxcbiAgICAgICAgICByZXN1bHQ6IG1lbW9yeUpvYi5yZXN1bHQsXG4gICAgICAgICAgZXJyb3I6IG1lbW9yeUpvYi5lcnJvclxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEpvYiAke2pvYklkfSBub3QgZm91bmQgaW4gU3VwYWJhc2UsIHVzaW5nIGluLW1lbW9yeSBkYXRhYCk7XG4gICAgICAgIC8vIE5vdCBmb3VuZCBpbiBEQiBidXQgaW4gbWVtb3J5LCByZXR1cm4gbWVtb3J5IHZlcnNpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IG1lbW9yeUpvYi5zdGF0dXMsXG4gICAgICAgICAgcmVzdWx0OiBtZW1vcnlKb2IucmVzdWx0LFxuICAgICAgICAgIGVycm9yOiBtZW1vcnlKb2IuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgam9iICR7am9iSWR9IHN0YXR1cyBmcm9tIFN1cGFiYXNlOiAke2RhdGEuc3RhdHVzfWApO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgaW4tbWVtb3J5IHN0b3JlIHRvIGtlZXAgaW4gc3luY1xuICAgICAgaW5NZW1vcnlKb2JzW2pvYklkXSA9IHtcbiAgICAgICAgaWQ6IGpvYklkLFxuICAgICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICByZXN1bHQ6IGRhdGEucmVzdWx0LFxuICAgICAgICBlcnJvcjogZGF0YS5lcnJvcixcbiAgICAgICAgY3JlYXRlZF9hdDogZGF0YS5jcmVhdGVkX2F0LFxuICAgICAgICB1cGRhdGVkX2F0OiBkYXRhLnVwZGF0ZWRfYXRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogZGF0YS5zdGF0dXMsXG4gICAgICAgIHJlc3VsdDogZGF0YS5yZXN1bHQsXG4gICAgICAgIGVycm9yOiBkYXRhLmVycm9yXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhdHRlbXB0cysrO1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgam9iIHN0YXR1cyAoYXR0ZW1wdCAke2F0dGVtcHRzfSk6YCwgZXJyb3IpO1xuICAgICAgXG4gICAgICBpZiAoYXR0ZW1wdHMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nIChleHBvbmVudGlhbCBiYWNrb2ZmKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwICogTWF0aC5wb3coMiwgYXR0ZW1wdHMpKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBbGwgcmV0cmllcyBmYWlsZWQsIGZhbGwgYmFjayB0byBpbi1tZW1vcnlcbiAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBtZW1vcnlKb2Iuc3RhdHVzLFxuICAgICAgICByZXN1bHQ6IG1lbW9yeUpvYi5yZXN1bHQsXG4gICAgICAgIGVycm9yOiBtZW1vcnlKb2IuZXJyb3JcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIFxuICAvLyBUaGlzIHNob3VsZCBuZXZlciBiZSByZWFjaGVkIGR1ZSB0byB0aGUgcmV0dXJucyBpbiB0aGUgbG9vcCwgYnV0IFR5cGVTY3JpcHQgbmVlZHMgaXRcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IG1lbW9yeUpvYi5zdGF0dXMsXG4gICAgcmVzdWx0OiBtZW1vcnlKb2IucmVzdWx0LFxuICAgIGVycm9yOiBtZW1vcnlKb2IuZXJyb3JcbiAgfTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IGpvYlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUpvYihqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIC8vIENyZWF0ZSBpbi1tZW1vcnkgZW50cnlcbiAgY29uc3QgbWVtb3J5Sm9iOiBKb2JEYXRhID0ge1xuICAgIGlkOiBqb2JJZCxcbiAgICBzdGF0dXM6ICdxdWV1ZWQnLFxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbiAgXG4gIC8vIFNhdmUgdG8gaW4tbWVtb3J5IHN0b3JlXG4gIGluTWVtb3J5Sm9ic1tqb2JJZF0gPSBtZW1vcnlKb2I7XG4gIGNvbnNvbGUubG9nKGBDcmVhdGVkIGpvYiAke2pvYklkfSBpbiBtZW1vcnkgd2l0aCBzdGF0dXM6ICR7bWVtb3J5Sm9iLnN0YXR1c31gKTtcblxuICAvLyBJZiB3ZSBzaG91bGRuJ3QgdXNlIFN1cGFiYXNlLCByZXR1cm4gZWFybHkgd2l0aCBzdWNjZXNzXG4gIGlmICghc2hvdWxkVXNlU3VwYWJhc2UoKSkge1xuICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGpvYiAke2pvYklkfSBpbiBtZW1vcnkgb25seSAoU3VwYWJhc2UgZGlzYWJsZWQpYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGRiSWQgPSBnZXREYkNvbXBhdGlibGVJZChqb2JJZCk7XG4gICAgY29uc29sZS5sb2coYENyZWF0aW5nIGpvYiAke2pvYklkfSAoZGJJZDogJHtkYklkfSkgaW4gU3VwYWJhc2VgKTtcbiAgICBcbiAgICAvLyBGaXJzdCB0cnkgdG8gY2hlY2sgaWYgdGhlIGpvYiBhbHJlYWR5IGV4aXN0cyB0byBhdm9pZCBjb25mbGljdHNcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nSm9iLCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdqb2JzJylcbiAgICAgIC5zZWxlY3QoJ2lkLCBzdGF0dXMnKVxuICAgICAgLmVxKCdpZCcsIGRiSWQpXG4gICAgICAubWF5YmVTaW5nbGUoKTtcbiAgICAgIFxuICAgIGlmIChjaGVja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBmb3IgZXhpc3Rpbmcgam9iIGluIFN1cGFiYXNlOicsIHtcbiAgICAgICAgY29kZTogY2hlY2tFcnJvci5jb2RlLFxuICAgICAgICBtZXNzYWdlOiBjaGVja0Vycm9yLm1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IGNoZWNrRXJyb3IuZGV0YWlscyxcbiAgICAgICAgam9iSWQsXG4gICAgICAgIGRiSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXhpc3RpbmdKb2IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBKb2IgJHtqb2JJZH0gYWxyZWFkeSBleGlzdHMgaW4gU3VwYWJhc2Ugd2l0aCBzdGF0dXM6ICR7ZXhpc3RpbmdKb2Iuc3RhdHVzfWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIEluc2VydCB0aGUgbmV3IGpvYlxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnam9icycpXG4gICAgICAuaW5zZXJ0KHtcbiAgICAgICAgaWQ6IGRiSWQsXG4gICAgICAgIHN0YXR1czogJ3F1ZXVlZCcsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KVxuICAgICAgLnNlbGVjdCgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBqb2IgaW4gU3VwYWJhc2U6Jywge1xuICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICBqb2JJZCxcbiAgICAgICAgZGJJZFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgdW5pcXVlIGNvbnN0cmFpbnQgZXJyb3IgKGpvYiBhbHJlYWR5IGV4aXN0cyksIHRoYXQncyBva2F5XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJzIzNTA1Jykge1xuICAgICAgICBjb25zb2xlLmxvZyhgSm9iICR7am9iSWR9IGFscmVhZHkgZXhpc3RzIChjb25zdHJhaW50IGVycm9yKSwgcHJvY2VlZGluZyBhbnl3YXlgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgY3JlYXRlZCBqb2IgJHtqb2JJZH0gaW4gU3VwYWJhc2U6YCwgZGF0YSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICB9XG4gIFxuICAvLyBBbHdheXMgcmV0dXJuIHRydWUgc2luY2Ugd2Ugc2F2ZWQgdG8gaW4tbWVtb3J5IHN0b3JhZ2VcbiAgcmV0dXJuIHRydWU7XG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjb25zb2xlIiwibG9nIiwiaGFzUHJvY2Vzc0VudiIsInByb2Nlc3MiLCJlbnYiLCJub2RlRW52IiwiaGFzU2JVcmwiLCJoYXNTYktleSIsIm5leHRDb25maWciLCJORVhUX0NPTkZJR19BVkFJTEFCTEUiLCJlbnZWYXJDb3VudCIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJzdGFydHNXaXRoIiwibGVuZ3RoIiwic3VwYWJhc2VVcmwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1YnN0cmluZyIsImhhc1VybCIsIkJvb2xlYW4iLCJ1cmxMZW5ndGgiLCJ1cmxQcmVmaXgiLCJoYXNLZXkiLCJrZXlMZW5ndGgiLCJrZXlQcmVmaXgiLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsInN1cGFiYXNlRGlzYWJsZWQiLCJzdXBhYmFzZSIsImF1dGgiLCJwZXJzaXN0U2Vzc2lvbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJnbG9iYWwiLCJoZWFkZXJzIiwiZGIiLCJzY2hlbWEiLCJ2ZXJpZnlTdXBhYmFzZUNvbm5lY3Rpb24iLCJjYXRjaCIsImVyciIsIndhcm4iLCJtZXNzYWdlIiwiaW5NZW1vcnlKb2JzIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwiY29kZSIsImVuc3VyZUpvYnNUYWJsZUV4aXN0cyIsImRldGFpbHMiLCJjaGVja1RhYmxlU3RydWN0dXJlIiwic3RhY2siLCJpbmNsdWRlcyIsIlR5cGVFcnJvciIsInNhbXBsZURhdGEiLCJmaXJzdFJvdyIsImpvaW4iLCJjcmVhdGVUYWJsZVNRTCIsImNyZWF0ZUVycm9yIiwicnBjIiwic3FsIiwiaW5zZXJ0RXJyb3IiLCJpbnNlcnQiLCJpZCIsInN0YXR1cyIsInJlc3VsdCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlIiwiZXEiLCJzcWxFcnJvciIsImdldERiQ29tcGF0aWJsZUlkIiwiaXNOYU4iLCJOdW1iZXIiLCJ0aW1lc3RhbXBNYXRjaCIsIm1hdGNoIiwiaGFzaCIsInByaW1lIiwiaSIsImNoYXIiLCJjaGFyQ29kZUF0IiwiTWF0aCIsImltdWwiLCJhYnMiLCJzaG91bGRVc2VTdXBhYmFzZSIsImhhbmRsZVN1cGFiYXNlRXJyb3IiLCJuYW1lIiwiaGludCIsImlzVHlwZUVycm9yIiwidXBkYXRlSm9iU3RhdHVzIiwiam9iSWQiLCJtZW1vcnlKb2IiLCJ1bmRlZmluZWQiLCJkYklkIiwic2FmZVJlc3VsdCIsIml0aW5lcmFyeSIsImRheXMiLCJoYXNDb29yZGluYXRlSXNzdWVzIiwiZGF5IiwiYWN0aXZpdGllcyIsIkFycmF5IiwiaXNBcnJheSIsImoiLCJhY3Rpdml0eSIsImNvb3JkaW5hdGVzIiwidGl0bGUiLCJsYXQiLCJsbmciLCJKU09OIiwic3RyaW5naWZ5IiwiZSIsImV4aXN0aW5nSm9iIiwic2luZ2xlIiwidXBzZXJ0Iiwib25Db25mbGljdCIsImdldEpvYlN0YXR1cyIsIm1heFJldHJpZXMiLCJhdHRlbXB0cyIsIm1heWJlU2luZ2xlIiwiYXR0ZW1wdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInBvdyIsImNyZWF0ZUpvYiIsImNoZWNrRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();