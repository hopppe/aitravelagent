"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/generate-itinerary/route";
exports.ids = ["app/api/generate-itinerary/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_ethanhoppe_Desktop_AItravelagent_app_api_generate_itinerary_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/generate-itinerary/route.ts */ \"(rsc)/./app/api/generate-itinerary/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/generate-itinerary/route\",\n        pathname: \"/api/generate-itinerary\",\n        filename: \"route\",\n        bundlePath: \"app/api/generate-itinerary/route\"\n    },\n    resolvedPagePath: \"/Users/ethanhoppe/Desktop/AItravelagent/app/api/generate-itinerary/route.ts\",\n    nextConfigOutput,\n    userland: _Users_ethanhoppe_Desktop_AItravelagent_app_api_generate_itinerary_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/generate-itinerary/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZnZW5lcmF0ZS1pdGluZXJhcnklMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmdlbmVyYXRlLWl0aW5lcmFyeSUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmdlbmVyYXRlLWl0aW5lcmFyeSUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmV0aGFuaG9wcGUlMkZEZXNrdG9wJTJGQUl0cmF2ZWxhZ2VudCUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZldGhhbmhvcHBlJTJGRGVza3RvcCUyRkFJdHJhdmVsYWdlbnQmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQzJCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktdHJhdmVsLWFnZW50Lz80Y2UyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi9Vc2Vycy9ldGhhbmhvcHBlL0Rlc2t0b3AvQUl0cmF2ZWxhZ2VudC9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZ2VuZXJhdGUtaXRpbmVyYXJ5L3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZ2VuZXJhdGUtaXRpbmVyYXJ5XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9nZW5lcmF0ZS1pdGluZXJhcnkvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvZXRoYW5ob3BwZS9EZXNrdG9wL0FJdHJhdmVsYWdlbnQvYXBwL2FwaS9nZW5lcmF0ZS1pdGluZXJhcnkvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/generate-itinerary/route.ts":
/*!*********************************************!*\
  !*** ./app/api/generate-itinerary/route.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   generatePrompt: () => (/* binding */ generatePrompt),\n/* harmony export */   maxDuration: () => (/* binding */ maxDuration),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _job_processor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../job-processor */ \"(rsc)/./app/api/job-processor.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../lib/logger */ \"(rsc)/./lib/logger.ts\");\n\n\n\n\n// Initialize logger\nconst logger = (0,_lib_logger__WEBPACK_IMPORTED_MODULE_3__.createLogger)(\"generate-itinerary\");\n// Configure runtime for serverless function - using edge for more consistent timeout behavior\nconst runtime = \"nodejs\";\nconst maxDuration = 60; // Set max duration to 60 seconds\n// Check if running in production environment\nconst isProduction = \"development\" === \"production\";\n// Check if Supabase is properly configured\nconst isSupabaseConfigured = Boolean( true && \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\");\nasync function POST(request) {\n    try {\n        // Log key information for debugging\n        logger.info(`========== ITINERARY GENERATION REQUEST ==========`);\n        logger.info(`API Request started: ${new Date().toISOString()}`);\n        logger.info(\"Environment:\", {\n            nodeEnv: \"development\",\n            isProduction: \"development\" === \"production\"\n        });\n        // Log environment variables (without exposing actual values)\n        logger.info(\"Supabase connection details:\", {\n            hasSupabaseUrl: !!\"https://toaiekqwflojwicejvne.supabase.co\",\n            hasSupabaseKey: !!\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\",\n            urlPrefix: \"https://toaiekqwflojwicejvne.supabase.co\"?.substring(0, 10) || 0,\n            keyPrefix: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\"?.substring(0, 5) || 0,\n            urlLength: \"https://toaiekqwflojwicejvne.supabase.co\"?.length || 0,\n            keyLength: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\"?.length || 0\n        });\n        // Only test Supabase connection if properly configured\n        if (isSupabaseConfigured) {\n            try {\n                logger.info(\"Testing Supabase connection...\");\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"jobs\").select(\"*\").limit(1);\n                if (error) {\n                    logger.error(\"❌ Supabase connection test failed:\", {\n                        message: error.message,\n                        hint: error.hint || \"\",\n                        code: error.code || \"\"\n                    });\n                } else {\n                    logger.info(\"✅ Supabase connection test successful\");\n                }\n            } catch (connError) {\n                logger.error(\"❌ Supabase connection test exception:\", {\n                    message: connError.message,\n                    details: connError.toString(),\n                    name: connError.name,\n                    stack: connError.stack?.substring(0, 200)\n                });\n            }\n        } else {\n            logger.warn(\"⚠️ Skipping Supabase connection test - not configured\");\n        }\n        // Parse the request body\n        const surveyData = await request.json();\n        logger.info(\"Received survey data:\", {\n            destination: surveyData.destination,\n            startDate: surveyData.startDate,\n            endDate: surveyData.endDate,\n            purpose: surveyData.purpose,\n            budget: surveyData.budget,\n            preferences: surveyData.preferences\n        });\n        // Create a unique job ID\n        const jobId = (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.generateJobId)();\n        logger.info(`Generated new job ID: ${jobId}`);\n        // Generate the prompt on the server side\n        const prompt = generatePrompt(surveyData);\n        logger.info(`Generated prompt for job ${jobId}, length: ${prompt.length} characters`);\n        // If we're in development or testing, return mock data immediately\n        if ( true && process.env.USE_MOCK_DATA === \"true\") {\n            logger.info(\"Development mode with mock data: Returning mock data\");\n            const mockItinerary = createMockItinerary(surveyData);\n            const updateResult = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"completed\", {\n                result: {\n                    itinerary: mockItinerary,\n                    prompt: prompt\n                }\n            });\n            if (!updateResult) {\n                logger.error(\"Failed to update job status in development mode\");\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Failed to update job status\"\n                }, {\n                    status: 500\n                });\n            }\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                jobId,\n                status: \"completed\"\n            });\n        }\n        // Create a new job in Supabase\n        logger.info(\"Creating new job with ID:\", jobId);\n        let jobCreated = false;\n        let retryCount = 0;\n        const maxRetries = 3;\n        // Add retry logic for job creation\n        while(!jobCreated && retryCount < maxRetries){\n            try {\n                jobCreated = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createJob)(jobId);\n                if (!jobCreated) {\n                    logger.error(`Failed to create job on attempt ${retryCount + 1}/${maxRetries}`);\n                    retryCount++;\n                    if (retryCount < maxRetries) {\n                        // Exponential backoff\n                        await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, retryCount)));\n                    }\n                }\n            } catch (error) {\n                logger.error(`Error creating job on attempt ${retryCount + 1}/${maxRetries}:`, error);\n                retryCount++;\n                if (retryCount < maxRetries) {\n                    // Exponential backoff\n                    await new Promise((resolve)=>setTimeout(resolve, 500 * Math.pow(2, retryCount)));\n                }\n            }\n        }\n        if (!jobCreated) {\n            logger.error(\"Failed to create job after multiple attempts\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to create job in database after multiple attempts\"\n            }, {\n                status: 500\n            });\n        }\n        logger.info(`Job ${jobId} created successfully, current status: queued`);\n        // Verify the job was created properly by fetching its status\n        let statusCheck;\n        try {\n            statusCheck = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.getJobStatus)(jobId);\n            logger.info(`Initial job status check: ${statusCheck.status}`);\n            if (statusCheck.status === \"not_found\") {\n                logger.error(`Critical error: Job ${jobId} was not found immediately after creation`);\n                // Try to recreate the job one more time in case of race condition\n                jobCreated = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.createJob)(jobId);\n                if (jobCreated) {\n                    logger.info(`Job ${jobId} recreated successfully after initial not_found status`);\n                    statusCheck = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.getJobStatus)(jobId);\n                    logger.info(`Second job status check: ${statusCheck.status}`);\n                }\n            }\n        } catch (statusCheckError) {\n            logger.error(\"Error checking initial job status:\", statusCheckError);\n        }\n        // Call the Supabase Edge Function to process the itinerary\n        try {\n            logger.info(`Invoking Supabase Edge Function for job ${jobId}`);\n            // Update job status to processing\n            await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"processing\");\n            if (!isSupabaseConfigured) {\n                throw new Error(\"Supabase URL or key is missing\");\n            }\n            // Invoke the Edge Function with the generated prompt\n            const { data: functionData, error: functionError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.functions.invoke(\"generate-itinerary\", {\n                body: {\n                    jobId,\n                    surveyData,\n                    prompt\n                }\n            });\n            if (functionError) {\n                logger.error(`Error invoking Supabase Edge Function:`, functionError);\n                throw new Error(`Edge Function error: ${functionError.message || \"Unknown error\"}`);\n            }\n            logger.info(`Supabase Edge Function invoked successfully for job ${jobId}:`, functionData);\n            // If the edge function returned a result directly, process it\n            if (functionData && functionData.result) {\n                logger.info(`Processing immediate result from edge function for job ${jobId}`);\n                await (0,_job_processor__WEBPACK_IMPORTED_MODULE_1__.processItineraryResponse)(jobId, functionData.result);\n            }\n        } catch (edgeFunctionError) {\n            logger.error(`Failed to invoke Supabase Edge Function:`, edgeFunctionError);\n            // Update job status to reflect the error but don't fail the response\n            // We want the client to keep polling the job status\n            await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_2__.updateJobStatus)(jobId, \"processing\", {\n                error: `Edge function invocation error (will retry): ${edgeFunctionError.message || \"Unknown error\"}`\n            });\n        }\n        // Return immediately with the job ID\n        logger.info(`Returning response for job ${jobId} with status: processing`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            jobId,\n            status: \"processing\",\n            message: \"Your itinerary is being generated. Poll the job-status endpoint for updates.\"\n        });\n    } catch (error) {\n        logger.error(\"Error initiating itinerary generation:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: `Failed to initiate itinerary generation: ${error.message || \"Unknown error\"}`\n        }, {\n            status: 500\n        });\n    }\n}\n// Function to generate a prompt based on survey data\nfunction generatePrompt(surveyData) {\n    // Calculate trip duration - adding 1 to include both start and end date\n    const startDate = new Date(surveyData.startDate);\n    const endDate = new Date(surveyData.endDate);\n    // Set time to noon to avoid timezone issues\n    startDate.setHours(12, 0, 0, 0);\n    endDate.setHours(12, 0, 0, 0);\n    // Calculate number of days\n    const tripDuration = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;\n    // Format dates for display\n    const formattedStartDate = formatDate(startDate);\n    const formattedEndDate = formatDate(endDate);\n    // Build the preferences section\n    let preferencesText = \"\";\n    if (surveyData.preferences && surveyData.preferences.length > 0) {\n        preferencesText = \"The traveler has expressed interest in the following: \" + surveyData.preferences.join(\", \") + \". \";\n    }\n    // Construct the prompt\n    return `\nCreate a personalized travel itinerary for a trip to ${surveyData.destination} from ${formattedStartDate} to ${formattedEndDate} (${tripDuration} days).\n\nTrip purpose: ${surveyData.purpose}\nBudget level: ${surveyData.budget}\n${preferencesText}\n\nGenerate a comprehensive day-by-day travel itinerary with the following structure (as a valid JSON object):\n\n{\n  \"destination\": \"${surveyData.destination}\",\n  \"tripName\": \"<create a catchy name for this trip>\",\n  \"dates\": {\n    \"start\": \"${surveyData.startDate}\",\n    \"end\": \"${surveyData.endDate}\"\n  },\n  \"summary\": \"<brief overview of the trip highlighting key attractions and experiences>\",\n  \"days\": [\n    {\n      \"day\": 1,\n      \"date\": \"${surveyData.startDate}\",\n      \"activities\": [\n        {\n          \"time\": \"<morning/afternoon/evening>\",\n          \"title\": \"<activity name>\",\n          \"description\": \"<detailed description>\",\n          \"location\": \"<specific location name>\",\n          \"coordinates\": {\n            \"lat\": <latitude as number>,\n            \"lng\": <longitude as number>\n          },\n          \"duration\": \"<estimated duration>\",\n          \"cost\": \"<cost estimate or budget level>\"\n        },\n        ... more activities ...\n      ]\n    },\n    ... more days ...\n  ],\n  \"budgetEstimate\": {\n    \"accommodation\": <estimated total cost as number>,\n    \"food\": <estimated total cost as number>,\n    \"activities\": <estimated total cost as number>,\n    \"transportation\": <estimated total cost as number>,\n    \"total\": <total estimated cost as number>\n  },\n  \"travelTips\": [\n    \"<useful tip for this destination>\",\n    ... more tips ...\n  ]\n}\n\nRemember, EACH activity MUST include valid and accurate coordinates (latitude and longitude) as numerical values - never use empty or placeholder coordinates. Research real locations in ${surveyData.destination} and include their actual coordinates.\n\nOnly return valid JSON that can be parsed with JSON.parse(). Do not include any explanations, markdown formatting, or code blocks outside the JSON object. Ensure all property names and string values use double quotes, not single quotes.\n  `;\n}\n// Format date for display\nfunction formatDate(date) {\n    const months = [\n        \"January\",\n        \"February\",\n        \"March\",\n        \"April\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"August\",\n        \"September\",\n        \"October\",\n        \"November\",\n        \"December\"\n    ];\n    const day = date.getDate();\n    const month = months[date.getMonth()];\n    const year = date.getFullYear();\n    // Add suffix to day\n    let suffix = \"th\";\n    if (day === 1 || day === 21 || day === 31) suffix = \"st\";\n    else if (day === 2 || day === 22) suffix = \"nd\";\n    else if (day === 3 || day === 23) suffix = \"rd\";\n    return `${month} ${day}${suffix}, ${year}`;\n}\n// Helper function to create mock data for development testing\nfunction createMockItinerary(surveyData) {\n    return {\n        destination: surveyData.destination,\n        tripName: `${surveyData.purpose} trip to ${surveyData.destination}`,\n        dates: {\n            start: surveyData.startDate,\n            end: surveyData.endDate\n        },\n        summary: `A ${surveyData.budget} ${surveyData.purpose} adventure in ${surveyData.destination}, featuring ${surveyData.preferences.join(\", \")}.`,\n        days: [\n            {\n                day: 1,\n                date: surveyData.startDate,\n                activities: [\n                    {\n                        time: \"morning\",\n                        title: \"Breakfast at local cafe\",\n                        description: \"Start your day with a delicious local breakfast\",\n                        location: \"Central Cafe\",\n                        coordinates: {\n                            lat: 48.8566,\n                            lng: 2.3522\n                        },\n                        duration: \"1 hour\",\n                        cost: \"moderate\"\n                    },\n                    {\n                        time: \"afternoon\",\n                        title: \"City Tour\",\n                        description: \"Explore the main attractions of the city\",\n                        location: \"City Center\",\n                        coordinates: {\n                            lat: 48.8584,\n                            lng: 2.3536\n                        },\n                        duration: \"3 hours\",\n                        cost: surveyData.budget\n                    }\n                ]\n            },\n            {\n                day: 2,\n                date: new Date(new Date(surveyData.startDate).setDate(new Date(surveyData.startDate).getDate() + 1)).toISOString().split(\"T\")[0],\n                activities: [\n                    {\n                        time: \"morning\",\n                        title: \"Museum Visit\",\n                        description: \"Visit the famous local museum\",\n                        location: \"National Museum\",\n                        coordinates: {\n                            lat: 48.8606,\n                            lng: 2.3376\n                        },\n                        duration: \"2 hours\",\n                        cost: surveyData.budget\n                    }\n                ]\n            }\n        ],\n        budgetEstimate: {\n            accommodation: 500,\n            food: 300,\n            activities: 200,\n            transportation: 100,\n            total: 1100\n        },\n        travelTips: [\n            \"Pack comfortable walking shoes\",\n            \"Try the local specialty dishes\",\n            \"Learn a few phrases in the local language\"\n        ]\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEyQztBQUNnQztBQUNnQjtBQUN4QztBQUVuRCxvQkFBb0I7QUFDcEIsTUFBTVEsU0FBU0QseURBQVlBLENBQUM7QUFFNUIsOEZBQThGO0FBQ3ZGLE1BQU1FLFVBQVUsU0FBUztBQUN6QixNQUFNQyxjQUFjLEdBQUcsQ0FBQyxpQ0FBaUM7QUFFaEUsNkNBQTZDO0FBQzdDLE1BQU1DLGVBQWVDLGtCQUF5QjtBQUU5QywyQ0FBMkM7QUFDM0MsTUFBTUMsdUJBQXVCQyxRQUMzQkYsS0FBb0MsSUFDcENBLGtOQUF5QztBQWFwQyxlQUFlTSxLQUFLQyxPQUFnQjtJQUN6QyxJQUFJO1FBQ0Ysb0NBQW9DO1FBQ3BDWCxPQUFPWSxJQUFJLENBQUMsQ0FBQyxrREFBa0QsQ0FBQztRQUNoRVosT0FBT1ksSUFBSSxDQUFDLENBQUMscUJBQXFCLEVBQUUsSUFBSUMsT0FBT0MsV0FBVyxHQUFHLENBQUM7UUFDOURkLE9BQU9ZLElBQUksQ0FBQyxnQkFBZ0I7WUFDMUJHLFNBckNOO1lBc0NNWixjQUFjQyxrQkFBeUI7UUFDekM7UUFFQSw2REFBNkQ7UUFDN0RKLE9BQU9ZLElBQUksQ0FBQyxnQ0FBZ0M7WUFDMUNJLGdCQUFnQixDQUFDLENBQUNaLDBDQUFvQztZQUN0RGEsZ0JBQWdCLENBQUMsQ0FBQ2Isa05BQXlDO1lBQzNEYyxXQUFXZCwwQ0FBb0MsRUFBRWUsVUFBVSxHQUFHLE9BQU87WUFDckVDLFdBQVdoQixrTkFBeUMsRUFBRWUsVUFBVSxHQUFHLE1BQU07WUFDekVFLFdBQVdqQiwwQ0FBb0MsRUFBRWtCLFVBQVU7WUFDM0RDLFdBQVduQixrTkFBeUMsRUFBRWtCLFVBQVU7UUFDbEU7UUFFQSx1REFBdUQ7UUFDdkQsSUFBSWpCLHNCQUFzQjtZQUN4QixJQUFJO2dCQUNGTCxPQUFPWSxJQUFJLENBQUM7Z0JBQ1osTUFBTSxFQUFFWSxJQUFJLEVBQUVD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Vjt3QkFDRUMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsYUFBYTt3QkFDYkMsVUFBVTt3QkFDVkMsYUFBYTs0QkFDWEMsS0FBSzs0QkFDTEMsS0FBSzt3QkFDUDt3QkFDQUMsVUFBVTt3QkFDVkMsTUFBTXBFLFdBQVdNLE1BQU07b0JBQ3pCO2lCQUNEO1lBQ0g7U0FDRDtRQUNEaUUsZ0JBQWdCO1lBQ2RDLGVBQWU7WUFDZkMsTUFBTTtZQUNOZCxZQUFZO1lBQ1plLGdCQUFnQjtZQUNoQkMsT0FBTztRQUNUO1FBQ0FDLFlBQVk7WUFDVjtZQUNBO1lBQ0E7U0FDRDtJQUNIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10cmF2ZWwtYWdlbnQvLi9hcHAvYXBpL2dlbmVyYXRlLWl0aW5lcmFyeS9yb3V0ZS50cz9kODMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IGdlbmVyYXRlSm9iSWQsIHByb2Nlc3NJdGluZXJhcnlSZXNwb25zZSB9IGZyb20gJy4uL2pvYi1wcm9jZXNzb3InO1xuaW1wb3J0IHsgY3JlYXRlSm9iLCB1cGRhdGVKb2JTdGF0dXMsIGdldEpvYlN0YXR1cywgc3VwYWJhc2UgfSBmcm9tICcuLi8uLi8uLi9saWIvc3VwYWJhc2UnO1xuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vbGliL2xvZ2dlcic7XG5cbi8vIEluaXRpYWxpemUgbG9nZ2VyXG5jb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoJ2dlbmVyYXRlLWl0aW5lcmFyeScpO1xuXG4vLyBDb25maWd1cmUgcnVudGltZSBmb3Igc2VydmVybGVzcyBmdW5jdGlvbiAtIHVzaW5nIGVkZ2UgZm9yIG1vcmUgY29uc2lzdGVudCB0aW1lb3V0IGJlaGF2aW9yXG5leHBvcnQgY29uc3QgcnVudGltZSA9ICdub2RlanMnO1xuZXhwb3J0IGNvbnN0IG1heER1cmF0aW9uID0gNjA7IC8vIFNldCBtYXggZHVyYXRpb24gdG8gNjAgc2Vjb25kc1xuXG4vLyBDaGVjayBpZiBydW5uaW5nIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5cbi8vIENoZWNrIGlmIFN1cGFiYXNlIGlzIHByb3Blcmx5IGNvbmZpZ3VyZWRcbmNvbnN0IGlzU3VwYWJhc2VDb25maWd1cmVkID0gQm9vbGVhbihcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMICYmIFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxuKTtcblxuLy8gU3VydmV5IGRhdGEgdHlwZVxudHlwZSBTdXJ2ZXlEYXRhID0ge1xuICBkZXN0aW5hdGlvbjogc3RyaW5nO1xuICBzdGFydERhdGU6IHN0cmluZztcbiAgZW5kRGF0ZTogc3RyaW5nO1xuICBwdXJwb3NlOiBzdHJpbmc7XG4gIGJ1ZGdldDogc3RyaW5nO1xuICBwcmVmZXJlbmNlczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgLy8gTG9nIGtleSBpbmZvcm1hdGlvbiBmb3IgZGVidWdnaW5nXG4gICAgbG9nZ2VyLmluZm8oYD09PT09PT09PT0gSVRJTkVSQVJZIEdFTkVSQVRJT04gUkVRVUVTVCA9PT09PT09PT09YCk7XG4gICAgbG9nZ2VyLmluZm8oYEFQSSBSZXF1ZXN0IHN0YXJ0ZWQ6ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWApO1xuICAgIGxvZ2dlci5pbmZvKCdFbnZpcm9ubWVudDonLCB7XG4gICAgICBub2RlRW52OiBwcm9jZXNzLmVudi5OT0RFX0VOVixcbiAgICAgIGlzUHJvZHVjdGlvbjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJ1xuICAgIH0pO1xuICAgIFxuICAgIC8vIExvZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgKHdpdGhvdXQgZXhwb3NpbmcgYWN0dWFsIHZhbHVlcylcbiAgICBsb2dnZXIuaW5mbygnU3VwYWJhc2UgY29ubmVjdGlvbiBkZXRhaWxzOicsIHtcbiAgICAgIGhhc1N1cGFiYXNlVXJsOiAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcbiAgICAgIGhhc1N1cGFiYXNlS2V5OiAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZLFxuICAgICAgdXJsUHJlZml4OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw/LnN1YnN0cmluZygwLCAxMCkgfHwgJ21pc3NpbmcnLFxuICAgICAga2V5UHJlZml4OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWT8uc3Vic3RyaW5nKDAsIDUpIHx8ICdtaXNzaW5nJyxcbiAgICAgIHVybExlbmd0aDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMPy5sZW5ndGggfHwgMCxcbiAgICAgIGtleUxlbmd0aDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVk/Lmxlbmd0aCB8fCAwXG4gICAgfSk7XG5cbiAgICAvLyBPbmx5IHRlc3QgU3VwYWJhc2UgY29ubmVjdGlvbiBpZiBwcm9wZXJseSBjb25maWd1cmVkXG4gICAgaWYgKGlzU3VwYWJhc2VDb25maWd1cmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIuaW5mbygnVGVzdGluZyBTdXBhYmFzZSBjb25uZWN0aW9uLi4uJyk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2pvYnMnKS5zZWxlY3QoJyonKS5saW1pdCgxKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCfinYwgU3VwYWJhc2UgY29ubmVjdGlvbiB0ZXN0IGZhaWxlZDonLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgaGludDogZXJyb3IuaGludCB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUgfHwgJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbygn4pyFIFN1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCBzdWNjZXNzZnVsJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGNvbm5FcnJvcjogYW55KSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcign4p2MIFN1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCBleGNlcHRpb246Jywge1xuICAgICAgICAgIG1lc3NhZ2U6IGNvbm5FcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGRldGFpbHM6IGNvbm5FcnJvci50b1N0cmluZygpLFxuICAgICAgICAgIG5hbWU6IGNvbm5FcnJvci5uYW1lLFxuICAgICAgICAgIHN0YWNrOiBjb25uRXJyb3Iuc3RhY2s/LnN1YnN0cmluZygwLCAyMDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2Fybign4pqg77iPIFNraXBwaW5nIFN1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCAtIG5vdCBjb25maWd1cmVkJyk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIHJlcXVlc3QgYm9keVxuICAgIGNvbnN0IHN1cnZleURhdGE6IFN1cnZleURhdGEgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICBsb2dnZXIuaW5mbygnUmVjZWl2ZWQgc3VydmV5IGRhdGE6Jywge1xuICAgICAgZGVzdGluYXRpb246IHN1cnZleURhdGEuZGVzdGluYXRpb24sXG4gICAgICBzdGFydERhdGU6IHN1cnZleURhdGEuc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZTogc3VydmV5RGF0YS5lbmREYXRlLFxuICAgICAgcHVycG9zZTogc3VydmV5RGF0YS5wdXJwb3NlLFxuICAgICAgYnVkZ2V0OiBzdXJ2ZXlEYXRhLmJ1ZGdldCxcbiAgICAgIHByZWZlcmVuY2VzOiBzdXJ2ZXlEYXRhLnByZWZlcmVuY2VzIFxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGpvYiBJRFxuICAgIGNvbnN0IGpvYklkID0gZ2VuZXJhdGVKb2JJZCgpO1xuICAgIGxvZ2dlci5pbmZvKGBHZW5lcmF0ZWQgbmV3IGpvYiBJRDogJHtqb2JJZH1gKTtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBwcm9tcHQgb24gdGhlIHNlcnZlciBzaWRlXG4gICAgY29uc3QgcHJvbXB0ID0gZ2VuZXJhdGVQcm9tcHQoc3VydmV5RGF0YSk7XG4gICAgbG9nZ2VyLmluZm8oYEdlbmVyYXRlZCBwcm9tcHQgZm9yIGpvYiAke2pvYklkfSwgbGVuZ3RoOiAke3Byb21wdC5sZW5ndGh9IGNoYXJhY3RlcnNgKTtcblxuICAgIC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50IG9yIHRlc3RpbmcsIHJldHVybiBtb2NrIGRhdGEgaW1tZWRpYXRlbHlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgcHJvY2Vzcy5lbnYuVVNFX01PQ0tfREFUQSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2dnZXIuaW5mbygnRGV2ZWxvcG1lbnQgbW9kZSB3aXRoIG1vY2sgZGF0YTogUmV0dXJuaW5nIG1vY2sgZGF0YScpO1xuICAgICAgY29uc3QgbW9ja0l0aW5lcmFyeSA9IGNyZWF0ZU1vY2tJdGluZXJhcnkoc3VydmV5RGF0YSk7XG4gICAgICBjb25zdCB1cGRhdGVSZXN1bHQgPSBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdjb21wbGV0ZWQnLCB7IFxuICAgICAgICByZXN1bHQ6IHsgXG4gICAgICAgICAgaXRpbmVyYXJ5OiBtb2NrSXRpbmVyYXJ5LCBcbiAgICAgICAgICBwcm9tcHQ6IHByb21wdCBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghdXBkYXRlUmVzdWx0KSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBqb2Igc3RhdHVzIGluIGRldmVsb3BtZW50IG1vZGUnKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gdXBkYXRlIGpvYiBzdGF0dXMnIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGpvYklkLCBzdGF0dXM6ICdjb21wbGV0ZWQnIH0pO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBqb2IgaW4gU3VwYWJhc2VcbiAgICBsb2dnZXIuaW5mbygnQ3JlYXRpbmcgbmV3IGpvYiB3aXRoIElEOicsIGpvYklkKTtcbiAgICBsZXQgam9iQ3JlYXRlZCA9IGZhbHNlO1xuICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcbiAgICBcbiAgICAvLyBBZGQgcmV0cnkgbG9naWMgZm9yIGpvYiBjcmVhdGlvblxuICAgIHdoaWxlICgham9iQ3JlYXRlZCAmJiByZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgam9iQ3JlYXRlZCA9IGF3YWl0IGNyZWF0ZUpvYihqb2JJZCk7XG4gICAgICAgIGlmICgham9iQ3JlYXRlZCkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBqb2Igb24gYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfS8ke21heFJldHJpZXN9YCk7XG4gICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgIGlmIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgICAgICAgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEVycm9yIGNyZWF0aW5nIGpvYiBvbiBhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9LyR7bWF4UmV0cmllc306YCwgZXJyb3IpO1xuICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIGlmIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoIWpvYkNyZWF0ZWQpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBqb2IgYWZ0ZXIgbXVsdGlwbGUgYXR0ZW1wdHMnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgam9iIGluIGRhdGFiYXNlIGFmdGVyIG11bHRpcGxlIGF0dGVtcHRzJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gY3JlYXRlZCBzdWNjZXNzZnVsbHksIGN1cnJlbnQgc3RhdHVzOiBxdWV1ZWRgKTtcblxuICAgIC8vIFZlcmlmeSB0aGUgam9iIHdhcyBjcmVhdGVkIHByb3Blcmx5IGJ5IGZldGNoaW5nIGl0cyBzdGF0dXNcbiAgICBsZXQgc3RhdHVzQ2hlY2s7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXR1c0NoZWNrID0gYXdhaXQgZ2V0Sm9iU3RhdHVzKGpvYklkKTtcbiAgICAgIGxvZ2dlci5pbmZvKGBJbml0aWFsIGpvYiBzdGF0dXMgY2hlY2s6ICR7c3RhdHVzQ2hlY2suc3RhdHVzfWApO1xuICAgICAgXG4gICAgICBpZiAoc3RhdHVzQ2hlY2suc3RhdHVzID09PSAnbm90X2ZvdW5kJykge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYENyaXRpY2FsIGVycm9yOiBKb2IgJHtqb2JJZH0gd2FzIG5vdCBmb3VuZCBpbW1lZGlhdGVseSBhZnRlciBjcmVhdGlvbmApO1xuICAgICAgICAvLyBUcnkgdG8gcmVjcmVhdGUgdGhlIGpvYiBvbmUgbW9yZSB0aW1lIGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb25cbiAgICAgICAgam9iQ3JlYXRlZCA9IGF3YWl0IGNyZWF0ZUpvYihqb2JJZCk7XG4gICAgICAgIGlmIChqb2JDcmVhdGVkKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYEpvYiAke2pvYklkfSByZWNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IGFmdGVyIGluaXRpYWwgbm90X2ZvdW5kIHN0YXR1c2ApO1xuICAgICAgICAgIHN0YXR1c0NoZWNrID0gYXdhaXQgZ2V0Sm9iU3RhdHVzKGpvYklkKTtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgU2Vjb25kIGpvYiBzdGF0dXMgY2hlY2s6ICR7c3RhdHVzQ2hlY2suc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoc3RhdHVzQ2hlY2tFcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBjaGVja2luZyBpbml0aWFsIGpvYiBzdGF0dXM6Jywgc3RhdHVzQ2hlY2tFcnJvcik7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCB0aGUgU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiB0byBwcm9jZXNzIHRoZSBpdGluZXJhcnlcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmluZm8oYEludm9raW5nIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgam9iIHN0YXR1cyB0byBwcm9jZXNzaW5nXG4gICAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdwcm9jZXNzaW5nJyk7XG4gICAgICBcbiAgICAgIGlmICghaXNTdXBhYmFzZUNvbmZpZ3VyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBhYmFzZSBVUkwgb3Iga2V5IGlzIG1pc3NpbmcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW52b2tlIHRoZSBFZGdlIEZ1bmN0aW9uIHdpdGggdGhlIGdlbmVyYXRlZCBwcm9tcHRcbiAgICAgIGNvbnN0IHsgZGF0YTogZnVuY3Rpb25EYXRhLCBlcnJvcjogZnVuY3Rpb25FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnVuY3Rpb25zLmludm9rZShcbiAgICAgICAgJ2dlbmVyYXRlLWl0aW5lcmFyeScsXG4gICAgICAgIHtcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgIHN1cnZleURhdGEsXG4gICAgICAgICAgICBwcm9tcHQgLy8gU2VuZCB0aGUgcHJvbXB0IHRvIHRoZSBlZGdlIGZ1bmN0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBpZiAoZnVuY3Rpb25FcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEVycm9yIGludm9raW5nIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb246YCwgZnVuY3Rpb25FcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRWRnZSBGdW5jdGlvbiBlcnJvcjogJHtmdW5jdGlvbkVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIuaW5mbyhgU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBpbnZva2VkIHN1Y2Nlc3NmdWxseSBmb3Igam9iICR7am9iSWR9OmAsIGZ1bmN0aW9uRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZSBlZGdlIGZ1bmN0aW9uIHJldHVybmVkIGEgcmVzdWx0IGRpcmVjdGx5LCBwcm9jZXNzIGl0XG4gICAgICBpZiAoZnVuY3Rpb25EYXRhICYmIGZ1bmN0aW9uRGF0YS5yZXN1bHQpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYFByb2Nlc3NpbmcgaW1tZWRpYXRlIHJlc3VsdCBmcm9tIGVkZ2UgZnVuY3Rpb24gZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgICBhd2FpdCBwcm9jZXNzSXRpbmVyYXJ5UmVzcG9uc2Uoam9iSWQsIGZ1bmN0aW9uRGF0YS5yZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVkZ2VGdW5jdGlvbkVycm9yOiBhbnkpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGludm9rZSBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uOmAsIGVkZ2VGdW5jdGlvbkVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGpvYiBzdGF0dXMgdG8gcmVmbGVjdCB0aGUgZXJyb3IgYnV0IGRvbid0IGZhaWwgdGhlIHJlc3BvbnNlXG4gICAgICAvLyBXZSB3YW50IHRoZSBjbGllbnQgdG8ga2VlcCBwb2xsaW5nIHRoZSBqb2Igc3RhdHVzXG4gICAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdwcm9jZXNzaW5nJywge1xuICAgICAgICBlcnJvcjogYEVkZ2UgZnVuY3Rpb24gaW52b2NhdGlvbiBlcnJvciAod2lsbCByZXRyeSk6ICR7ZWRnZUZ1bmN0aW9uRXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IHdpdGggdGhlIGpvYiBJRFxuICAgIGxvZ2dlci5pbmZvKGBSZXR1cm5pbmcgcmVzcG9uc2UgZm9yIGpvYiAke2pvYklkfSB3aXRoIHN0YXR1czogcHJvY2Vzc2luZ2ApO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgam9iSWQsIFxuICAgICAgc3RhdHVzOiAncHJvY2Vzc2luZycsXG4gICAgICBtZXNzYWdlOiAnWW91ciBpdGluZXJhcnkgaXMgYmVpbmcgZ2VuZXJhdGVkLiBQb2xsIHRoZSBqb2Itc3RhdHVzIGVuZHBvaW50IGZvciB1cGRhdGVzLidcbiAgICB9KTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaW5pdGlhdGluZyBpdGluZXJhcnkgZ2VuZXJhdGlvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogYEZhaWxlZCB0byBpbml0aWF0ZSBpdGluZXJhcnkgZ2VuZXJhdGlvbjogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgcHJvbXB0IGJhc2VkIG9uIHN1cnZleSBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQcm9tcHQoc3VydmV5RGF0YTogU3VydmV5RGF0YSk6IHN0cmluZyB7XG4gIC8vIENhbGN1bGF0ZSB0cmlwIGR1cmF0aW9uIC0gYWRkaW5nIDEgdG8gaW5jbHVkZSBib3RoIHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShzdXJ2ZXlEYXRhLnN0YXJ0RGF0ZSk7XG4gIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZShzdXJ2ZXlEYXRhLmVuZERhdGUpO1xuICBcbiAgLy8gU2V0IHRpbWUgdG8gbm9vbiB0byBhdm9pZCB0aW1lem9uZSBpc3N1ZXNcbiAgc3RhcnREYXRlLnNldEhvdXJzKDEyLCAwLCAwLCAwKTtcbiAgZW5kRGF0ZS5zZXRIb3VycygxMiwgMCwgMCwgMCk7XG4gIFxuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRheXNcbiAgY29uc3QgdHJpcER1cmF0aW9uID0gTWF0aC5jZWlsKChlbmREYXRlLmdldFRpbWUoKSAtIHN0YXJ0RGF0ZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSArIDE7XG4gIFxuICAvLyBGb3JtYXQgZGF0ZXMgZm9yIGRpc3BsYXlcbiAgY29uc3QgZm9ybWF0dGVkU3RhcnREYXRlID0gZm9ybWF0RGF0ZShzdGFydERhdGUpO1xuICBjb25zdCBmb3JtYXR0ZWRFbmREYXRlID0gZm9ybWF0RGF0ZShlbmREYXRlKTtcbiAgXG4gIC8vIEJ1aWxkIHRoZSBwcmVmZXJlbmNlcyBzZWN0aW9uXG4gIGxldCBwcmVmZXJlbmNlc1RleHQgPSAnJztcbiAgaWYgKHN1cnZleURhdGEucHJlZmVyZW5jZXMgJiYgc3VydmV5RGF0YS5wcmVmZXJlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgcHJlZmVyZW5jZXNUZXh0ID0gJ1RoZSB0cmF2ZWxlciBoYXMgZXhwcmVzc2VkIGludGVyZXN0IGluIHRoZSBmb2xsb3dpbmc6ICcgKyBcbiAgICAgIHN1cnZleURhdGEucHJlZmVyZW5jZXMuam9pbignLCAnKSArICcuICc7XG4gIH1cblxuICAvLyBDb25zdHJ1Y3QgdGhlIHByb21wdFxuICByZXR1cm4gYFxuQ3JlYXRlIGEgcGVyc29uYWxpemVkIHRyYXZlbCBpdGluZXJhcnkgZm9yIGEgdHJpcCB0byAke3N1cnZleURhdGEuZGVzdGluYXRpb259IGZyb20gJHtmb3JtYXR0ZWRTdGFydERhdGV9IHRvICR7Zm9ybWF0dGVkRW5kRGF0ZX0gKCR7dHJpcER1cmF0aW9ufSBkYXlzKS5cblxuVHJpcCBwdXJwb3NlOiAke3N1cnZleURhdGEucHVycG9zZX1cbkJ1ZGdldCBsZXZlbDogJHtzdXJ2ZXlEYXRhLmJ1ZGdldH1cbiR7cHJlZmVyZW5jZXNUZXh0fVxuXG5HZW5lcmF0ZSBhIGNvbXByZWhlbnNpdmUgZGF5LWJ5LWRheSB0cmF2ZWwgaXRpbmVyYXJ5IHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUgKGFzIGEgdmFsaWQgSlNPTiBvYmplY3QpOlxuXG57XG4gIFwiZGVzdGluYXRpb25cIjogXCIke3N1cnZleURhdGEuZGVzdGluYXRpb259XCIsXG4gIFwidHJpcE5hbWVcIjogXCI8Y3JlYXRlIGEgY2F0Y2h5IG5hbWUgZm9yIHRoaXMgdHJpcD5cIixcbiAgXCJkYXRlc1wiOiB7XG4gICAgXCJzdGFydFwiOiBcIiR7c3VydmV5RGF0YS5zdGFydERhdGV9XCIsXG4gICAgXCJlbmRcIjogXCIke3N1cnZleURhdGEuZW5kRGF0ZX1cIlxuICB9LFxuICBcInN1bW1hcnlcIjogXCI8YnJpZWYgb3ZlcnZpZXcgb2YgdGhlIHRyaXAgaGlnaGxpZ2h0aW5nIGtleSBhdHRyYWN0aW9ucyBhbmQgZXhwZXJpZW5jZXM+XCIsXG4gIFwiZGF5c1wiOiBbXG4gICAge1xuICAgICAgXCJkYXlcIjogMSxcbiAgICAgIFwiZGF0ZVwiOiBcIiR7c3VydmV5RGF0YS5zdGFydERhdGV9XCIsXG4gICAgICBcImFjdGl2aXRpZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJ0aW1lXCI6IFwiPG1vcm5pbmcvYWZ0ZXJub29uL2V2ZW5pbmc+XCIsXG4gICAgICAgICAgXCJ0aXRsZVwiOiBcIjxhY3Rpdml0eSBuYW1lPlwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCI8ZGV0YWlsZWQgZGVzY3JpcHRpb24+XCIsXG4gICAgICAgICAgXCJsb2NhdGlvblwiOiBcIjxzcGVjaWZpYyBsb2NhdGlvbiBuYW1lPlwiLFxuICAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjoge1xuICAgICAgICAgICAgXCJsYXRcIjogPGxhdGl0dWRlIGFzIG51bWJlcj4sXG4gICAgICAgICAgICBcImxuZ1wiOiA8bG9uZ2l0dWRlIGFzIG51bWJlcj5cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZHVyYXRpb25cIjogXCI8ZXN0aW1hdGVkIGR1cmF0aW9uPlwiLFxuICAgICAgICAgIFwiY29zdFwiOiBcIjxjb3N0IGVzdGltYXRlIG9yIGJ1ZGdldCBsZXZlbD5cIlxuICAgICAgICB9LFxuICAgICAgICAuLi4gbW9yZSBhY3Rpdml0aWVzIC4uLlxuICAgICAgXVxuICAgIH0sXG4gICAgLi4uIG1vcmUgZGF5cyAuLi5cbiAgXSxcbiAgXCJidWRnZXRFc3RpbWF0ZVwiOiB7XG4gICAgXCJhY2NvbW1vZGF0aW9uXCI6IDxlc3RpbWF0ZWQgdG90YWwgY29zdCBhcyBudW1iZXI+LFxuICAgIFwiZm9vZFwiOiA8ZXN0aW1hdGVkIHRvdGFsIGNvc3QgYXMgbnVtYmVyPixcbiAgICBcImFjdGl2aXRpZXNcIjogPGVzdGltYXRlZCB0b3RhbCBjb3N0IGFzIG51bWJlcj4sXG4gICAgXCJ0cmFuc3BvcnRhdGlvblwiOiA8ZXN0aW1hdGVkIHRvdGFsIGNvc3QgYXMgbnVtYmVyPixcbiAgICBcInRvdGFsXCI6IDx0b3RhbCBlc3RpbWF0ZWQgY29zdCBhcyBudW1iZXI+XG4gIH0sXG4gIFwidHJhdmVsVGlwc1wiOiBbXG4gICAgXCI8dXNlZnVsIHRpcCBmb3IgdGhpcyBkZXN0aW5hdGlvbj5cIixcbiAgICAuLi4gbW9yZSB0aXBzIC4uLlxuICBdXG59XG5cblJlbWVtYmVyLCBFQUNIIGFjdGl2aXR5IE1VU1QgaW5jbHVkZSB2YWxpZCBhbmQgYWNjdXJhdGUgY29vcmRpbmF0ZXMgKGxhdGl0dWRlIGFuZCBsb25naXR1ZGUpIGFzIG51bWVyaWNhbCB2YWx1ZXMgLSBuZXZlciB1c2UgZW1wdHkgb3IgcGxhY2Vob2xkZXIgY29vcmRpbmF0ZXMuIFJlc2VhcmNoIHJlYWwgbG9jYXRpb25zIGluICR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn0gYW5kIGluY2x1ZGUgdGhlaXIgYWN0dWFsIGNvb3JkaW5hdGVzLlxuXG5Pbmx5IHJldHVybiB2YWxpZCBKU09OIHRoYXQgY2FuIGJlIHBhcnNlZCB3aXRoIEpTT04ucGFyc2UoKS4gRG8gbm90IGluY2x1ZGUgYW55IGV4cGxhbmF0aW9ucywgbWFya2Rvd24gZm9ybWF0dGluZywgb3IgY29kZSBibG9ja3Mgb3V0c2lkZSB0aGUgSlNPTiBvYmplY3QuIEVuc3VyZSBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHN0cmluZyB2YWx1ZXMgdXNlIGRvdWJsZSBxdW90ZXMsIG5vdCBzaW5nbGUgcXVvdGVzLlxuICBgO1xufVxuXG4vLyBGb3JtYXQgZGF0ZSBmb3IgZGlzcGxheVxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgY29uc3QgbW9udGhzID0gW1xuICAgICdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJyxcbiAgICAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXG4gIF07XG4gIFxuICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgY29uc3QgbW9udGggPSBtb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgXG4gIC8vIEFkZCBzdWZmaXggdG8gZGF5XG4gIGxldCBzdWZmaXggPSAndGgnO1xuICBpZiAoZGF5ID09PSAxIHx8IGRheSA9PT0gMjEgfHwgZGF5ID09PSAzMSkgc3VmZml4ID0gJ3N0JztcbiAgZWxzZSBpZiAoZGF5ID09PSAyIHx8IGRheSA9PT0gMjIpIHN1ZmZpeCA9ICduZCc7XG4gIGVsc2UgaWYgKGRheSA9PT0gMyB8fCBkYXkgPT09IDIzKSBzdWZmaXggPSAncmQnO1xuICBcbiAgcmV0dXJuIGAke21vbnRofSAke2RheX0ke3N1ZmZpeH0sICR7eWVhcn1gO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnQgdGVzdGluZ1xuZnVuY3Rpb24gY3JlYXRlTW9ja0l0aW5lcmFyeShzdXJ2ZXlEYXRhOiBTdXJ2ZXlEYXRhKTogYW55IHtcbiAgcmV0dXJuIHtcbiAgICBkZXN0aW5hdGlvbjogc3VydmV5RGF0YS5kZXN0aW5hdGlvbixcbiAgICB0cmlwTmFtZTogYCR7c3VydmV5RGF0YS5wdXJwb3NlfSB0cmlwIHRvICR7c3VydmV5RGF0YS5kZXN0aW5hdGlvbn1gLFxuICAgIGRhdGVzOiB7XG4gICAgICBzdGFydDogc3VydmV5RGF0YS5zdGFydERhdGUsXG4gICAgICBlbmQ6IHN1cnZleURhdGEuZW5kRGF0ZVxuICAgIH0sXG4gICAgc3VtbWFyeTogYEEgJHtzdXJ2ZXlEYXRhLmJ1ZGdldH0gJHtzdXJ2ZXlEYXRhLnB1cnBvc2V9IGFkdmVudHVyZSBpbiAke3N1cnZleURhdGEuZGVzdGluYXRpb259LCBmZWF0dXJpbmcgJHtzdXJ2ZXlEYXRhLnByZWZlcmVuY2VzLmpvaW4oJywgJyl9LmAsXG4gICAgZGF5czogW1xuICAgICAge1xuICAgICAgICBkYXk6IDEsXG4gICAgICAgIGRhdGU6IHN1cnZleURhdGEuc3RhcnREYXRlLFxuICAgICAgICBhY3Rpdml0aWVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGltZTogXCJtb3JuaW5nXCIsXG4gICAgICAgICAgICB0aXRsZTogXCJCcmVha2Zhc3QgYXQgbG9jYWwgY2FmZVwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU3RhcnQgeW91ciBkYXkgd2l0aCBhIGRlbGljaW91cyBsb2NhbCBicmVha2Zhc3RcIixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBcIkNlbnRyYWwgQ2FmZVwiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgICAgICAgbGF0OiA0OC44NTY2LFxuICAgICAgICAgICAgICBsbmc6IDIuMzUyMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBcIjEgaG91clwiLFxuICAgICAgICAgICAgY29zdDogXCJtb2RlcmF0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aW1lOiBcImFmdGVybm9vblwiLFxuICAgICAgICAgICAgdGl0bGU6IFwiQ2l0eSBUb3VyXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJFeHBsb3JlIHRoZSBtYWluIGF0dHJhY3Rpb25zIG9mIHRoZSBjaXR5XCIsXG4gICAgICAgICAgICBsb2NhdGlvbjogXCJDaXR5IENlbnRlclwiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgICAgICAgbGF0OiA0OC44NTg0LFxuICAgICAgICAgICAgICBsbmc6IDIuMzUzNlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBcIjMgaG91cnNcIixcbiAgICAgICAgICAgIGNvc3Q6IHN1cnZleURhdGEuYnVkZ2V0XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkYXk6IDIsXG4gICAgICAgIGRhdGU6IG5ldyBEYXRlKG5ldyBEYXRlKHN1cnZleURhdGEuc3RhcnREYXRlKS5zZXREYXRlKG5ldyBEYXRlKHN1cnZleURhdGEuc3RhcnREYXRlKS5nZXREYXRlKCkgKyAxKSkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICBhY3Rpdml0aWVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGltZTogXCJtb3JuaW5nXCIsXG4gICAgICAgICAgICB0aXRsZTogXCJNdXNldW0gVmlzaXRcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlZpc2l0IHRoZSBmYW1vdXMgbG9jYWwgbXVzZXVtXCIsXG4gICAgICAgICAgICBsb2NhdGlvbjogXCJOYXRpb25hbCBNdXNldW1cIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgICAgIGxhdDogNDguODYwNixcbiAgICAgICAgICAgICAgbG5nOiAyLjMzNzZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogXCIyIGhvdXJzXCIsXG4gICAgICAgICAgICBjb3N0OiBzdXJ2ZXlEYXRhLmJ1ZGdldFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgYnVkZ2V0RXN0aW1hdGU6IHtcbiAgICAgIGFjY29tbW9kYXRpb246IDUwMCxcbiAgICAgIGZvb2Q6IDMwMCxcbiAgICAgIGFjdGl2aXRpZXM6IDIwMCxcbiAgICAgIHRyYW5zcG9ydGF0aW9uOiAxMDAsXG4gICAgICB0b3RhbDogMTEwMFxuICAgIH0sXG4gICAgdHJhdmVsVGlwczogW1xuICAgICAgXCJQYWNrIGNvbWZvcnRhYmxlIHdhbGtpbmcgc2hvZXNcIixcbiAgICAgIFwiVHJ5IHRoZSBsb2NhbCBzcGVjaWFsdHkgZGlzaGVzXCIsXG4gICAgICBcIkxlYXJuIGEgZmV3IHBocmFzZXMgaW4gdGhlIGxvY2FsIGxhbmd1YWdlXCJcbiAgICBdXG4gIH07XG59ICJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJnZW5lcmF0ZUpvYklkIiwicHJvY2Vzc0l0aW5lcmFyeVJlc3BvbnNlIiwiY3JlYXRlSm9iIiwidXBkYXRlSm9iU3RhdHVzIiwiZ2V0Sm9iU3RhdHVzIiwic3VwYWJhc2UiLCJjcmVhdGVMb2dnZXIiLCJsb2dnZXIiLCJydW50aW1lIiwibWF4RHVyYXRpb24iLCJpc1Byb2R1Y3Rpb24iLCJwcm9jZXNzIiwiaXNTdXBhYmFzZUNvbmZpZ3VyZWQiLCJCb29sZWFuIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJQT1NUIiwicmVxdWVzdCIsImluZm8iLCJEYXRlIiwidG9JU09TdHJpbmciLCJub2RlRW52IiwiaGFzU3VwYWJhc2VVcmwiLCJoYXNTdXBhYmFzZUtleSIsInVybFByZWZpeCIsInN1YnN0cmluZyIsImtleVByZWZpeCIsInVybExlbmd0aCIsImxlbmd0aCIsImtleUxlbmd0aCIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJsaW1pdCIsIm1lc3NhZ2UiLCJoaW50IiwiY29kZSIsImNvbm5FcnJvciIsImRldGFpbHMiLCJ0b1N0cmluZyIsIm5hbWUiLCJzdGFjayIsIndhcm4iLCJzdXJ2ZXlEYXRhIiwianNvbiIsImRlc3RpbmF0aW9uIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInB1cnBvc2UiLCJidWRnZXQiLCJwcmVmZXJlbmNlcyIsImpvYklkIiwicHJvbXB0IiwiZ2VuZXJhdGVQcm9tcHQiLCJVU0VfTU9DS19EQVRBIiwibW9ja0l0aW5lcmFyeSIsImNyZWF0ZU1vY2tJdGluZXJhcnkiLCJ1cGRhdGVSZXN1bHQiLCJyZXN1bHQiLCJpdGluZXJhcnkiLCJzdGF0dXMiLCJqb2JDcmVhdGVkIiwicmV0cnlDb3VudCIsIm1heFJldHJpZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJNYXRoIiwicG93Iiwic3RhdHVzQ2hlY2siLCJzdGF0dXNDaGVja0Vycm9yIiwiRXJyb3IiLCJmdW5jdGlvbkRhdGEiLCJmdW5jdGlvbkVycm9yIiwiZnVuY3Rpb25zIiwiaW52b2tlIiwiYm9keSIsImVkZ2VGdW5jdGlvbkVycm9yIiwic2V0SG91cnMiLCJ0cmlwRHVyYXRpb24iLCJjZWlsIiwiZ2V0VGltZSIsImZvcm1hdHRlZFN0YXJ0RGF0ZSIsImZvcm1hdERhdGUiLCJmb3JtYXR0ZWRFbmREYXRlIiwicHJlZmVyZW5jZXNUZXh0Iiwiam9pbiIsImRhdGUiLCJtb250aHMiLCJkYXkiLCJnZXREYXRlIiwibW9udGgiLCJnZXRNb250aCIsInllYXIiLCJnZXRGdWxsWWVhciIsInN1ZmZpeCIsInRyaXBOYW1lIiwiZGF0ZXMiLCJzdGFydCIsImVuZCIsInN1bW1hcnkiLCJkYXlzIiwiYWN0aXZpdGllcyIsInRpbWUiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwibG9jYXRpb24iLCJjb29yZGluYXRlcyIsImxhdCIsImxuZyIsImR1cmF0aW9uIiwiY29zdCIsInNldERhdGUiLCJzcGxpdCIsImJ1ZGdldEVzdGltYXRlIiwiYWNjb21tb2RhdGlvbiIsImZvb2QiLCJ0cmFuc3BvcnRhdGlvbiIsInRvdGFsIiwidHJhdmVsVGlwcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/generate-itinerary/route.ts\n");

/***/ }),

/***/ "(rsc)/./app/api/job-processor.ts":
/*!**********************************!*\
  !*** ./app/api/job-processor.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureValidCoordinates: () => (/* binding */ ensureValidCoordinates),\n/* harmony export */   generateJobId: () => (/* binding */ generateJobId),\n/* harmony export */   processItineraryJob: () => (/* binding */ processItineraryJob),\n/* harmony export */   processItineraryResponse: () => (/* binding */ processItineraryResponse),\n/* harmony export */   sanitizeJSON: () => (/* binding */ sanitizeJSON)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/supabase */ \"(rsc)/./lib/supabase.ts\");\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/logger */ \"(rsc)/./lib/logger.ts\");\n\n\n// Create a logger for the job processor\nconst logger = (0,_lib_logger__WEBPACK_IMPORTED_MODULE_1__.createLogger)(\"job-processor\");\n// Helper function to generate a unique job ID\nfunction generateJobId() {\n    return `job_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n// Function to sanitize JSON - fixes common JSON syntax issues\nfunction sanitizeJSON(content) {\n    logger.debug(\"Sanitizing JSON content\");\n    // Remove JavaScript-style comments\n    let sanitized = content.replace(/\\/\\/.*?(\\r?\\n|$)/g, \"$1\").replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n    // Fix property names without quotes\n    sanitized = sanitized.replace(/(\\{|\\,)\\s*([a-zA-Z0-9_]+)\\s*\\:/g, '$1\"$2\":');\n    // Remove trailing commas\n    sanitized = sanitized.replace(/,(\\s*[\\]\\}])/g, \"$1\");\n    // Replace single quotes with double quotes\n    sanitized = sanitized.replace(/'/g, '\"');\n    return sanitized;\n}\n// Ensure valid coordinates in the itinerary\nfunction ensureValidCoordinates(itinerary) {\n    logger.debug(\"Validating and fixing coordinates in itinerary\");\n    // Default backup coordinates for Paris (use as last resort)\n    const defaultCoordinates = {\n        lat: 48.8566,\n        lng: 2.3522\n    };\n    // Helper to validate a single coordinates object\n    const isValidCoordinates = (coords)=>{\n        return coords && typeof coords === \"object\" && typeof coords.lat === \"number\" && typeof coords.lng === \"number\" && !isNaN(coords.lat) && !isNaN(coords.lng);\n    };\n    // If there are no days, nothing to do\n    if (!itinerary.days || !Array.isArray(itinerary.days)) {\n        logger.warn(\"No days array found in itinerary\");\n        return itinerary;\n    }\n    // Track issues found\n    let issuesFound = 0;\n    // Check each day and activity\n    itinerary.days.forEach((day, dayIndex)=>{\n        if (!day.activities || !Array.isArray(day.activities)) {\n            logger.warn(`Day ${dayIndex + 1} has no activities array`);\n            return;\n        }\n        day.activities.forEach((activity, activityIndex)=>{\n            // Skip if there's no activity object\n            if (!activity || typeof activity !== \"object\") {\n                logger.warn(`Invalid activity at day ${dayIndex + 1}, index ${activityIndex}`);\n                return;\n            }\n            // Check if coordinates exist and are valid\n            if (!isValidCoordinates(activity.coordinates)) {\n                issuesFound++;\n                logger.warn(`Invalid coordinates found for activity \"${activity.title}\" on day ${dayIndex + 1}`, {\n                    coordinates: activity.coordinates,\n                    activityIndex,\n                    dayIndex\n                });\n                // If the coordinates exist but are invalid, try to fix them\n                if (activity.coordinates && typeof activity.coordinates === \"object\") {\n                    // Try to convert string values to numbers\n                    if (typeof activity.coordinates.lat === \"string\") {\n                        activity.coordinates.lat = parseFloat(activity.coordinates.lat);\n                    }\n                    if (typeof activity.coordinates.lng === \"string\") {\n                        activity.coordinates.lng = parseFloat(activity.coordinates.lng);\n                    }\n                    // If still invalid, use default\n                    if (!isValidCoordinates(activity.coordinates)) {\n                        activity.coordinates = {\n                            ...defaultCoordinates\n                        };\n                    }\n                } else {\n                    // No coordinates or completely invalid, use default\n                    activity.coordinates = {\n                        ...defaultCoordinates\n                    };\n                }\n                logger.debug(`Fixed coordinates for activity \"${activity.title}\"`, activity.coordinates);\n            }\n        });\n    });\n    if (issuesFound > 0) {\n        logger.info(`Fixed ${issuesFound} coordinate issues in itinerary`);\n    } else {\n        logger.debug(\"All coordinates in itinerary are valid\");\n    }\n    return itinerary;\n}\n// Parse and process the OpenAI response from Edge Function\nasync function processItineraryResponse(jobId, contentData) {\n    try {\n        logger.info(`Processing itinerary response for job ${jobId}`);\n        if (!contentData || !contentData.rawContent) {\n            logger.error(`Invalid response data for job ${jobId}`);\n            await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                error: \"Invalid response data from Supabase edge function\"\n            });\n            return false;\n        }\n        const itineraryContent = contentData.rawContent;\n        logger.debug(`Content length for job ${jobId}: ${itineraryContent.length} characters`);\n        // Parse the JSON response with error handling\n        try {\n            logger.debug(`Parsing JSON response for job ${jobId}`);\n            // Try direct parse first\n            let itinerary;\n            try {\n                itinerary = JSON.parse(itineraryContent);\n                logger.info(`JSON for job ${jobId} parsed successfully on first attempt`);\n            } catch (err) {\n                const parseError = err;\n                logger.error(`Initial JSON parse failed for job ${jobId}:`, parseError.message);\n                // First try to extract JSON content from the response\n                const jsonMatch = itineraryContent.match(/\\{[\\s\\S]*\\}/);\n                if (jsonMatch) {\n                    try {\n                        logger.debug(`Attempting to extract JSON from response for job ${jobId}`);\n                        itinerary = JSON.parse(jsonMatch[0]);\n                        logger.info(`JSON extracted and parsed successfully for job ${jobId}`);\n                    } catch (err2) {\n                        const extractError = err2;\n                        logger.error(`Failed to extract valid JSON for job ${jobId}:`, extractError.message);\n                        // Try to sanitize and repair the JSON\n                        try {\n                            logger.debug(`Attempting to sanitize and repair the JSON for job ${jobId}`);\n                            const sanitizedJSON = sanitizeJSON(itineraryContent);\n                            itinerary = JSON.parse(sanitizedJSON);\n                            logger.info(`Sanitized JSON parsed successfully for job ${jobId}`);\n                        } catch (err3) {\n                            throw parseError; // Fallback to the original error\n                        }\n                    }\n                } else {\n                    throw parseError;\n                }\n            }\n            // Quick validation of the itinerary\n            if (!itinerary || typeof itinerary !== \"object\") {\n                throw new Error(\"Parsed result is not a valid object\");\n            }\n            logger.debug(`Validating coordinates for job ${jobId}`);\n            // Ensure coordinates exist for all activities\n            ensureValidCoordinates(itinerary);\n            logger.info(`Coordinates validated successfully for job ${jobId}`);\n            // Update job status with the successful result\n            logger.info(`Updating job ${jobId} status to completed`);\n            await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"completed\", {\n                result: {\n                    itinerary,\n                    prompt: contentData.prompt,\n                    generatedAt: new Date().toISOString()\n                }\n            });\n            logger.info(`Job ${jobId} completed successfully`);\n            return true;\n        } catch (parseError) {\n            logger.error(`JSON parsing error for job ${jobId}:`, {\n                message: parseError.message,\n                stack: parseError.stack?.substring(0, 200)\n            });\n            // Content may be too long to include in logs, write to a debug file in development\n            if (true) {\n                try {\n                    const fs = __webpack_require__(/*! fs */ \"fs\");\n                    fs.writeFileSync(`debug-job-${jobId}.txt`, itineraryContent);\n                    logger.debug(`Wrote debug content to debug-job-${jobId}.txt`);\n                } catch (fsError) {\n                    logger.error(`Failed to write debug file for job ${jobId}:`, fsError);\n                }\n            }\n            // Update job status to failed\n            await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n                error: `Failed to parse itinerary JSON: ${parseError.message}`\n            });\n            logger.info(`Job ${jobId} failed due to JSON parsing error`);\n            return false;\n        }\n    } catch (error) {\n        logger.error(`Error processing itinerary job ${jobId}:`, {\n            message: error.message,\n            stack: error.stack?.substring(0, 200)\n        });\n        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n            error: error.message || \"Unknown error\"\n        });\n        return false;\n    }\n}\n// Process itinerary job by making a direct OpenAI API call\nasync function processItineraryJob(jobId, surveyData, promptGenerator, apiKey) {\n    try {\n        logger.info(`Processing itinerary job for job ${jobId}`);\n        // Use the provided prompt or generate one using the generator function\n        let prompt;\n        if (typeof promptGenerator === \"function\") {\n            prompt = promptGenerator(surveyData);\n            logger.debug(`Generated prompt for job ${jobId}, length: ${prompt.length} characters`);\n        } else {\n            prompt = promptGenerator;\n            logger.debug(`Using pre-formulated prompt for job ${jobId}, length: ${prompt.length} characters`);\n        }\n        // Call OpenAI API directly\n        logger.info(`Calling OpenAI API for job ${jobId}`);\n        const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": `Bearer ${apiKey}`\n            },\n            body: JSON.stringify({\n                model: \"gpt-3.5-turbo\",\n                messages: [\n                    {\n                        role: \"system\",\n                        content: 'You are an expert travel planner. Generate a detailed travel itinerary based on the user\\'s preferences. Return your response in a structured JSON format only, with no additional text, explanation, or markdown formatting. Do not wrap the JSON in code blocks. Ensure all property names use double quotes. IMPORTANT: Every activity MUST include a valid \"coordinates\" object with \"lat\" and \"lng\" numerical values - never omit coordinates or use empty objects. For price fields, DO NOT use $ symbols directly - use price descriptors like \"Budget\", \"Moderate\", \"Expensive\" or numeric values without currency symbols.'\n                    },\n                    {\n                        role: \"user\",\n                        content: prompt\n                    }\n                ],\n                temperature: 0.7,\n                max_tokens: 3000\n            })\n        });\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(`OpenAI API error: ${error.error?.message || \"Unknown error\"}`);\n        }\n        const openAIData = await response.json();\n        const rawContent = openAIData.choices[0].message.content;\n        // Process the raw response\n        await processItineraryResponse(jobId, {\n            rawContent,\n            prompt,\n            usage: openAIData.usage\n        });\n        return true;\n    } catch (error) {\n        logger.error(`Failed to process itinerary job ${jobId}:`, error);\n        // Update job status to failed\n        await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.updateJobStatus)(jobId, \"failed\", {\n            error: `OpenAI API error: ${error.message || \"Unknown error\"}`\n        });\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QThCO1FBQzlCLE1BQU0xQyw4REFBZUEsQ0FBQ3VDLE9BQU8sVUFBVTtZQUNyQ0csT0FBTyxDQUFDLGtCQUFrQixFQUFFQSxNQUFNTyxPQUFPLElBQUksZ0JBQWdCLENBQUM7UUFDaEU7UUFFQSxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRyYXZlbC1hZ2VudC8uL2FwcC9hcGkvam9iLXByb2Nlc3Nvci50cz85ZmRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVwZGF0ZUpvYlN0YXR1cyB9IGZyb20gJy4uLy4uL2xpYi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICcuLi8uLi9saWIvbG9nZ2VyJztcblxuLy8gQ3JlYXRlIGEgbG9nZ2VyIGZvciB0aGUgam9iIHByb2Nlc3NvclxuY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKCdqb2ItcHJvY2Vzc29yJyk7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBqb2IgSURcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUpvYklkKCk6IHN0cmluZyB7XG4gIHJldHVybiBgam9iXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gc2FuaXRpemUgSlNPTiAtIGZpeGVzIGNvbW1vbiBKU09OIHN5bnRheCBpc3N1ZXNcbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUpTT04oY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgbG9nZ2VyLmRlYnVnKCdTYW5pdGl6aW5nIEpTT04gY29udGVudCcpO1xuICBcbiAgLy8gUmVtb3ZlIEphdmFTY3JpcHQtc3R5bGUgY29tbWVudHNcbiAgbGV0IHNhbml0aXplZCA9IGNvbnRlbnQucmVwbGFjZSgvXFwvXFwvLio/KFxccj9cXG58JCkvZywgJyQxJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAvLyBGaXggcHJvcGVydHkgbmFtZXMgd2l0aG91dCBxdW90ZXNcbiAgc2FuaXRpemVkID0gc2FuaXRpemVkLnJlcGxhY2UoLyhcXHt8XFwsKVxccyooW2EtekEtWjAtOV9dKylcXHMqXFw6L2csICckMVwiJDJcIjonKTtcbiAgXG4gIC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYXNcbiAgc2FuaXRpemVkID0gc2FuaXRpemVkLnJlcGxhY2UoLywoXFxzKltcXF1cXH1dKS9nLCAnJDEnKTtcbiAgXG4gIC8vIFJlcGxhY2Ugc2luZ2xlIHF1b3RlcyB3aXRoIGRvdWJsZSBxdW90ZXNcbiAgc2FuaXRpemVkID0gc2FuaXRpemVkLnJlcGxhY2UoLycvZywgJ1wiJyk7XG4gIFxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuXG4vLyBFbnN1cmUgdmFsaWQgY29vcmRpbmF0ZXMgaW4gdGhlIGl0aW5lcmFyeVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVZhbGlkQ29vcmRpbmF0ZXMoaXRpbmVyYXJ5OiBhbnkpOiBhbnkge1xuICBsb2dnZXIuZGVidWcoJ1ZhbGlkYXRpbmcgYW5kIGZpeGluZyBjb29yZGluYXRlcyBpbiBpdGluZXJhcnknKTtcbiAgXG4gIC8vIERlZmF1bHQgYmFja3VwIGNvb3JkaW5hdGVzIGZvciBQYXJpcyAodXNlIGFzIGxhc3QgcmVzb3J0KVxuICBjb25zdCBkZWZhdWx0Q29vcmRpbmF0ZXMgPSB7IGxhdDogNDguODU2NiwgbG5nOiAyLjM1MjIgfTtcbiAgXG4gIC8vIEhlbHBlciB0byB2YWxpZGF0ZSBhIHNpbmdsZSBjb29yZGluYXRlcyBvYmplY3RcbiAgY29uc3QgaXNWYWxpZENvb3JkaW5hdGVzID0gKGNvb3JkczogYW55KTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIGNvb3JkcyAmJiBcbiAgICAgICAgICAgdHlwZW9mIGNvb3JkcyA9PT0gJ29iamVjdCcgJiYgXG4gICAgICAgICAgIHR5cGVvZiBjb29yZHMubGF0ID09PSAnbnVtYmVyJyAmJiBcbiAgICAgICAgICAgdHlwZW9mIGNvb3Jkcy5sbmcgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICFpc05hTihjb29yZHMubGF0KSAmJiBcbiAgICAgICAgICAgIWlzTmFOKGNvb3Jkcy5sbmcpO1xuICB9O1xuICBcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGRheXMsIG5vdGhpbmcgdG8gZG9cbiAgaWYgKCFpdGluZXJhcnkuZGF5cyB8fCAhQXJyYXkuaXNBcnJheShpdGluZXJhcnkuZGF5cykpIHtcbiAgICBsb2dnZXIud2FybignTm8gZGF5cyBhcnJheSBmb3VuZCBpbiBpdGluZXJhcnknKTtcbiAgICByZXR1cm4gaXRpbmVyYXJ5O1xuICB9XG4gIFxuICAvLyBUcmFjayBpc3N1ZXMgZm91bmRcbiAgbGV0IGlzc3Vlc0ZvdW5kID0gMDtcbiAgXG4gIC8vIENoZWNrIGVhY2ggZGF5IGFuZCBhY3Rpdml0eVxuICBpdGluZXJhcnkuZGF5cy5mb3JFYWNoKChkYXk6IGFueSwgZGF5SW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGlmICghZGF5LmFjdGl2aXRpZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF5LmFjdGl2aXRpZXMpKSB7XG4gICAgICBsb2dnZXIud2FybihgRGF5ICR7ZGF5SW5kZXggKyAxfSBoYXMgbm8gYWN0aXZpdGllcyBhcnJheWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBkYXkuYWN0aXZpdGllcy5mb3JFYWNoKChhY3Rpdml0eTogYW55LCBhY3Rpdml0eUluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIC8vIFNraXAgaWYgdGhlcmUncyBubyBhY3Rpdml0eSBvYmplY3RcbiAgICAgIGlmICghYWN0aXZpdHkgfHwgdHlwZW9mIGFjdGl2aXR5ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2dnZXIud2FybihgSW52YWxpZCBhY3Rpdml0eSBhdCBkYXkgJHtkYXlJbmRleCArIDF9LCBpbmRleCAke2FjdGl2aXR5SW5kZXh9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgY29vcmRpbmF0ZXMgZXhpc3QgYW5kIGFyZSB2YWxpZFxuICAgICAgaWYgKCFpc1ZhbGlkQ29vcmRpbmF0ZXMoYWN0aXZpdHkuY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgIGlzc3Vlc0ZvdW5kKys7XG4gICAgICAgIGxvZ2dlci53YXJuKGBJbnZhbGlkIGNvb3JkaW5hdGVzIGZvdW5kIGZvciBhY3Rpdml0eSBcIiR7YWN0aXZpdHkudGl0bGV9XCIgb24gZGF5ICR7ZGF5SW5kZXggKyAxfWAsIHtcbiAgICAgICAgICBjb29yZGluYXRlczogYWN0aXZpdHkuY29vcmRpbmF0ZXMsXG4gICAgICAgICAgYWN0aXZpdHlJbmRleCxcbiAgICAgICAgICBkYXlJbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoZSBjb29yZGluYXRlcyBleGlzdCBidXQgYXJlIGludmFsaWQsIHRyeSB0byBmaXggdGhlbVxuICAgICAgICBpZiAoYWN0aXZpdHkuY29vcmRpbmF0ZXMgJiYgdHlwZW9mIGFjdGl2aXR5LmNvb3JkaW5hdGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIFRyeSB0byBjb252ZXJ0IHN0cmluZyB2YWx1ZXMgdG8gbnVtYmVyc1xuICAgICAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYWN0aXZpdHkuY29vcmRpbmF0ZXMubGF0ID0gcGFyc2VGbG9hdChhY3Rpdml0eS5jb29yZGluYXRlcy5sYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGFjdGl2aXR5LmNvb3JkaW5hdGVzLmxuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFjdGl2aXR5LmNvb3JkaW5hdGVzLmxuZyA9IHBhcnNlRmxvYXQoYWN0aXZpdHkuY29vcmRpbmF0ZXMubG5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgc3RpbGwgaW52YWxpZCwgdXNlIGRlZmF1bHRcbiAgICAgICAgICBpZiAoIWlzVmFsaWRDb29yZGluYXRlcyhhY3Rpdml0eS5jb29yZGluYXRlcykpIHtcbiAgICAgICAgICAgIGFjdGl2aXR5LmNvb3JkaW5hdGVzID0geyAuLi5kZWZhdWx0Q29vcmRpbmF0ZXMgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gY29vcmRpbmF0ZXMgb3IgY29tcGxldGVseSBpbnZhbGlkLCB1c2UgZGVmYXVsdFxuICAgICAgICAgIGFjdGl2aXR5LmNvb3JkaW5hdGVzID0geyAuLi5kZWZhdWx0Q29vcmRpbmF0ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBGaXhlZCBjb29yZGluYXRlcyBmb3IgYWN0aXZpdHkgXCIke2FjdGl2aXR5LnRpdGxlfVwiYCwgYWN0aXZpdHkuY29vcmRpbmF0ZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgXG4gIGlmIChpc3N1ZXNGb3VuZCA+IDApIHtcbiAgICBsb2dnZXIuaW5mbyhgRml4ZWQgJHtpc3N1ZXNGb3VuZH0gY29vcmRpbmF0ZSBpc3N1ZXMgaW4gaXRpbmVyYXJ5YCk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdBbGwgY29vcmRpbmF0ZXMgaW4gaXRpbmVyYXJ5IGFyZSB2YWxpZCcpO1xuICB9XG4gIFxuICByZXR1cm4gaXRpbmVyYXJ5O1xufVxuXG4vLyBQYXJzZSBhbmQgcHJvY2VzcyB0aGUgT3BlbkFJIHJlc3BvbnNlIGZyb20gRWRnZSBGdW5jdGlvblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJdGluZXJhcnlSZXNwb25zZShqb2JJZDogc3RyaW5nLCBjb250ZW50RGF0YTogYW55KTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgbG9nZ2VyLmluZm8oYFByb2Nlc3NpbmcgaXRpbmVyYXJ5IHJlc3BvbnNlIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICBcbiAgICBpZiAoIWNvbnRlbnREYXRhIHx8ICFjb250ZW50RGF0YS5yYXdDb250ZW50KSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZGF0YSBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7IFxuICAgICAgICBlcnJvcjogJ0ludmFsaWQgcmVzcG9uc2UgZGF0YSBmcm9tIFN1cGFiYXNlIGVkZ2UgZnVuY3Rpb24nIFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGl0aW5lcmFyeUNvbnRlbnQgPSBjb250ZW50RGF0YS5yYXdDb250ZW50O1xuICAgIGxvZ2dlci5kZWJ1ZyhgQ29udGVudCBsZW5ndGggZm9yIGpvYiAke2pvYklkfTogJHtpdGluZXJhcnlDb250ZW50Lmxlbmd0aH0gY2hhcmFjdGVyc2ApO1xuICAgIFxuICAgIC8vIFBhcnNlIHRoZSBKU09OIHJlc3BvbnNlIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBQYXJzaW5nIEpTT04gcmVzcG9uc2UgZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgXG4gICAgICAvLyBUcnkgZGlyZWN0IHBhcnNlIGZpcnN0XG4gICAgICBsZXQgaXRpbmVyYXJ5O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaXRpbmVyYXJ5ID0gSlNPTi5wYXJzZShpdGluZXJhcnlDb250ZW50KTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYEpTT04gZm9yIGpvYiAke2pvYklkfSBwYXJzZWQgc3VjY2Vzc2Z1bGx5IG9uIGZpcnN0IGF0dGVtcHRgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBwYXJzZUVycm9yID0gZXJyIGFzIEVycm9yO1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEluaXRpYWwgSlNPTiBwYXJzZSBmYWlsZWQgZm9yIGpvYiAke2pvYklkfTpgLCBwYXJzZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIGV4dHJhY3QgSlNPTiBjb250ZW50IGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IGpzb25NYXRjaCA9IGl0aW5lcmFyeUNvbnRlbnQubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xuICAgICAgICBpZiAoanNvbk1hdGNoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgQXR0ZW1wdGluZyB0byBleHRyYWN0IEpTT04gZnJvbSByZXNwb25zZSBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgICAgICAgICBpdGluZXJhcnkgPSBKU09OLnBhcnNlKGpzb25NYXRjaFswXSk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgSlNPTiBleHRyYWN0ZWQgYW5kIHBhcnNlZCBzdWNjZXNzZnVsbHkgZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RFcnJvciA9IGVycjIgYXMgRXJyb3I7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBleHRyYWN0IHZhbGlkIEpTT04gZm9yIGpvYiAke2pvYklkfTpgLCBleHRyYWN0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRyeSB0byBzYW5pdGl6ZSBhbmQgcmVwYWlyIHRoZSBKU09OXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEF0dGVtcHRpbmcgdG8gc2FuaXRpemUgYW5kIHJlcGFpciB0aGUgSlNPTiBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEpTT04gPSBzYW5pdGl6ZUpTT04oaXRpbmVyYXJ5Q29udGVudCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpdGluZXJhcnkgPSBKU09OLnBhcnNlKHNhbml0aXplZEpTT04pO1xuICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgU2FuaXRpemVkIEpTT04gcGFyc2VkIHN1Y2Nlc3NmdWxseSBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIzKSB7XG4gICAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3I7IC8vIEZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBwYXJzZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFF1aWNrIHZhbGlkYXRpb24gb2YgdGhlIGl0aW5lcmFyeVxuICAgICAgaWYgKCFpdGluZXJhcnkgfHwgdHlwZW9mIGl0aW5lcmFyeSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZWQgcmVzdWx0IGlzIG5vdCBhIHZhbGlkIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsb2dnZXIuZGVidWcoYFZhbGlkYXRpbmcgY29vcmRpbmF0ZXMgZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgY29vcmRpbmF0ZXMgZXhpc3QgZm9yIGFsbCBhY3Rpdml0aWVzXG4gICAgICBlbnN1cmVWYWxpZENvb3JkaW5hdGVzKGl0aW5lcmFyeSk7XG4gICAgICBsb2dnZXIuaW5mbyhgQ29vcmRpbmF0ZXMgdmFsaWRhdGVkIHN1Y2Nlc3NmdWxseSBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBqb2Igc3RhdHVzIHdpdGggdGhlIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgICBsb2dnZXIuaW5mbyhgVXBkYXRpbmcgam9iICR7am9iSWR9IHN0YXR1cyB0byBjb21wbGV0ZWRgKTtcbiAgICAgIGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ2NvbXBsZXRlZCcsIHsgcmVzdWx0OiB7IFxuICAgICAgICBpdGluZXJhcnksXG4gICAgICAgIHByb21wdDogY29udGVudERhdGEucHJvbXB0LCAvLyBJbmNsdWRlIHRoZSBwcm9tcHQgZm9yIHJlZmVyZW5jZVxuICAgICAgICBnZW5lcmF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9fSk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcjogYW55KSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYEpTT04gcGFyc2luZyBlcnJvciBmb3Igam9iICR7am9iSWR9OmAsIHtcbiAgICAgICAgbWVzc2FnZTogcGFyc2VFcnJvci5tZXNzYWdlLFxuICAgICAgICBzdGFjazogcGFyc2VFcnJvci5zdGFjaz8uc3Vic3RyaW5nKDAsIDIwMClcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDb250ZW50IG1heSBiZSB0b28gbG9uZyB0byBpbmNsdWRlIGluIGxvZ3MsIHdyaXRlIHRvIGEgZGVidWcgZmlsZSBpbiBkZXZlbG9wbWVudFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoYGRlYnVnLWpvYi0ke2pvYklkfS50eHRgLCBpdGluZXJhcnlDb250ZW50KTtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFdyb3RlIGRlYnVnIGNvbnRlbnQgdG8gZGVidWctam9iLSR7am9iSWR9LnR4dGApO1xuICAgICAgICB9IGNhdGNoIChmc0Vycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gd3JpdGUgZGVidWcgZmlsZSBmb3Igam9iICR7am9iSWR9OmAsIGZzRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBqb2Igc3RhdHVzIHRvIGZhaWxlZFxuICAgICAgYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCAnZmFpbGVkJywge1xuICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBwYXJzZSBpdGluZXJhcnkgSlNPTjogJHtwYXJzZUVycm9yLm1lc3NhZ2V9YFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gZmFpbGVkIGR1ZSB0byBKU09OIHBhcnNpbmcgZXJyb3JgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBsb2dnZXIuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgaXRpbmVyYXJ5IGpvYiAke2pvYklkfTpgLCB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrPy5zdWJzdHJpbmcoMCwgMjAwKVxuICAgIH0pO1xuICAgIGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgJ2ZhaWxlZCcsIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBQcm9jZXNzIGl0aW5lcmFyeSBqb2IgYnkgbWFraW5nIGEgZGlyZWN0IE9wZW5BSSBBUEkgY2FsbFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJdGluZXJhcnlKb2IoXG4gIGpvYklkOiBzdHJpbmcsIFxuICBzdXJ2ZXlEYXRhOiBhbnksIFxuICBwcm9tcHRHZW5lcmF0b3I6ICgoc3VydmV5RGF0YTogYW55KSA9PiBzdHJpbmcpIHwgc3RyaW5nLFxuICBhcGlLZXk6IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgbG9nZ2VyLmluZm8oYFByb2Nlc3NpbmcgaXRpbmVyYXJ5IGpvYiBmb3Igam9iICR7am9iSWR9YCk7XG4gICAgXG4gICAgLy8gVXNlIHRoZSBwcm92aWRlZCBwcm9tcHQgb3IgZ2VuZXJhdGUgb25lIHVzaW5nIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb25cbiAgICBsZXQgcHJvbXB0OiBzdHJpbmc7XG4gICAgaWYgKHR5cGVvZiBwcm9tcHRHZW5lcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb21wdCA9IHByb21wdEdlbmVyYXRvcihzdXJ2ZXlEYXRhKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgR2VuZXJhdGVkIHByb21wdCBmb3Igam9iICR7am9iSWR9LCBsZW5ndGg6ICR7cHJvbXB0Lmxlbmd0aH0gY2hhcmFjdGVyc2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9tcHQgPSBwcm9tcHRHZW5lcmF0b3I7XG4gICAgICBsb2dnZXIuZGVidWcoYFVzaW5nIHByZS1mb3JtdWxhdGVkIHByb21wdCBmb3Igam9iICR7am9iSWR9LCBsZW5ndGg6ICR7cHJvbXB0Lmxlbmd0aH0gY2hhcmFjdGVyc2ApO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxsIE9wZW5BSSBBUEkgZGlyZWN0bHlcbiAgICBsb2dnZXIuaW5mbyhgQ2FsbGluZyBPcGVuQUkgQVBJIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2NoYXQvY29tcGxldGlvbnMnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YXBpS2V5fWAsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8nLFxuICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICAgICAgY29udGVudDogJ1lvdSBhcmUgYW4gZXhwZXJ0IHRyYXZlbCBwbGFubmVyLiBHZW5lcmF0ZSBhIGRldGFpbGVkIHRyYXZlbCBpdGluZXJhcnkgYmFzZWQgb24gdGhlIHVzZXJcXCdzIHByZWZlcmVuY2VzLiBSZXR1cm4geW91ciByZXNwb25zZSBpbiBhIHN0cnVjdHVyZWQgSlNPTiBmb3JtYXQgb25seSwgd2l0aCBubyBhZGRpdGlvbmFsIHRleHQsIGV4cGxhbmF0aW9uLCBvciBtYXJrZG93biBmb3JtYXR0aW5nLiBEbyBub3Qgd3JhcCB0aGUgSlNPTiBpbiBjb2RlIGJsb2Nrcy4gRW5zdXJlIGFsbCBwcm9wZXJ0eSBuYW1lcyB1c2UgZG91YmxlIHF1b3Rlcy4gSU1QT1JUQU5UOiBFdmVyeSBhY3Rpdml0eSBNVVNUIGluY2x1ZGUgYSB2YWxpZCBcImNvb3JkaW5hdGVzXCIgb2JqZWN0IHdpdGggXCJsYXRcIiBhbmQgXCJsbmdcIiBudW1lcmljYWwgdmFsdWVzIC0gbmV2ZXIgb21pdCBjb29yZGluYXRlcyBvciB1c2UgZW1wdHkgb2JqZWN0cy4gRm9yIHByaWNlIGZpZWxkcywgRE8gTk9UIHVzZSAkIHN5bWJvbHMgZGlyZWN0bHkgLSB1c2UgcHJpY2UgZGVzY3JpcHRvcnMgbGlrZSBcIkJ1ZGdldFwiLCBcIk1vZGVyYXRlXCIsIFwiRXhwZW5zaXZlXCIgb3IgbnVtZXJpYyB2YWx1ZXMgd2l0aG91dCBjdXJyZW5jeSBzeW1ib2xzLidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHByb21wdFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICAgICAgbWF4X3Rva2VuczogMzAwMCxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wZW5BSSBBUEkgZXJyb3I6ICR7ZXJyb3IuZXJyb3I/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wZW5BSURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgcmF3Q29udGVudCA9IG9wZW5BSURhdGEuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQ7XG4gICAgXG4gICAgLy8gUHJvY2VzcyB0aGUgcmF3IHJlc3BvbnNlXG4gICAgYXdhaXQgcHJvY2Vzc0l0aW5lcmFyeVJlc3BvbnNlKGpvYklkLCB7IFxuICAgICAgcmF3Q29udGVudCwgXG4gICAgICBwcm9tcHQsXG4gICAgICB1c2FnZTogb3BlbkFJRGF0YS51c2FnZVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBpdGluZXJhcnkgam9iICR7am9iSWR9OmAsIGVycm9yKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgam9iIHN0YXR1cyB0byBmYWlsZWRcbiAgICBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsICdmYWlsZWQnLCB7XG4gICAgICBlcnJvcjogYE9wZW5BSSBBUEkgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YFxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSAiXSwibmFtZXMiOlsidXBkYXRlSm9iU3RhdHVzIiwiY3JlYXRlTG9nZ2VyIiwibG9nZ2VyIiwiZ2VuZXJhdGVKb2JJZCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJzYW5pdGl6ZUpTT04iLCJjb250ZW50IiwiZGVidWciLCJzYW5pdGl6ZWQiLCJyZXBsYWNlIiwiZW5zdXJlVmFsaWRDb29yZGluYXRlcyIsIml0aW5lcmFyeSIsImRlZmF1bHRDb29yZGluYXRlcyIsImxhdCIsImxuZyIsImlzVmFsaWRDb29yZGluYXRlcyIsImNvb3JkcyIsImlzTmFOIiwiZGF5cyIsIkFycmF5IiwiaXNBcnJheSIsIndhcm4iLCJpc3N1ZXNGb3VuZCIsImZvckVhY2giLCJkYXkiLCJkYXlJbmRleCIsImFjdGl2aXRpZXMiLCJhY3Rpdml0eSIsImFjdGl2aXR5SW5kZXgiLCJjb29yZGluYXRlcyIsInRpdGxlIiwicGFyc2VGbG9hdCIsImluZm8iLCJwcm9jZXNzSXRpbmVyYXJ5UmVzcG9uc2UiLCJqb2JJZCIsImNvbnRlbnREYXRhIiwicmF3Q29udGVudCIsImVycm9yIiwiaXRpbmVyYXJ5Q29udGVudCIsImxlbmd0aCIsIkpTT04iLCJwYXJzZSIsImVyciIsInBhcnNlRXJyb3IiLCJtZXNzYWdlIiwianNvbk1hdGNoIiwibWF0Y2giLCJlcnIyIiwiZXh0cmFjdEVycm9yIiwic2FuaXRpemVkSlNPTiIsImVycjMiLCJFcnJvciIsInJlc3VsdCIsInByb21wdCIsImdlbmVyYXRlZEF0IiwidG9JU09TdHJpbmciLCJzdGFjayIsInByb2Nlc3MiLCJmcyIsInJlcXVpcmUiLCJ3cml0ZUZpbGVTeW5jIiwiZnNFcnJvciIsInByb2Nlc3NJdGluZXJhcnlKb2IiLCJzdXJ2ZXlEYXRhIiwicHJvbXB0R2VuZXJhdG9yIiwiYXBpS2V5IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5Iiwic3RyaW5naWZ5IiwibW9kZWwiLCJtZXNzYWdlcyIsInJvbGUiLCJ0ZW1wZXJhdHVyZSIsIm1heF90b2tlbnMiLCJvayIsImpzb24iLCJvcGVuQUlEYXRhIiwiY2hvaWNlcyIsInVzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/job-processor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/logger.ts":
/*!***********************!*\
  !*** ./lib/logger.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLogger: () => (/* binding */ createLogger),\n/* harmony export */   logger: () => (/* binding */ logger)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n// Advanced logger utility for structured logging with context\n\n\n\n// Configure log file path - default to logs directory in project root\nconst LOG_DIR = process.env.LOG_DIR || \"logs\";\nconst LOG_FILE = process.env.LOG_FILE || \"app.log\";\nconst MAX_LOG_SIZE = 5 * 1024 * 1024; // 5MB max log file size\nconst LOG_LEVEL = process.env.LOG_LEVEL || \"info\";\n// Ensure log directory exists\ntry {\n    if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(LOG_DIR)) {\n        fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(LOG_DIR, {\n            recursive: true\n        });\n    }\n} catch (err) {\n    console.error(\"Failed to create log directory:\", err);\n}\n// Define log levels as numbers for comparisons\nconst logLevelValues = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3\n};\n/**\n * Write log to file with rotation\n */ function writeToFile(message) {\n    try {\n        const logPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(LOG_DIR, LOG_FILE);\n        // Check if log file exists and if it's too large\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(logPath)) {\n            const stats = fs__WEBPACK_IMPORTED_MODULE_0___default().statSync(logPath);\n            if (stats.size > MAX_LOG_SIZE) {\n                // Create backup of current log file with timestamp\n                const timestamp = new Date().toISOString().replace(/:/g, \"-\");\n                const backupPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(LOG_DIR, `${LOG_FILE}.${timestamp}.backup`);\n                fs__WEBPACK_IMPORTED_MODULE_0___default().renameSync(logPath, backupPath);\n            }\n        }\n        (0,fs__WEBPACK_IMPORTED_MODULE_0__.appendFileSync)(logPath, message + \"\\n\");\n    } catch (err) {\n        console.error(\"Failed to write to log file:\", err);\n    }\n}\n/**\n * Format object for logging - handles circular refs and formats nicely\n */ function formatObject(obj) {\n    try {\n        // Remove circular references\n        const seen = new WeakSet();\n        const safeObj = JSON.stringify(obj, (key, value)=>{\n            if (typeof value === \"object\" && value !== null) {\n                if (seen.has(value)) {\n                    return \"[Circular]\";\n                }\n                seen.add(value);\n            }\n            return value;\n        }, 2);\n        return safeObj;\n    } catch (err) {\n        return `[Unformattable Object: ${err}]`;\n    }\n}\n/**\n * Main logger function\n */ function logWithLevel(level, context, message, ...args) {\n    // Skip logs below current level\n    if (logLevelValues[level] < logLevelValues[LOG_LEVEL]) {\n        return;\n    }\n    const timestamp = new Date().toISOString();\n    const formattedArgs = args.map((arg)=>typeof arg === \"object\" && arg !== null ? formatObject(arg) : String(arg)).join(\" \");\n    const logEntry = `[${timestamp}] [${level.toUpperCase()}] [${context}] ${message} ${formattedArgs}`;\n    // Always log to console for immediate feedback\n    if (level === \"error\") {\n        console.error(logEntry);\n    } else if (level === \"warn\") {\n        console.warn(logEntry);\n    } else {\n        console.log(logEntry);\n    }\n    // Also write to log file\n    writeToFile(logEntry);\n}\n/**\n * Create a logger for a specific context\n */ function createLogger(context) {\n    return {\n        debug: (message, ...args)=>logWithLevel(\"debug\", context, message, ...args),\n        info: (message, ...args)=>logWithLevel(\"info\", context, message, ...args),\n        warn: (message, ...args)=>logWithLevel(\"warn\", context, message, ...args),\n        error: (message, ...args)=>logWithLevel(\"error\", context, message, ...args)\n    };\n}\n// Export a default logger\nconst logger = createLogger(\"app\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Qy9DLElBQUlILFVBQVUsU0FBUztRQUNyQi9CLFFBQVFDLEtBQUssQ0FBQ3FDO0lBQ2hCLE9BQU8sSUFBSVAsVUFBVSxRQUFRO1FBQzNCL0IsUUFBUUssSUFBSSxDQUFDaUM7SUFDZixPQUFPO1FBQ0x0QyxRQUFRd0MsR0FBRyxDQUFDRjtJQUNkO0lBRUEseUJBQXlCO0lBQ3pCaEMsWUFBWWdDO0FBQ2Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNHLGFBQWFULE9BQWU7SUFDMUMsT0FBTztRQUNMN0IsT0FBTyxDQUFDSSxTQUFpQixHQUFHMEIsT0FBZ0JILGFBQWEsU0FBU0UsU0FBU3pCLFlBQVkwQjtRQUN2RjdCLE1BQU0sQ0FBQ0csU0FBaUIsR0FBRzBCLE9BQWdCSCxhQUFhLFFBQVFFLFNBQVN6QixZQUFZMEI7UUFDckY1QixNQUFNLENBQUNFLFNBQWlCLEdBQUcwQixPQUFnQkgsYUFBYSxRQUFRRSxTQUFTekIsWUFBWTBCO1FBQ3JGaEMsT0FBTyxDQUFDTSxTQUFpQixHQUFHMEIsT0FBZ0JILGFBQWEsU0FBU0UsU0FBU3pCLFlBQVkwQjtJQUN6RjtBQUNGO0FBRUEsMEJBQTBCO0FBQ25CLE1BQU1TLFNBQVNELGFBQWEsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXRyYXZlbC1hZ2VudC8uL2xpYi9sb2dnZXIudHM/ZmQ1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBZHZhbmNlZCBsb2dnZXIgdXRpbGl0eSBmb3Igc3RydWN0dXJlZCBsb2dnaW5nIHdpdGggY29udGV4dFxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgYXBwZW5kRmlsZVN5bmMgfSBmcm9tICdmcyc7XG5cbi8vIExvZyBsZXZlbHNcbmV4cG9ydCB0eXBlIExvZ0xldmVsID0gJ2RlYnVnJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcic7XG5cbi8vIENvbmZpZ3VyZSBsb2cgZmlsZSBwYXRoIC0gZGVmYXVsdCB0byBsb2dzIGRpcmVjdG9yeSBpbiBwcm9qZWN0IHJvb3RcbmNvbnN0IExPR19ESVIgPSBwcm9jZXNzLmVudi5MT0dfRElSIHx8ICdsb2dzJztcbmNvbnN0IExPR19GSUxFID0gcHJvY2Vzcy5lbnYuTE9HX0ZJTEUgfHwgJ2FwcC5sb2cnO1xuY29uc3QgTUFYX0xPR19TSVpFID0gNSAqIDEwMjQgKiAxMDI0OyAvLyA1TUIgbWF4IGxvZyBmaWxlIHNpemVcbmNvbnN0IExPR19MRVZFTCA9IChwcm9jZXNzLmVudi5MT0dfTEVWRUwgfHwgJ2luZm8nKSBhcyBMb2dMZXZlbDtcblxuLy8gRW5zdXJlIGxvZyBkaXJlY3RvcnkgZXhpc3RzXG50cnkge1xuICBpZiAoIWZzLmV4aXN0c1N5bmMoTE9HX0RJUikpIHtcbiAgICBmcy5ta2RpclN5bmMoTE9HX0RJUiwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIH1cbn0gY2F0Y2ggKGVycikge1xuICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGxvZyBkaXJlY3Rvcnk6JywgZXJyKTtcbn1cblxuLy8gRGVmaW5lIGxvZyBsZXZlbHMgYXMgbnVtYmVycyBmb3IgY29tcGFyaXNvbnNcbmNvbnN0IGxvZ0xldmVsVmFsdWVzOiBSZWNvcmQ8TG9nTGV2ZWwsIG51bWJlcj4gPSB7XG4gIGRlYnVnOiAwLFxuICBpbmZvOiAxLFxuICB3YXJuOiAyLFxuICBlcnJvcjogM1xufTtcblxuLyoqXG4gKiBXcml0ZSBsb2cgdG8gZmlsZSB3aXRoIHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVG9GaWxlKG1lc3NhZ2U6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IGxvZ1BhdGggPSBwYXRoLmpvaW4oTE9HX0RJUiwgTE9HX0ZJTEUpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGxvZyBmaWxlIGV4aXN0cyBhbmQgaWYgaXQncyB0b28gbGFyZ2VcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2dQYXRoKSkge1xuICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhsb2dQYXRoKTtcbiAgICAgIGlmIChzdGF0cy5zaXplID4gTUFYX0xPR19TSVpFKSB7XG4gICAgICAgIC8vIENyZWF0ZSBiYWNrdXAgb2YgY3VycmVudCBsb2cgZmlsZSB3aXRoIHRpbWVzdGFtcFxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvOi9nLCAnLScpO1xuICAgICAgICBjb25zdCBiYWNrdXBQYXRoID0gcGF0aC5qb2luKExPR19ESVIsIGAke0xPR19GSUxFfS4ke3RpbWVzdGFtcH0uYmFja3VwYCk7XG4gICAgICAgIGZzLnJlbmFtZVN5bmMobG9nUGF0aCwgYmFja3VwUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGFwcGVuZEZpbGVTeW5jKGxvZ1BhdGgsIG1lc3NhZ2UgKyAnXFxuJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSB0byBsb2cgZmlsZTonLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IG9iamVjdCBmb3IgbG9nZ2luZyAtIGhhbmRsZXMgY2lyY3VsYXIgcmVmcyBhbmQgZm9ybWF0cyBuaWNlbHlcbiAqL1xuZnVuY3Rpb24gZm9ybWF0T2JqZWN0KG9iajogYW55KTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICAvLyBSZW1vdmUgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHNhZmVPYmogPSBKU09OLnN0cmluZ2lmeShvYmosIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgMik7XG4gICAgXG4gICAgcmV0dXJuIHNhZmVPYmo7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBgW1VuZm9ybWF0dGFibGUgT2JqZWN0OiAke2Vycn1dYDtcbiAgfVxufVxuXG4vKipcbiAqIE1haW4gbG9nZ2VyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGxvZ1dpdGhMZXZlbChsZXZlbDogTG9nTGV2ZWwsIGNvbnRleHQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAvLyBTa2lwIGxvZ3MgYmVsb3cgY3VycmVudCBsZXZlbFxuICBpZiAobG9nTGV2ZWxWYWx1ZXNbbGV2ZWxdIDwgbG9nTGV2ZWxWYWx1ZXNbTE9HX0xFVkVMIGFzIExvZ0xldmVsXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBmb3JtYXR0ZWRBcmdzID0gYXJncy5tYXAoYXJnID0+IFxuICAgIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbCA/IGZvcm1hdE9iamVjdChhcmcpIDogU3RyaW5nKGFyZylcbiAgKS5qb2luKCcgJyk7XG4gIFxuICBjb25zdCBsb2dFbnRyeSA9IGBbJHt0aW1lc3RhbXB9XSBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0gWyR7Y29udGV4dH1dICR7bWVzc2FnZX0gJHtmb3JtYXR0ZWRBcmdzfWA7XG4gIFxuICAvLyBBbHdheXMgbG9nIHRvIGNvbnNvbGUgZm9yIGltbWVkaWF0ZSBmZWVkYmFja1xuICBpZiAobGV2ZWwgPT09ICdlcnJvcicpIHtcbiAgICBjb25zb2xlLmVycm9yKGxvZ0VudHJ5KTtcbiAgfSBlbHNlIGlmIChsZXZlbCA9PT0gJ3dhcm4nKSB7XG4gICAgY29uc29sZS53YXJuKGxvZ0VudHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhsb2dFbnRyeSk7XG4gIH1cbiAgXG4gIC8vIEFsc28gd3JpdGUgdG8gbG9nIGZpbGVcbiAgd3JpdGVUb0ZpbGUobG9nRW50cnkpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxvZ2dlciBmb3IgYSBzcGVjaWZpYyBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2dnZXIoY29udGV4dDogc3RyaW5nKSB7XG4gIHJldHVybiB7XG4gICAgZGVidWc6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSA9PiBsb2dXaXRoTGV2ZWwoJ2RlYnVnJywgY29udGV4dCwgbWVzc2FnZSwgLi4uYXJncyksXG4gICAgaW5mbzogKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IGxvZ1dpdGhMZXZlbCgnaW5mbycsIGNvbnRleHQsIG1lc3NhZ2UsIC4uLmFyZ3MpLFxuICAgIHdhcm46IChtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSA9PiBsb2dXaXRoTGV2ZWwoJ3dhcm4nLCBjb250ZXh0LCBtZXNzYWdlLCAuLi5hcmdzKSxcbiAgICBlcnJvcjogKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IGxvZ1dpdGhMZXZlbCgnZXJyb3InLCBjb250ZXh0LCBtZXNzYWdlLCAuLi5hcmdzKSxcbiAgfTtcbn1cblxuLy8gRXhwb3J0IGEgZGVmYXVsdCBsb2dnZXJcbmV4cG9ydCBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoJ2FwcCcpOyAiXSwibmFtZXMiOlsiZnMiLCJwYXRoIiwiYXBwZW5kRmlsZVN5bmMiLCJMT0dfRElSIiwicHJvY2VzcyIsImVudiIsIkxPR19GSUxFIiwiTUFYX0xPR19TSVpFIiwiTE9HX0xFVkVMIiwiZXhpc3RzU3luYyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImxvZ0xldmVsVmFsdWVzIiwiZGVidWciLCJpbmZvIiwid2FybiIsIndyaXRlVG9GaWxlIiwibWVzc2FnZSIsImxvZ1BhdGgiLCJqb2luIiwic3RhdHMiLCJzdGF0U3luYyIsInNpemUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwiYmFja3VwUGF0aCIsInJlbmFtZVN5bmMiLCJmb3JtYXRPYmplY3QiLCJvYmoiLCJzZWVuIiwiV2Vha1NldCIsInNhZmVPYmoiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5IiwidmFsdWUiLCJoYXMiLCJhZGQiLCJsb2dXaXRoTGV2ZWwiLCJsZXZlbCIsImNvbnRleHQiLCJhcmdzIiwiZm9ybWF0dGVkQXJncyIsIm1hcCIsImFyZyIsIlN0cmluZyIsImxvZ0VudHJ5IiwidG9VcHBlckNhc2UiLCJsb2ciLCJjcmVhdGVMb2dnZXIiLCJsb2dnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/logger.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   countJobsByStatus: () => (/* binding */ countJobsByStatus),\n/* harmony export */   createJob: () => (/* binding */ createJob),\n/* harmony export */   getInMemoryJobs: () => (/* binding */ getInMemoryJobs),\n/* harmony export */   getJobStatus: () => (/* binding */ getJobStatus),\n/* harmony export */   getRecentJobs: () => (/* binding */ getRecentJobs),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   updateJobStatus: () => (/* binding */ updateJobStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ \"(rsc)/./lib/logger.ts\");\n\n\n// Create a logger for the Supabase module\nconst logger = (0,_logger__WEBPACK_IMPORTED_MODULE_0__.createLogger)(\"supabase\");\n// Explicitly log all environment variables for debugging\nlogger.info(\"Supabase initialization\", {\n    NODE_ENV: \"development\",\n    hasProcessEnv: typeof process !== \"undefined\" && !!process.env,\n    nodeEnv: \"development\",\n    hasSbUrl: \"NEXT_PUBLIC_SUPABASE_URL\" in process.env,\n    hasSbKey: \"NEXT_PUBLIC_SUPABASE_ANON_KEY\" in process.env,\n    nextConfig: \"string\" === \"string\",\n    envVarCount: Object.keys(process.env).filter((key)=>key.startsWith(\"NEXT_\")).length\n});\n// Supabase client setup\n// Directly access variables for debugging rather than using || '' pattern initially\nlet supabaseUrl = \"https://toaiekqwflojwicejvne.supabase.co\";\nlet supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvYWlla3F3ZmxvandpY2Vqdm5lIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5MzM2MzMsImV4cCI6MjA2MDUwOTYzM30.E70hBHGjbvCJPjYpMmlMIMvyfyBlotOwP01YaXf37Mg\";\n// Debug Supabase setup without exposing keys\nlogger.debug(\"Supabase credentials\", {\n    urlPrefix: supabaseUrl?.substring(0, 12) + \"...\" || 0,\n    keyPrefix: supabaseAnonKey?.substring(0, 6) + \"...\" || 0\n});\n// Fallback to empty string if undefined\nsupabaseUrl = supabaseUrl || \"\";\nsupabaseAnonKey = supabaseAnonKey || \"\";\n// Debug Supabase setup without exposing keys\nlogger.info(\"Supabase configuration check\", {\n    hasUrl: Boolean(supabaseUrl),\n    urlLength: supabaseUrl?.length || 0,\n    urlPrefix: supabaseUrl?.substring(0, 8) || \"\",\n    hasKey: Boolean(supabaseAnonKey),\n    keyLength: supabaseAnonKey?.length || 0,\n    keyPrefix: supabaseAnonKey?.substring(0, 4) || \"\"\n});\n// Check if Supabase is configured properly\nconst isSupabaseConfigured = Boolean(supabaseUrl && supabaseAnonKey);\n// In-memory store to track if Supabase connectivity failed during runtime\nlet supabaseDisabled = false;\n// Initialize the Supabase client with explicit options for better reliability\nconst supabase = isSupabaseConfigured ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    },\n    global: {\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    },\n    db: {\n        schema: \"public\"\n    }\n}) : (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(\"https://placeholder-url.supabase.co\", \"placeholder-key\", {\n    auth: {\n        persistSession: false,\n        autoRefreshToken: false\n    }\n});\n// Log initialization status\nif (!isSupabaseConfigured) {\n    logger.warn(\"Supabase not properly configured. Using in-memory job storage as fallback.\");\n} else {\n    logger.info(\"Supabase client initialized, verifying connection...\");\n    // Attempt to verify connection and ensure the jobs table exists\n    verifySupabaseConnection().catch((err)=>{\n        logger.error(\"Failed to verify Supabase connection:\", err.message);\n    });\n}\n// In-memory fallback store for development or when Supabase isn't configured\nconst inMemoryJobs = {};\n// Function to verify the Supabase connection\nasync function verifySupabaseConnection() {\n    if (!isSupabaseConfigured) return;\n    try {\n        logger.info(\"Checking Supabase connection...\");\n        // First try to directly query if the jobs table exists\n        const { data, error } = await supabase.from(\"jobs\").select(\"*\").limit(1);\n        if (error) {\n            // Table might not exist\n            if (error.code === \"42P01\") {\n                logger.warn(\"Jobs table does not exist, will attempt to create it\");\n                await ensureJobsTableExists();\n            } else {\n                logger.error(\"Supabase connection verification failed:\", {\n                    message: error.message,\n                    code: error.code,\n                    details: error.details\n                });\n            }\n        } else {\n            logger.info(\"Supabase connection verified successfully, jobs table exists\");\n            // Check to see if we have the right columns\n            await checkTableStructure(data);\n        }\n    } catch (error) {\n        logger.error(\"Error verifying Supabase connection:\", {\n            message: error.message,\n            stack: error.stack?.substring(0, 200)\n        });\n        // If this is a network error, disable Supabase\n        if (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\") || error instanceof TypeError) {\n            logger.warn(\"Disabling Supabase due to connection issues\");\n            supabaseDisabled = true;\n        }\n    }\n}\n// Check and adapt to existing table structure\nasync function checkTableStructure(sampleData) {\n    if (sampleData && sampleData.length > 0) {\n        // Log the structure we found for debugging\n        const firstRow = sampleData[0];\n        logger.debug(\"Found existing jobs table with columns:\", Object.keys(firstRow).join(\", \"));\n    }\n}\n// Function to check and create the jobs table if it doesn't exist\nasync function ensureJobsTableExists() {\n    if (!isSupabaseConfigured) return;\n    try {\n        logger.info(\"Attempting to create jobs table...\");\n        // Check if we have permission to execute SQL\n        try {\n            // First, try to create a simple table with the minimum required fields\n            const createTableSQL = `\n        CREATE TABLE IF NOT EXISTS jobs (\n          id BIGINT PRIMARY KEY,\n          status TEXT,\n          result JSONB,\n          error TEXT,\n          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n        );\n      `;\n            const { error: createError } = await supabase.rpc(\"execute_sql\", {\n                sql: createTableSQL\n            });\n            if (createError) {\n                logger.error(\"Failed to create jobs table via SQL:\", createError);\n                // Try an alternative approach - using the insert API\n                logger.info(\"Trying to create jobs table via insert...\");\n                const { error: insertError } = await supabase.from(\"jobs\").insert({\n                    id: 0,\n                    status: \"test\",\n                    result: null,\n                    error: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                });\n                if (insertError) {\n                    // If Supabase doesn't let us create the table, log what needs to be created\n                    logger.error(\"Cannot create jobs table automatically:\", insertError);\n                    logger.error(\"Please create the jobs table manually with this SQL:\");\n                    logger.error(createTableSQL);\n                } else {\n                    logger.info(\"Jobs table created successfully through insert\");\n                    // Clean up test record\n                    await supabase.from(\"jobs\").delete().eq(\"id\", 0);\n                }\n            } else {\n                logger.info(\"Jobs table created successfully through SQL\");\n            }\n        } catch (sqlError) {\n            logger.error(\"Error executing SQL:\", sqlError.message);\n        }\n    } catch (error) {\n        logger.error(\"Error ensuring jobs table exists:\", error);\n    }\n}\n// Helper function to convert job ID to database-compatible ID\nfunction getDbCompatibleId(id) {\n    // If the ID is already numeric, return it as is\n    if (!isNaN(Number(id))) {\n        return Number(id);\n    }\n    // For job IDs that start with a timestamp (job_ or debug_), extract the timestamp\n    const timestampMatch = id.match(/^(job|debug|test)_(\\d+)/);\n    if (timestampMatch && !isNaN(Number(timestampMatch[2]))) {\n        // Use the timestamp portion as the numeric ID\n        return Number(timestampMatch[2]);\n    }\n    // For any other IDs, use a hash function to generate a numeric ID\n    let hash = 0;\n    const prime = 31; // Use a prime number for better distribution\n    for(let i = 0; i < id.length; i++){\n        // Get the character code\n        const char = id.charCodeAt(i);\n        // Multiply the current hash by the prime and add the character code\n        hash = Math.imul(hash, prime) + char | 0;\n    }\n    // Ensure positive number by using absolute value\n    return Math.abs(hash);\n}\n// Helper function to determine if we should use Supabase\nfunction shouldUseSupabase() {\n    return isSupabaseConfigured && !supabaseDisabled;\n}\n// Helper function to handle and log Supabase errors\nfunction handleSupabaseError(error) {\n    logger.error(\"Supabase operation failed:\", {\n        message: error.message,\n        code: error.code,\n        details: error.details || error.stack?.substring(0, 200)\n    });\n    // If this is a network error, disable Supabase for future operations\n    if (error.message?.includes(\"fetch failed\") || error.message?.includes(\"network error\") || error instanceof TypeError) {\n        logger.warn(\"Disabling Supabase due to connection issues\");\n        supabaseDisabled = true;\n    }\n}\n// Update the status of a job\nasync function updateJobStatus(jobId, status, data) {\n    const updateTime = new Date().toISOString();\n    const dbId = getDbCompatibleId(jobId);\n    logger.info(`Updating job status: ${jobId} -> ${status}`, {\n        dbId,\n        hasResult: !!data?.result,\n        hasError: !!data?.error\n    });\n    if (shouldUseSupabase()) {\n        try {\n            const updateData = {\n                status,\n                updated_at: updateTime\n            };\n            if (data) {\n                if (data.result !== undefined) {\n                    updateData.result = data.result;\n                }\n                if (data.error !== undefined) {\n                    updateData.error = data.error;\n                }\n            }\n            logger.debug(`Supabase update job ${jobId} with data:`, updateData);\n            // Implement retry logic for job updates\n            let retries = 0;\n            const maxRetries = 3;\n            let success = false;\n            while(retries < maxRetries && !success){\n                const { error } = await supabase.from(\"jobs\").update(updateData).eq(\"id\", dbId);\n                if (error) {\n                    logger.warn(`Failed to update job status (attempt ${retries + 1}):`, error);\n                    retries++;\n                    if (retries < maxRetries) {\n                        // Wait a bit before retrying (exponential backoff)\n                        await new Promise((resolve)=>setTimeout(resolve, 200 * Math.pow(2, retries)));\n                    } else {\n                        handleSupabaseError(error);\n                        break;\n                    }\n                } else {\n                    logger.info(`Job ${jobId} status updated successfully to ${status}`);\n                    success = true;\n                }\n            }\n            return success;\n        } catch (error) {\n            handleSupabaseError(error);\n            // Fallback to in-memory storage\n            logger.info(`Falling back to in-memory storage for job ${jobId}`);\n        }\n    }\n    // Fallback to in-memory storage if Supabase is not available\n    if (!inMemoryJobs[jobId]) {\n        inMemoryJobs[jobId] = {\n            id: jobId,\n            status: status,\n            updated_at: updateTime\n        };\n    } else {\n        inMemoryJobs[jobId].status = status;\n        inMemoryJobs[jobId].updated_at = updateTime;\n    }\n    if (data) {\n        if (data.result !== undefined) {\n            inMemoryJobs[jobId].result = data.result;\n        }\n        if (data.error !== undefined) {\n            inMemoryJobs[jobId].error = data.error;\n        }\n    }\n    logger.info(`Updated in-memory job ${jobId} status to ${status}`);\n    return true;\n}\n// Get the status of a job\nasync function getJobStatus(jobId) {\n    const dbId = getDbCompatibleId(jobId);\n    logger.info(`Getting status for job: ${jobId} (db id: ${dbId})`);\n    if (shouldUseSupabase()) {\n        try {\n            logger.debug(`Querying Supabase for job ${jobId}`);\n            // Implement retry logic for job status fetching\n            let retries = 0;\n            const maxRetries = 3;\n            while(retries < maxRetries){\n                const { data, error } = await supabase.from(\"jobs\").select(\"status, result, error, updated_at\").eq(\"id\", dbId).single();\n                if (error) {\n                    logger.warn(`Failed to get job status (attempt ${retries + 1}):`, error);\n                    retries++;\n                    if (retries < maxRetries) {\n                        // Wait a bit before retrying (exponential backoff)\n                        await new Promise((resolve)=>setTimeout(resolve, 200 * Math.pow(2, retries)));\n                    } else {\n                        handleSupabaseError(error);\n                        break;\n                    }\n                } else if (data) {\n                    logger.info(`Job ${jobId} status retrieved: ${data.status}`, {\n                        hasResult: !!data.result,\n                        hasError: !!data.error,\n                        updatedAt: data.updated_at\n                    });\n                    return {\n                        status: data.status,\n                        result: data.result,\n                        error: data.error\n                    };\n                } else {\n                    logger.warn(`Job ${jobId} not found in database`);\n                    break;\n                }\n            }\n            // At this point, either we hit max retries or no data was found\n            // Try fallback to in-memory storage\n            logger.info(`Supabase lookup failed, checking in-memory storage for job ${jobId}`);\n        } catch (error) {\n            handleSupabaseError(error);\n            logger.info(`Falling back to in-memory storage for job ${jobId} after error`);\n        }\n    }\n    // Fallback to in-memory storage\n    if (inMemoryJobs[jobId]) {\n        logger.info(`Found job ${jobId} in memory with status: ${inMemoryJobs[jobId].status}`);\n        return {\n            status: inMemoryJobs[jobId].status,\n            result: inMemoryJobs[jobId].result,\n            error: inMemoryJobs[jobId].error\n        };\n    }\n    logger.warn(`Job ${jobId} not found in any storage`);\n    return {\n        status: \"not_found\"\n    };\n}\n// Create a new job\nasync function createJob(jobId) {\n    const dbId = getDbCompatibleId(jobId);\n    const timestamp = new Date().toISOString();\n    logger.info(`Creating new job: ${jobId} (db id: ${dbId})`);\n    if (shouldUseSupabase()) {\n        try {\n            // Implement retry logic for job creation\n            let retries = 0;\n            const maxRetries = 3;\n            let success = false;\n            while(retries < maxRetries && !success){\n                // Try to insert a new job\n                const { error } = await supabase.from(\"jobs\").insert({\n                    id: dbId,\n                    status: \"queued\",\n                    created_at: timestamp,\n                    updated_at: timestamp\n                });\n                if (error) {\n                    logger.warn(`Failed to create job (attempt ${retries + 1}):`, error);\n                    retries++;\n                    if (retries < maxRetries) {\n                        // Wait a bit before retrying (exponential backoff)\n                        await new Promise((resolve)=>setTimeout(resolve, 200 * Math.pow(2, retries)));\n                    } else {\n                        handleSupabaseError(error);\n                        break;\n                    }\n                } else {\n                    logger.info(`Job ${jobId} created successfully`);\n                    success = true;\n                }\n            }\n            if (success) {\n                return true;\n            }\n            // If we get here, we hit max retries\n            logger.info(`Supabase job creation failed after retries, falling back to in-memory`);\n        } catch (error) {\n            handleSupabaseError(error);\n            logger.info(`Falling back to in-memory storage for job ${jobId} creation`);\n        }\n    }\n    // Fallback to in-memory storage\n    inMemoryJobs[jobId] = {\n        id: jobId,\n        status: \"queued\",\n        created_at: timestamp,\n        updated_at: timestamp\n    };\n    logger.info(`Created in-memory job ${jobId}`);\n    return true;\n}\n// Export the in-memory jobs for debugging\nfunction getInMemoryJobs() {\n    return {\n        ...inMemoryJobs\n    };\n}\n// Function to count jobs by status - useful for diagnostics\nasync function countJobsByStatus() {\n    if (shouldUseSupabase()) {\n        try {\n            logger.debug(\"Counting jobs by status from Supabase\");\n            // Fetch all jobs\n            const { data, error } = await supabase.from(\"jobs\").select(\"status\").order(\"created_at\", {\n                ascending: false\n            }).limit(500);\n            if (error) {\n                handleSupabaseError(error);\n            } else if (data) {\n                // Count jobs by status\n                const statusCounts = {};\n                data.forEach((job)=>{\n                    statusCounts[job.status] = (statusCounts[job.status] || 0) + 1;\n                });\n                logger.info(\"Job count by status:\", statusCounts);\n                return statusCounts;\n            }\n        } catch (error) {\n            handleSupabaseError(error);\n        }\n    }\n    // Fallback to in-memory count\n    const statusCounts = {};\n    Object.values(inMemoryJobs).forEach((job)=>{\n        statusCounts[job.status] = (statusCounts[job.status] || 0) + 1;\n    });\n    logger.info(\"In-memory job count by status:\", statusCounts);\n    return statusCounts;\n}\n// Get recent jobs for diagnostics\nasync function getRecentJobs(limit = 50) {\n    if (shouldUseSupabase()) {\n        try {\n            logger.debug(`Fetching ${limit} recent jobs from Supabase`);\n            const { data, error } = await supabase.from(\"jobs\").select(\"*\").order(\"created_at\", {\n                ascending: false\n            }).limit(limit);\n            if (error) {\n                handleSupabaseError(error);\n            } else if (data) {\n                logger.info(`Retrieved ${data.length} recent jobs from Supabase`);\n                return data;\n            }\n        } catch (error) {\n            handleSupabaseError(error);\n        }\n    }\n    // Fallback to in-memory jobs\n    const jobs = Object.values(inMemoryJobs).sort((a, b)=>(b.created_at || \"\").localeCompare(a.created_at || \"\")).slice(0, limit);\n    logger.info(`Retrieved ${jobs.length} recent jobs from in-memory storage`);\n    return jobs;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU0sMEJBQTBCLENBQUM7WUFFMUQsTUFBTSxFQUFFSCxJQUFJLEVBQUVILEtBQUssRUFBRSxHQUFHLE1BQU1aLFNBQzNCZ0IsSUFBSSxDQUFDLFFBQ0xDLE1BQU0sQ0FBQyxLQUNQa0UsS0FBSyxDQUFDLGNBQWM7Z0JBQUVDLFdBQVc7WUFBTSxHQUN2Q2xFLEtBQUssQ0FBQ0E7WUFFVCxJQUFJTixPQUFPO2dCQUNUK0Msb0JBQW9CL0M7WUFDdEIsT0FBTyxJQUFJRyxNQUFNO2dCQUNmaEQsT0FBT0MsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFK0MsS0FBSy9CLE1BQU0sQ0FBQywwQkFBMEIsQ0FBQztnQkFDaEUsT0FBTytCO1lBQ1Q7UUFDRixFQUFFLE9BQU9ILE9BQU87WUFDZCtDLG9CQUFvQi9DO1FBQ3RCO0lBQ0Y7SUFFQSw2QkFBNkI7SUFDN0IsTUFBTThFLE9BQU8vRyxPQUFPNkcsTUFBTSxDQUFDMUUsY0FDeEI2RSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDQSxFQUFFdkQsVUFBVSxJQUFJLEVBQUMsRUFBR3dELGFBQWEsQ0FBQ0YsRUFBRXRELFVBQVUsSUFBSSxLQUNsRXlELEtBQUssQ0FBQyxHQUFHN0U7SUFFWm5ELE9BQU9DLElBQUksQ0FBQyxDQUFDLFVBQVUsRUFBRTBILEtBQUsxRyxNQUFNLENBQUMsbUNBQW1DLENBQUM7SUFDekUsT0FBTzBHO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10cmF2ZWwtYWdlbnQvLi9saWIvc3VwYWJhc2UudHM/Yzk5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuXG4vLyBDcmVhdGUgYSBsb2dnZXIgZm9yIHRoZSBTdXBhYmFzZSBtb2R1bGVcbmNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcignc3VwYWJhc2UnKTtcblxuLy8gRXhwbGljaXRseSBsb2cgYWxsIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgZGVidWdnaW5nXG5sb2dnZXIuaW5mbygnU3VwYWJhc2UgaW5pdGlhbGl6YXRpb24nLCB7XG4gIE5PREVfRU5WOiBwcm9jZXNzLmVudi5OT0RFX0VOVixcbiAgaGFzUHJvY2Vzc0VudjogdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICEhcHJvY2Vzcy5lbnYsXG4gIG5vZGVFbnY6IHByb2Nlc3MuZW52Lk5PREVfRU5WLFxuICBoYXNTYlVybDogJ05FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCcgaW4gcHJvY2Vzcy5lbnYsXG4gIGhhc1NiS2V5OiAnTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVknIGluIHByb2Nlc3MuZW52LFxuICBuZXh0Q29uZmlnOiB0eXBlb2YgcHJvY2Vzcy5lbnYuTkVYVF9DT05GSUdfQVZBSUxBQkxFID09PSAnc3RyaW5nJyxcbiAgZW52VmFyQ291bnQ6IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdORVhUXycpKS5sZW5ndGhcbn0pO1xuXG4vLyBTdXBhYmFzZSBjbGllbnQgc2V0dXBcbi8vIERpcmVjdGx5IGFjY2VzcyB2YXJpYWJsZXMgZm9yIGRlYnVnZ2luZyByYXRoZXIgdGhhbiB1c2luZyB8fCAnJyBwYXR0ZXJuIGluaXRpYWxseVxubGV0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xubGV0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZO1xuXG4vLyBEZWJ1ZyBTdXBhYmFzZSBzZXR1cCB3aXRob3V0IGV4cG9zaW5nIGtleXNcbmxvZ2dlci5kZWJ1ZygnU3VwYWJhc2UgY3JlZGVudGlhbHMnLCB7XG4gIHVybFByZWZpeDogc3VwYWJhc2VVcmw/LnN1YnN0cmluZygwLCAxMikgKyAnLi4uJyB8fCAndW5kZWZpbmVkJyxcbiAga2V5UHJlZml4OiBzdXBhYmFzZUFub25LZXk/LnN1YnN0cmluZygwLCA2KSArICcuLi4nIHx8ICd1bmRlZmluZWQnLFxufSk7XG5cbi8vIEZhbGxiYWNrIHRvIGVtcHR5IHN0cmluZyBpZiB1bmRlZmluZWRcbnN1cGFiYXNlVXJsID0gc3VwYWJhc2VVcmwgfHwgJyc7XG5zdXBhYmFzZUFub25LZXkgPSBzdXBhYmFzZUFub25LZXkgfHwgJyc7XG5cbi8vIERlYnVnIFN1cGFiYXNlIHNldHVwIHdpdGhvdXQgZXhwb3Npbmcga2V5c1xubG9nZ2VyLmluZm8oJ1N1cGFiYXNlIGNvbmZpZ3VyYXRpb24gY2hlY2snLCB7XG4gIGhhc1VybDogQm9vbGVhbihzdXBhYmFzZVVybCksXG4gIHVybExlbmd0aDogc3VwYWJhc2VVcmw/Lmxlbmd0aCB8fCAwLFxuICB1cmxQcmVmaXg6IHN1cGFiYXNlVXJsPy5zdWJzdHJpbmcoMCwgOCkgfHwgJycsXG4gIGhhc0tleTogQm9vbGVhbihzdXBhYmFzZUFub25LZXkpLFxuICBrZXlMZW5ndGg6IHN1cGFiYXNlQW5vbktleT8ubGVuZ3RoIHx8IDAsXG4gIGtleVByZWZpeDogc3VwYWJhc2VBbm9uS2V5Py5zdWJzdHJpbmcoMCwgNCkgfHwgJydcbn0pO1xuXG4vLyBUeXBlIGRlZmluaXRpb24gZm9yIGpvYiBkYXRhXG5leHBvcnQgdHlwZSBKb2JEYXRhID0ge1xuICBpZDogc3RyaW5nO1xuICBzdGF0dXM6ICdxdWV1ZWQnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZmFpbGVkJyB8ICdub3RfZm91bmQnO1xuICByZXN1bHQ/OiBhbnk7XG4gIGVycm9yPzogc3RyaW5nO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59O1xuXG4vLyBDaGVjayBpZiBTdXBhYmFzZSBpcyBjb25maWd1cmVkIHByb3Blcmx5XG5jb25zdCBpc1N1cGFiYXNlQ29uZmlndXJlZCA9IEJvb2xlYW4oc3VwYWJhc2VVcmwgJiYgc3VwYWJhc2VBbm9uS2V5KTtcblxuLy8gSW4tbWVtb3J5IHN0b3JlIHRvIHRyYWNrIGlmIFN1cGFiYXNlIGNvbm5lY3Rpdml0eSBmYWlsZWQgZHVyaW5nIHJ1bnRpbWVcbmxldCBzdXBhYmFzZURpc2FibGVkID0gZmFsc2U7XG5cbi8vIEluaXRpYWxpemUgdGhlIFN1cGFiYXNlIGNsaWVudCB3aXRoIGV4cGxpY2l0IG9wdGlvbnMgZm9yIGJldHRlciByZWxpYWJpbGl0eVxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gaXNTdXBhYmFzZUNvbmZpZ3VyZWRcbiAgPyBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRiOiB7XG4gICAgICAgIHNjaGVtYTogJ3B1YmxpYydcbiAgICAgIH1cbiAgICB9KVxuICA6IGNyZWF0ZUNsaWVudCgnaHR0cHM6Ly9wbGFjZWhvbGRlci11cmwuc3VwYWJhc2UuY28nLCAncGxhY2Vob2xkZXIta2V5Jywge1xuICAgICAgYXV0aDoge1xuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuLy8gTG9nIGluaXRpYWxpemF0aW9uIHN0YXR1c1xuaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkge1xuICBsb2dnZXIud2FybignU3VwYWJhc2Ugbm90IHByb3Blcmx5IGNvbmZpZ3VyZWQuIFVzaW5nIGluLW1lbW9yeSBqb2Igc3RvcmFnZSBhcyBmYWxsYmFjay4nKTtcbn0gZWxzZSB7XG4gIGxvZ2dlci5pbmZvKCdTdXBhYmFzZSBjbGllbnQgaW5pdGlhbGl6ZWQsIHZlcmlmeWluZyBjb25uZWN0aW9uLi4uJyk7XG4gIC8vIEF0dGVtcHQgdG8gdmVyaWZ5IGNvbm5lY3Rpb24gYW5kIGVuc3VyZSB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgdmVyaWZ5U3VwYWJhc2VDb25uZWN0aW9uKCkuY2F0Y2goZXJyID0+IHtcbiAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byB2ZXJpZnkgU3VwYWJhc2UgY29ubmVjdGlvbjonLCBlcnIubWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBJbi1tZW1vcnkgZmFsbGJhY2sgc3RvcmUgZm9yIGRldmVsb3BtZW50IG9yIHdoZW4gU3VwYWJhc2UgaXNuJ3QgY29uZmlndXJlZFxuY29uc3QgaW5NZW1vcnlKb2JzOiBSZWNvcmQ8c3RyaW5nLCBKb2JEYXRhPiA9IHt9O1xuXG4vLyBGdW5jdGlvbiB0byB2ZXJpZnkgdGhlIFN1cGFiYXNlIGNvbm5lY3Rpb25cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVN1cGFiYXNlQ29ubmVjdGlvbigpIHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBsb2dnZXIuaW5mbygnQ2hlY2tpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB0byBkaXJlY3RseSBxdWVyeSBpZiB0aGUgam9icyB0YWJsZSBleGlzdHNcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAubGltaXQoMSk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAvLyBUYWJsZSBtaWdodCBub3QgZXhpc3RcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnNDJQMDEnKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdKb2JzIHRhYmxlIGRvZXMgbm90IGV4aXN0LCB3aWxsIGF0dGVtcHQgdG8gY3JlYXRlIGl0Jyk7XG4gICAgICAgIGF3YWl0IGVuc3VyZUpvYnNUYWJsZUV4aXN0cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdTdXBhYmFzZSBjb25uZWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6Jywge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuaW5mbygnU3VwYWJhc2UgY29ubmVjdGlvbiB2ZXJpZmllZCBzdWNjZXNzZnVsbHksIGpvYnMgdGFibGUgZXhpc3RzJyk7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSB0aGUgcmlnaHQgY29sdW1uc1xuICAgICAgYXdhaXQgY2hlY2tUYWJsZVN0cnVjdHVyZShkYXRhKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBTdXBhYmFzZSBjb25uZWN0aW9uOicsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBzdGFjazogZXJyb3Iuc3RhY2s/LnN1YnN0cmluZygwLCAyMDApXG4gICAgfSk7XG4gICAgXG4gICAgLy8gSWYgdGhpcyBpcyBhIG5ldHdvcmsgZXJyb3IsIGRpc2FibGUgU3VwYWJhc2VcbiAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2ZldGNoIGZhaWxlZCcpIHx8IFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbmV0d29yayBlcnJvcicpIHx8XG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICBsb2dnZXIud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aW9uIGlzc3VlcycpO1xuICAgICAgc3VwYWJhc2VEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIENoZWNrIGFuZCBhZGFwdCB0byBleGlzdGluZyB0YWJsZSBzdHJ1Y3R1cmVcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrVGFibGVTdHJ1Y3R1cmUoc2FtcGxlRGF0YTogYW55W10pIHtcbiAgaWYgKHNhbXBsZURhdGEgJiYgc2FtcGxlRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgLy8gTG9nIHRoZSBzdHJ1Y3R1cmUgd2UgZm91bmQgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IGZpcnN0Um93ID0gc2FtcGxlRGF0YVswXTtcbiAgICBsb2dnZXIuZGVidWcoJ0ZvdW5kIGV4aXN0aW5nIGpvYnMgdGFibGUgd2l0aCBjb2x1bW5zOicsIE9iamVjdC5rZXlzKGZpcnN0Um93KS5qb2luKCcsICcpKTtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBjaGVjayBhbmQgY3JlYXRlIHRoZSBqb2JzIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUpvYnNUYWJsZUV4aXN0cygpIHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCkgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBsb2dnZXIuaW5mbygnQXR0ZW1wdGluZyB0byBjcmVhdGUgam9icyB0YWJsZS4uLicpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgcGVybWlzc2lvbiB0byBleGVjdXRlIFNRTFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCwgdHJ5IHRvIGNyZWF0ZSBhIHNpbXBsZSB0YWJsZSB3aXRoIHRoZSBtaW5pbXVtIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgY29uc3QgY3JlYXRlVGFibGVTUUwgPSBgXG4gICAgICAgIENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIGpvYnMgKFxuICAgICAgICAgIGlkIEJJR0lOVCBQUklNQVJZIEtFWSxcbiAgICAgICAgICBzdGF0dXMgVEVYVCxcbiAgICAgICAgICByZXN1bHQgSlNPTkIsXG4gICAgICAgICAgZXJyb3IgVEVYVCxcbiAgICAgICAgICBjcmVhdGVkX2F0IFRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORSBERUZBVUxUIE5PVygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQgVElNRVNUQU1QIFdJVEggVElNRSBaT05FIERFRkFVTFQgTk9XKClcbiAgICAgICAgKTtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ2V4ZWN1dGVfc3FsJywgeyBzcWw6IGNyZWF0ZVRhYmxlU1FMIH0pO1xuICAgICAgXG4gICAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGpvYnMgdGFibGUgdmlhIFNRTDonLCBjcmVhdGVFcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgYW4gYWx0ZXJuYXRpdmUgYXBwcm9hY2ggLSB1c2luZyB0aGUgaW5zZXJ0IEFQSVxuICAgICAgICBsb2dnZXIuaW5mbygnVHJ5aW5nIHRvIGNyZWF0ZSBqb2JzIHRhYmxlIHZpYSBpbnNlcnQuLi4nKTtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICBzdGF0dXM6ICd0ZXN0JyxcbiAgICAgICAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICAgIC8vIElmIFN1cGFiYXNlIGRvZXNuJ3QgbGV0IHVzIGNyZWF0ZSB0aGUgdGFibGUsIGxvZyB3aGF0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCBjcmVhdGUgam9icyB0YWJsZSBhdXRvbWF0aWNhbGx5OicsIGluc2VydEVycm9yKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1BsZWFzZSBjcmVhdGUgdGhlIGpvYnMgdGFibGUgbWFudWFsbHkgd2l0aCB0aGlzIFNRTDonKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoY3JlYXRlVGFibGVTUUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggaW5zZXJ0Jyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgdGVzdCByZWNvcmRcbiAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdqb2JzJykuZGVsZXRlKCkuZXEoJ2lkJywgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdKb2JzIHRhYmxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHRocm91Z2ggU1FMJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoc3FsRXJyb3I6IGFueSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBleGVjdXRpbmcgU1FMOicsIHNxbEVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZW5zdXJpbmcgam9icyB0YWJsZSBleGlzdHM6JywgZXJyb3IpO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGpvYiBJRCB0byBkYXRhYmFzZS1jb21wYXRpYmxlIElEXG5mdW5jdGlvbiBnZXREYkNvbXBhdGlibGVJZChpZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgLy8gSWYgdGhlIElEIGlzIGFscmVhZHkgbnVtZXJpYywgcmV0dXJuIGl0IGFzIGlzXG4gIGlmICghaXNOYU4oTnVtYmVyKGlkKSkpIHtcbiAgICByZXR1cm4gTnVtYmVyKGlkKTtcbiAgfVxuICBcbiAgLy8gRm9yIGpvYiBJRHMgdGhhdCBzdGFydCB3aXRoIGEgdGltZXN0YW1wIChqb2JfIG9yIGRlYnVnXyksIGV4dHJhY3QgdGhlIHRpbWVzdGFtcFxuICBjb25zdCB0aW1lc3RhbXBNYXRjaCA9IGlkLm1hdGNoKC9eKGpvYnxkZWJ1Z3x0ZXN0KV8oXFxkKykvKTtcbiAgaWYgKHRpbWVzdGFtcE1hdGNoICYmICFpc05hTihOdW1iZXIodGltZXN0YW1wTWF0Y2hbMl0pKSkge1xuICAgIC8vIFVzZSB0aGUgdGltZXN0YW1wIHBvcnRpb24gYXMgdGhlIG51bWVyaWMgSURcbiAgICByZXR1cm4gTnVtYmVyKHRpbWVzdGFtcE1hdGNoWzJdKTtcbiAgfVxuXG4gIC8vIEZvciBhbnkgb3RoZXIgSURzLCB1c2UgYSBoYXNoIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbnVtZXJpYyBJRFxuICBsZXQgaGFzaCA9IDA7XG4gIGNvbnN0IHByaW1lID0gMzE7IC8vIFVzZSBhIHByaW1lIG51bWJlciBmb3IgYmV0dGVyIGRpc3RyaWJ1dGlvblxuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIC8vIEdldCB0aGUgY2hhcmFjdGVyIGNvZGVcbiAgICBjb25zdCBjaGFyID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAvLyBNdWx0aXBseSB0aGUgY3VycmVudCBoYXNoIGJ5IHRoZSBwcmltZSBhbmQgYWRkIHRoZSBjaGFyYWN0ZXIgY29kZVxuICAgIGhhc2ggPSBNYXRoLmltdWwoaGFzaCwgcHJpbWUpICsgY2hhciB8IDA7XG4gIH1cbiAgXG4gIC8vIEVuc3VyZSBwb3NpdGl2ZSBudW1iZXIgYnkgdXNpbmcgYWJzb2x1dGUgdmFsdWVcbiAgcmV0dXJuIE1hdGguYWJzKGhhc2gpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgU3VwYWJhc2VcbmZ1bmN0aW9uIHNob3VsZFVzZVN1cGFiYXNlKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNTdXBhYmFzZUNvbmZpZ3VyZWQgJiYgIXN1cGFiYXNlRGlzYWJsZWQ7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgYW5kIGxvZyBTdXBhYmFzZSBlcnJvcnNcbmZ1bmN0aW9uIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3I6IGFueSk6IHZvaWQge1xuICBsb2dnZXIuZXJyb3IoJ1N1cGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQ6Jywge1xuICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgY29kZTogZXJyb3IuY29kZSxcbiAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzIHx8IGVycm9yLnN0YWNrPy5zdWJzdHJpbmcoMCwgMjAwKVxuICB9KTtcbiAgXG4gIC8vIElmIHRoaXMgaXMgYSBuZXR3b3JrIGVycm9yLCBkaXNhYmxlIFN1cGFiYXNlIGZvciBmdXR1cmUgb3BlcmF0aW9uc1xuICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2ZldGNoIGZhaWxlZCcpIHx8IFxuICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsgZXJyb3InKSB8fFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICBsb2dnZXIud2FybignRGlzYWJsaW5nIFN1cGFiYXNlIGR1ZSB0byBjb25uZWN0aW9uIGlzc3VlcycpO1xuICAgIHN1cGFiYXNlRGlzYWJsZWQgPSB0cnVlO1xuICB9XG59XG5cbi8vIFVwZGF0ZSB0aGUgc3RhdHVzIG9mIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSm9iU3RhdHVzKFxuICBqb2JJZDogc3RyaW5nLCBcbiAgc3RhdHVzOiAncXVldWVkJyB8ICdwcm9jZXNzaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCcsIFxuICBkYXRhPzogeyByZXN1bHQ/OiBhbnk7IGVycm9yPzogc3RyaW5nIH1cbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCB1cGRhdGVUaW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBkYklkID0gZ2V0RGJDb21wYXRpYmxlSWQoam9iSWQpO1xuICBcbiAgbG9nZ2VyLmluZm8oYFVwZGF0aW5nIGpvYiBzdGF0dXM6ICR7am9iSWR9IC0+ICR7c3RhdHVzfWAsIHsgXG4gICAgZGJJZCwgXG4gICAgaGFzUmVzdWx0OiAhIWRhdGE/LnJlc3VsdCwgXG4gICAgaGFzRXJyb3I6ICEhZGF0YT8uZXJyb3IgXG4gIH0pO1xuXG4gIGlmIChzaG91bGRVc2VTdXBhYmFzZSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICB1cGRhdGVkX2F0OiB1cGRhdGVUaW1lXG4gICAgICB9O1xuICAgICAgXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwZGF0ZURhdGEucmVzdWx0ID0gZGF0YS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRhLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cGRhdGVEYXRhLmVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBsb2dnZXIuZGVidWcoYFN1cGFiYXNlIHVwZGF0ZSBqb2IgJHtqb2JJZH0gd2l0aCBkYXRhOmAsIHVwZGF0ZURhdGEpO1xuICAgICAgXG4gICAgICAvLyBJbXBsZW1lbnQgcmV0cnkgbG9naWMgZm9yIGpvYiB1cGRhdGVzXG4gICAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcbiAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG4gICAgICBcbiAgICAgIHdoaWxlIChyZXRyaWVzIDwgbWF4UmV0cmllcyAmJiAhc3VjY2Vzcykge1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdqb2JzJylcbiAgICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgICAgLmVxKCdpZCcsIGRiSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byB1cGRhdGUgam9iIHN0YXR1cyAoYXR0ZW1wdCAke3JldHJpZXMgKyAxfSk6YCwgZXJyb3IpO1xuICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocmV0cmllcyA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgYmVmb3JlIHJldHJ5aW5nIChleHBvbmVudGlhbCBiYWNrb2ZmKVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gc3RhdHVzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IHRvICR7c3RhdHVzfWApO1xuICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlXG4gICAgICBsb2dnZXIuaW5mbyhgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGlmIFN1cGFiYXNlIGlzIG5vdCBhdmFpbGFibGVcbiAgaWYgKCFpbk1lbW9yeUpvYnNbam9iSWRdKSB7XG4gICAgaW5NZW1vcnlKb2JzW2pvYklkXSA9IHtcbiAgICAgIGlkOiBqb2JJZCxcbiAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgdXBkYXRlZF9hdDogdXBkYXRlVGltZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW5NZW1vcnlKb2JzW2pvYklkXS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgaW5NZW1vcnlKb2JzW2pvYklkXS51cGRhdGVkX2F0ID0gdXBkYXRlVGltZTtcbiAgfVxuICBcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5NZW1vcnlKb2JzW2pvYklkXS5yZXN1bHQgPSBkYXRhLnJlc3VsdDtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGEuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5NZW1vcnlKb2JzW2pvYklkXS5lcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICBsb2dnZXIuaW5mbyhgVXBkYXRlZCBpbi1tZW1vcnkgam9iICR7am9iSWR9IHN0YXR1cyB0byAke3N0YXR1c31gKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEdldCB0aGUgc3RhdHVzIG9mIGEgam9iXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iU3RhdHVzKGpvYklkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IHJlc3VsdD86IGFueTsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICBjb25zdCBkYklkID0gZ2V0RGJDb21wYXRpYmxlSWQoam9iSWQpO1xuICBcbiAgbG9nZ2VyLmluZm8oYEdldHRpbmcgc3RhdHVzIGZvciBqb2I6ICR7am9iSWR9IChkYiBpZDogJHtkYklkfSlgKTtcbiAgXG4gIGlmIChzaG91bGRVc2VTdXBhYmFzZSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgUXVlcnlpbmcgU3VwYWJhc2UgZm9yIGpvYiAke2pvYklkfWApO1xuICAgICAgXG4gICAgICAvLyBJbXBsZW1lbnQgcmV0cnkgbG9naWMgZm9yIGpvYiBzdGF0dXMgZmV0Y2hpbmdcbiAgICAgIGxldCByZXRyaWVzID0gMDtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzO1xuICAgICAgXG4gICAgICB3aGlsZSAocmV0cmllcyA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnam9icycpXG4gICAgICAgICAgLnNlbGVjdCgnc3RhdHVzLCByZXN1bHQsIGVycm9yLCB1cGRhdGVkX2F0JylcbiAgICAgICAgICAuZXEoJ2lkJywgZGJJZClcbiAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRmFpbGVkIHRvIGdldCBqb2Igc3RhdHVzIChhdHRlbXB0ICR7cmV0cmllcyArIDF9KTpgLCBlcnJvcik7XG4gICAgICAgICAgcmV0cmllcysrO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZXRyaWVzIDwgbWF4UmV0cmllcykge1xuICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwICogTWF0aC5wb3coMiwgcmV0cmllcykpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBKb2IgJHtqb2JJZH0gc3RhdHVzIHJldHJpZXZlZDogJHtkYXRhLnN0YXR1c31gLCB7XG4gICAgICAgICAgICBoYXNSZXN1bHQ6ICEhZGF0YS5yZXN1bHQsXG4gICAgICAgICAgICBoYXNFcnJvcjogISFkYXRhLmVycm9yLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnVwZGF0ZWRfYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3VsdDogZGF0YS5yZXN1bHQsXG4gICAgICAgICAgICBlcnJvcjogZGF0YS5lcnJvclxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEpvYiAke2pvYklkfSBub3QgZm91bmQgaW4gZGF0YWJhc2VgKTtcbiAgICAgICAgICAvLyBObyBkYXRhIGZvdW5kLCBicmVhayB0aGUgbG9vcFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoaXQgbWF4IHJldHJpZXMgb3Igbm8gZGF0YSB3YXMgZm91bmRcbiAgICAgIC8vIFRyeSBmYWxsYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZVxuICAgICAgbG9nZ2VyLmluZm8oYFN1cGFiYXNlIGxvb2t1cCBmYWlsZWQsIGNoZWNraW5nIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgICBsb2dnZXIuaW5mbyhgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH0gYWZ0ZXIgZXJyb3JgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlXG4gIGlmIChpbk1lbW9yeUpvYnNbam9iSWRdKSB7XG4gICAgbG9nZ2VyLmluZm8oYEZvdW5kIGpvYiAke2pvYklkfSBpbiBtZW1vcnkgd2l0aCBzdGF0dXM6ICR7aW5NZW1vcnlKb2JzW2pvYklkXS5zdGF0dXN9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogaW5NZW1vcnlKb2JzW2pvYklkXS5zdGF0dXMsXG4gICAgICByZXN1bHQ6IGluTWVtb3J5Sm9ic1tqb2JJZF0ucmVzdWx0LFxuICAgICAgZXJyb3I6IGluTWVtb3J5Sm9ic1tqb2JJZF0uZXJyb3JcbiAgICB9O1xuICB9XG4gIFxuICBsb2dnZXIud2FybihgSm9iICR7am9iSWR9IG5vdCBmb3VuZCBpbiBhbnkgc3RvcmFnZWApO1xuICByZXR1cm4geyBzdGF0dXM6ICdub3RfZm91bmQnIH07XG59XG5cbi8vIENyZWF0ZSBhIG5ldyBqb2JcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVKb2Ioam9iSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBkYklkID0gZ2V0RGJDb21wYXRpYmxlSWQoam9iSWQpO1xuICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIFxuICBsb2dnZXIuaW5mbyhgQ3JlYXRpbmcgbmV3IGpvYjogJHtqb2JJZH0gKGRiIGlkOiAke2RiSWR9KWApO1xuICBcbiAgaWYgKHNob3VsZFVzZVN1cGFiYXNlKCkpIHtcbiAgICB0cnkge1xuICAgICAgLy8gSW1wbGVtZW50IHJldHJ5IGxvZ2ljIGZvciBqb2IgY3JlYXRpb25cbiAgICAgIGxldCByZXRyaWVzID0gMDtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzO1xuICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgd2hpbGUgKHJldHJpZXMgPCBtYXhSZXRyaWVzICYmICFzdWNjZXNzKSB7XG4gICAgICAgIC8vIFRyeSB0byBpbnNlcnQgYSBuZXcgam9iXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgaWQ6IGRiSWQsXG4gICAgICAgICAgICBzdGF0dXM6ICdxdWV1ZWQnLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogdGltZXN0YW1wLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogdGltZXN0YW1wXG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRmFpbGVkIHRvIGNyZWF0ZSBqb2IgKGF0dGVtcHQgJHtyZXRyaWVzICsgMX0pOmAsIGVycm9yKTtcbiAgICAgICAgICByZXRyaWVzKys7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHJldHJpZXMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGEgYml0IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZilcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgSm9iICR7am9iSWR9IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoaXQgbWF4IHJldHJpZXNcbiAgICAgIGxvZ2dlci5pbmZvKGBTdXBhYmFzZSBqb2IgY3JlYXRpb24gZmFpbGVkIGFmdGVyIHJldHJpZXMsIGZhbGxpbmcgYmFjayB0byBpbi1tZW1vcnlgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgICBsb2dnZXIuaW5mbyhgRmFsbGluZyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlIGZvciBqb2IgJHtqb2JJZH0gY3JlYXRpb25gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlXG4gIGluTWVtb3J5Sm9ic1tqb2JJZF0gPSB7XG4gICAgaWQ6IGpvYklkLFxuICAgIHN0YXR1czogJ3F1ZXVlZCcsXG4gICAgY3JlYXRlZF9hdDogdGltZXN0YW1wLFxuICAgIHVwZGF0ZWRfYXQ6IHRpbWVzdGFtcFxuICB9O1xuICBcbiAgbG9nZ2VyLmluZm8oYENyZWF0ZWQgaW4tbWVtb3J5IGpvYiAke2pvYklkfWApO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gRXhwb3J0IHRoZSBpbi1tZW1vcnkgam9icyBmb3IgZGVidWdnaW5nXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5NZW1vcnlKb2JzKCkge1xuICByZXR1cm4geyAuLi5pbk1lbW9yeUpvYnMgfTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY291bnQgam9icyBieSBzdGF0dXMgLSB1c2VmdWwgZm9yIGRpYWdub3N0aWNzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY291bnRKb2JzQnlTdGF0dXMoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiB7XG4gIGlmIChzaG91bGRVc2VTdXBhYmFzZSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ291bnRpbmcgam9icyBieSBzdGF0dXMgZnJvbSBTdXBhYmFzZScpO1xuICAgICAgXG4gICAgICAvLyBGZXRjaCBhbGwgam9ic1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAuc2VsZWN0KCdzdGF0dXMnKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLmxpbWl0KDUwMCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAvLyBDb3VudCBqb2JzIGJ5IHN0YXR1c1xuICAgICAgICBjb25zdCBzdGF0dXNDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgICAgZGF0YS5mb3JFYWNoKGpvYiA9PiB7XG4gICAgICAgICAgc3RhdHVzQ291bnRzW2pvYi5zdGF0dXNdID0gKHN0YXR1c0NvdW50c1tqb2Iuc3RhdHVzXSB8fCAwKSArIDE7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbG9nZ2VyLmluZm8oJ0pvYiBjb3VudCBieSBzdGF0dXM6Jywgc3RhdHVzQ291bnRzKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1c0NvdW50cztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBpbi1tZW1vcnkgY291bnRcbiAgY29uc3Qgc3RhdHVzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIE9iamVjdC52YWx1ZXMoaW5NZW1vcnlKb2JzKS5mb3JFYWNoKGpvYiA9PiB7XG4gICAgc3RhdHVzQ291bnRzW2pvYi5zdGF0dXNdID0gKHN0YXR1c0NvdW50c1tqb2Iuc3RhdHVzXSB8fCAwKSArIDE7XG4gIH0pO1xuICBcbiAgbG9nZ2VyLmluZm8oJ0luLW1lbW9yeSBqb2IgY291bnQgYnkgc3RhdHVzOicsIHN0YXR1c0NvdW50cyk7XG4gIHJldHVybiBzdGF0dXNDb3VudHM7XG59XG5cbi8vIEdldCByZWNlbnQgam9icyBmb3IgZGlhZ25vc3RpY3NcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNlbnRKb2JzKGxpbWl0ID0gNTApOiBQcm9taXNlPEpvYkRhdGFbXT4ge1xuICBpZiAoc2hvdWxkVXNlU3VwYWJhc2UoKSkge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoYEZldGNoaW5nICR7bGltaXR9IHJlY2VudCBqb2JzIGZyb20gU3VwYWJhc2VgKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2pvYnMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdChsaW1pdCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBoYW5kbGVTdXBhYmFzZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICBsb2dnZXIuaW5mbyhgUmV0cmlldmVkICR7ZGF0YS5sZW5ndGh9IHJlY2VudCBqb2JzIGZyb20gU3VwYWJhc2VgKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gaW4tbWVtb3J5IGpvYnNcbiAgY29uc3Qgam9icyA9IE9iamVjdC52YWx1ZXMoaW5NZW1vcnlKb2JzKVxuICAgIC5zb3J0KChhLCBiKSA9PiAoYi5jcmVhdGVkX2F0IHx8ICcnKS5sb2NhbGVDb21wYXJlKGEuY3JlYXRlZF9hdCB8fCAnJykpXG4gICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgXG4gIGxvZ2dlci5pbmZvKGBSZXRyaWV2ZWQgJHtqb2JzLmxlbmd0aH0gcmVjZW50IGpvYnMgZnJvbSBpbi1tZW1vcnkgc3RvcmFnZWApO1xuICByZXR1cm4gam9icztcbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImNyZWF0ZUxvZ2dlciIsImxvZ2dlciIsImluZm8iLCJOT0RFX0VOViIsImhhc1Byb2Nlc3NFbnYiLCJwcm9jZXNzIiwiZW52Iiwibm9kZUVudiIsImhhc1NiVXJsIiwiaGFzU2JLZXkiLCJuZXh0Q29uZmlnIiwiTkVYVF9DT05GSUdfQVZBSUxBQkxFIiwiZW52VmFyQ291bnQiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwia2V5Iiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInN1cGFiYXNlVXJsIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJkZWJ1ZyIsInVybFByZWZpeCIsInN1YnN0cmluZyIsImtleVByZWZpeCIsImhhc1VybCIsIkJvb2xlYW4iLCJ1cmxMZW5ndGgiLCJoYXNLZXkiLCJrZXlMZW5ndGgiLCJpc1N1cGFiYXNlQ29uZmlndXJlZCIsInN1cGFiYXNlRGlzYWJsZWQiLCJzdXBhYmFzZSIsImF1dGgiLCJwZXJzaXN0U2Vzc2lvbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJnbG9iYWwiLCJoZWFkZXJzIiwiZGIiLCJzY2hlbWEiLCJ3YXJuIiwidmVyaWZ5U3VwYWJhc2VDb25uZWN0aW9uIiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsIm1lc3NhZ2UiLCJpbk1lbW9yeUpvYnMiLCJkYXRhIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwiY29kZSIsImVuc3VyZUpvYnNUYWJsZUV4aXN0cyIsImRldGFpbHMiLCJjaGVja1RhYmxlU3RydWN0dXJlIiwic3RhY2siLCJpbmNsdWRlcyIsIlR5cGVFcnJvciIsInNhbXBsZURhdGEiLCJmaXJzdFJvdyIsImpvaW4iLCJjcmVhdGVUYWJsZVNRTCIsImNyZWF0ZUVycm9yIiwicnBjIiwic3FsIiwiaW5zZXJ0RXJyb3IiLCJpbnNlcnQiLCJpZCIsInN0YXR1cyIsInJlc3VsdCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZGVsZXRlIiwiZXEiLCJzcWxFcnJvciIsImdldERiQ29tcGF0aWJsZUlkIiwiaXNOYU4iLCJOdW1iZXIiLCJ0aW1lc3RhbXBNYXRjaCIsIm1hdGNoIiwiaGFzaCIsInByaW1lIiwiaSIsImNoYXIiLCJjaGFyQ29kZUF0IiwiTWF0aCIsImltdWwiLCJhYnMiLCJzaG91bGRVc2VTdXBhYmFzZSIsImhhbmRsZVN1cGFiYXNlRXJyb3IiLCJ1cGRhdGVKb2JTdGF0dXMiLCJqb2JJZCIsInVwZGF0ZVRpbWUiLCJkYklkIiwiaGFzUmVzdWx0IiwiaGFzRXJyb3IiLCJ1cGRhdGVEYXRhIiwidW5kZWZpbmVkIiwicmV0cmllcyIsIm1heFJldHJpZXMiLCJzdWNjZXNzIiwidXBkYXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicG93IiwiZ2V0Sm9iU3RhdHVzIiwic2luZ2xlIiwidXBkYXRlZEF0IiwiY3JlYXRlSm9iIiwidGltZXN0YW1wIiwiZ2V0SW5NZW1vcnlKb2JzIiwiY291bnRKb2JzQnlTdGF0dXMiLCJvcmRlciIsImFzY2VuZGluZyIsInN0YXR1c0NvdW50cyIsImZvckVhY2giLCJqb2IiLCJ2YWx1ZXMiLCJnZXRSZWNlbnRKb2JzIiwiam9icyIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fgenerate-itinerary%2Froute&page=%2Fapi%2Fgenerate-itinerary%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fgenerate-itinerary%2Froute.ts&appDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fethanhoppe%2FDesktop%2FAItravelagent&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();